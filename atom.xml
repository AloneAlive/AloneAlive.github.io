<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>sunwengang blog</title>
  
  <subtitle>wizzie</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wizzie.top/"/>
  <updated>2020-03-08T10:26:39.717Z</updated>
  <id>http://wizzie.top/</id>
  
  <author>
    <name>sunwengang</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android Systrace如何抓取分析问题</title>
    <link href="http://wizzie.top/2020/02/22/2020/200222_android_systrace_study/"/>
    <id>http://wizzie.top/2020/02/22/2020/200222_android_systrace_study/</id>
    <published>2020-02-22T12:32:00.000Z</published>
    <updated>2020-03-08T10:26:39.717Z</updated>
    
    <content type="html"><![CDATA[<h2 id="UI流畅平滑的systrace"><a href="#UI流畅平滑的systrace" class="headerlink" title="UI流畅平滑的systrace"></a>UI流畅平滑的systrace</h2><h3 id="Systrace获取："><a href="#Systrace获取：" class="headerlink" title="Systrace获取："></a>Systrace获取：</h3><p>Android\Sdk\platform-tools\systrace</p><p>systrace.py：<br><code>python systrace.py --time=10 -o trace.html gfx input view webview wm am sm audio video hal  res dalvik bionic power pm ss pdx sched freq idle load  binder_driver binder_lock</code></p><p>默认Tag with: <code>sched freq idle res ss gfx input view am</code></p><a id="more"></a><p>常用：<br><code>./systrace -t 3 -b 10240 -o test.html sched freq idle res ss gfx input view am hal power wm</code></p><h3 id="需要开的Tag"><a href="#需要开的Tag" class="headerlink" title="需要开的Tag"></a>需要开的Tag</h3><table><thead><tr><th align="center">需求</th><th align="center">tags</th></tr></thead><tbody><tr><td align="center">cpu信息</td><td align="center">sched/freq/idle</td></tr><tr><td align="center">测试列表滑动，桌面滑动等流畅性问题</td><td align="center">gfx/view/input/hwui</td></tr><tr><td align="center">测试app launch，点击某个应用，点击进入某个界面</td><td align="center">gfx/view/input/dalvik/disk</td></tr><tr><td align="center">怀疑有power问题（亮灭屏，电量相关）</td><td align="center">gfx/view/input/res/am/wm/power</td></tr></tbody></table><h3 id="time和buffer-size"><a href="#time和buffer-size" class="headerlink" title="time和buffer size"></a>time和buffer size</h3><p>一般我给的是<code>-t 3 -b 8000</code></p><ul><li>如果抓5s，-b可以给20480（kb）</li><li>如果时间再长，-b可以给30720（kb）</li></ul><h3 id="视频获取"><a href="#视频获取" class="headerlink" title="视频获取"></a>视频获取</h3><p><code>动画过程</code>:指手机画面开始动的前一帧到画面停止动(完全显示，最后一帧)的过程，所以动画过程时间，依据动画不同，记录的时间也会不同。<br>在播放高清视频时，影格数就表示画面所更新的次数，需要仔细观察视频画面。其中一影格就是手机更新画面时动一次，一般在fps为60的平台上，通常是一帧画面就会动一次，也就是一影格，而对于fps为30的平台，通常是两帧表示一影格。</p><p><code>FPS</code>:表示每秒刷新的帧数，是画面流畅性的一个重要指标,那它是如何计算出来的呢（影格数除以动画时间）</p><p><code>FPS</code>:特定的区段时间内,每秒平均更新画面的次数。</p><ul><li>数值的高低不能代表画面的流畅度</li><li>流畅度还是会跟画面的内容有关系（例如分辨率）</li></ul><p><strong>目前常用的FPS计算方法：</strong></p><ul><li>systrace所录到的<code>queuebuffer</code>个数计算区段时间内的刷新次数</li><li>高速摄影机在区段时间内的刷新次数</li></ul><p>从绘图流程的角度来看,这些FPS的意义是类似的：<br>如果只有单一图层更新的情况,表示从<code>APP画图</code>到<code>display显示</code>的频率。</p><p>常见<code>FPS TestCase</code>：</p><ol><li>App 界面滑动换页的流畅性</li><li>browser浏览网页的流畅性</li><li>包含列表控件(list menu)界面卷动的流畅性</li><li>Contact list界面卷动的流畅性</li><li>Launch app 过场动画流畅性</li><li>Status bar下拉的流畅性</li></ol><h2 id="systrace查看绘制过程是否有问题（FPS）"><a href="#systrace查看绘制过程是否有问题（FPS）" class="headerlink" title="systrace查看绘制过程是否有问题（FPS）"></a>systrace查看绘制过程是否有问题（FPS）</h2><p>如图：<br><img src="systrace1.png" alt="systrace查看绘制"></p><ol><li>首先查看VSYNC周期是否正常，是否有进行vsync tunning；</li><li>查看是否queuebuffer成功？ 绘制之前调用dequeuebufffer从BufferQueue获取一个buffer，绘制完成会调用queuebuffer放回BufferQueue。</li></ol><ul><li>如果正常queuebufffer,则查看SF合成</li><li>如果queuebufffer不正常，则查看是否是queuebuffer阻塞？</li><li><ul><li>如果queuebuffer阻塞，则看GPU</li></ul></li><li><ul><li>若不是，查看HWUI绘制是否成功？</li></ul></li></ul><ol start="3"><li>如果HWUI没有绘制，则检查UIThread（UI线程）</li></ol><ul><li>如果UIThread调用了runnable，则查看SS（不清楚具体表示什么？）</li><li>如果skia耗费太长时间，则查看skia的代码（绘制API）</li><li>如果是view耗费太长时间，则查看view模块的代码</li><li>如果UI线程状态正常，则查看第三方APP是否有问题？</li></ul><ol start="4"><li>如果HWUI绘制了，则检查UIThread和RenderThread（绘制线程）</li></ol><ul><li>UIThread同上</li><li>如果HWUI耗时过长，检查是否阻塞在GL？（openGL）</li><li><ul><li>如果是，则检查GPU</li></ul></li><li><ul><li>如果不是，则检查HWUI模块</li></ul></li></ul><hr><h2 id="上层到底层的模块图-Buffer流程"><a href="#上层到底层的模块图-Buffer流程" class="headerlink" title="上层到底层的模块图(Buffer流程)"></a>上层到底层的模块图(Buffer流程)</h2><p>如图：<br><img src="systrace2.png" alt="上层APP到底层Driver顺序模块"></p><p>从APP开始  –》  然后到View（触发setView，测量布局绘制等操作） –》  然后到绘制，如果是软件绘制就是skia，如果是硬件绘制就是到HWUI，再到OpenGL  –》  接着绘制完成，通过BufferQueue，调用queuebuffer函数  –》  触发SF合成  –》 查看合成方式，如果是GPU合成还是观察OpenGL，然后两种合成方式再调用到HWC模块  –》  然后到底层驱动Display Driver模块  –》  然后到硬件LCD Panel屏幕</p><p><strong>Note:</strong> queubuffer的查看可以分两部分分析：  </p><ol><li>Queue的速度有没有达到预期值？是否时间太长，一直在Queue？</li><li>时间点是否正确，是否绘制完成？是否下一个时间点开始触发SF模块合成流程？</li></ol><hr><h2 id="FPS问题关注点"><a href="#FPS问题关注点" class="headerlink" title="FPS问题关注点"></a>FPS问题关注点</h2><p>如图：<br><img src="systrace3.png" alt="systrace截图分析"></p><ol><li>APP在收到SW Vsync之后，开始产生新的frame</li><li>查看抓取APP的UIThread， 首先是<code>Choreographer#doFrame</code>进行绘制之前的测量、布局，以及reDraw重绘的判断，然后触发HWUI绘制；</li><li>查看DrawFrame部分，开始调用<code>dequeubuffer</code>获取buffer，以及其他GL Function；</li><li>绘制完成后调用<code>eglSwapBuffers</code>，然后再调用<code>queuebuffer</code>将Buffer放回<code>bufferqueue</code>；</li><li>SF在收到下一个SW Vsync之后，从<code>bufferqueue</code>取出buffer，调用onMessageReceived，然后在函数<code>latchBuffer</code>到更新纹理<code>updateTextImage</code>（纹理数据可以通过<code>GAPID</code>工具抓取trace查看），再到<code>acquireBuffer</code>取Buffer；</li><li>合成完成后，HWC将SF传下来的工作排进内部thread（可以查看Dispatcher_0和DispSync）</li><li>HWC处理合成之后，传到底层驱动display driver，然后触发驱动driver（可以查看OverlayEngine_0）</li><li>然后查看当前的<code>DispSync</code>，在当前的<code>sen_sw_sync</code>结束后将frame送到<code>LCD</code></li></ol><h2 id="Vsync周期是否正常"><a href="#Vsync周期是否正常" class="headerlink" title="Vsync周期是否正常"></a>Vsync周期是否正常</h2><p>如图：<br><img src="systrace4.png" alt="systrace截图分析"></p><ol><li>如果是标准60fps刷新率，查看VSYNC的周期是否是<code>16.6ms</code>，绘制是否在这个周期内完成？</li><li>绘制queuebuffer和下一帧合成的时间是否正常？</li></ol><h3 id="底层硬件的FPS是否正常"><a href="#底层硬件的FPS是否正常" class="headerlink" title="底层硬件的FPS是否正常"></a>底层硬件的FPS是否正常</h3><p>如图：<br><img src="systrace5.png" alt="systrace截图分析"></p><p>如果是标准60fps刷新率，查看底层的FPS（HW_VSYNC）是否是16.6ms正常的周期？</p><h2 id="查看queuebuffer周期是否规律"><a href="#查看queuebuffer周期是否规律" class="headerlink" title="查看queuebuffer周期是否规律"></a>查看queuebuffer周期是否规律</h2><p>如图：<br><img src="systrace6.png" alt="systrace截图分析"></p><p><code>hasClientComposition</code>对比<code>hasDeviceComposition</code>两种合成方式。</p><hr><h2 id="硬件绘制和软件绘制如何查看"><a href="#硬件绘制和软件绘制如何查看" class="headerlink" title="硬件绘制和软件绘制如何查看"></a>硬件绘制和软件绘制如何查看</h2><h3 id="硬件绘制"><a href="#硬件绘制" class="headerlink" title="硬件绘制"></a>硬件绘制</h3><blockquote><p><code>HWUI draw</code>会有<code>Record View#draw()</code></p></blockquote><p>如图：<br><img src="systrace7.png" alt="systrace截图分析"></p><h3 id="软件绘制"><a href="#软件绘制" class="headerlink" title="软件绘制"></a>软件绘制</h3><blockquote><p><code>SWUI draw</code>会有<code>drawSoftware lockCanvas</code></p></blockquote><p>如图：<br><img src="systrace8.png" alt="systrace截图分析"></p><hr><h2 id="view耗时太久"><a href="#view耗时太久" class="headerlink" title="view耗时太久"></a><code>view</code>耗时太久</h2><p>如图：<br><img src="systrace9.png" alt="systrace截图分析"></p><p>可以分别查看测量、布局、以及软件/硬件绘制的过程。</p><hr><h2 id="Draw绘制太长"><a href="#Draw绘制太长" class="headerlink" title="Draw绘制太长"></a>Draw绘制太长</h2><blockquote><p><code>注意</code>：systrace (don’t turn on <code>hwui/gfx tag</code>)</p></blockquote><p>如图：<br><img src="systrace10.png" alt="systrace截图分析"></p><p>查看<code>Choreographer#doFrame</code>时长。</p><p>如图：<br><img src="systrace11.png" alt="systrace截图分析"></p><p>然后查看<code>draw</code>的耗时（注意是软件绘制SWUI）</p><h3 id="DrawFrame耗时"><a href="#DrawFrame耗时" class="headerlink" title="DrawFrame耗时"></a><code>DrawFrame</code>耗时</h3><blockquote><p><code>注意</code>：systrace (don’t turn on <code>hwui/gfx tag</code>)</p></blockquote><p>如图：<br><img src="systrace12.png" alt="systrace截图分析"></p><p>如果是标准60FPS帧率，则该函数耗时不要超过16.6ms</p><hr><h2 id="OpenGL-API绘制是否正常"><a href="#OpenGL-API绘制是否正常" class="headerlink" title="OpenGL API绘制是否正常"></a>OpenGL API绘制是否正常</h2><p>需要以下的函数被systrace抓取到，则需要开启<code>GL trace</code>开关：</p><ol><li>adb shell setprop debug.egl.trace systrace</li><li>adb shell stop</li><li>adb shell start (or make sure your app restart)</li><li>Run systrace (<code>需要加上tag：view,input,freq,res,hwui/gfx</code>)</li></ol><p>如图：<br><img src="systrace13.png" alt="systrace截图分析"></p><hr><h2 id="查看systrace的进程状态"><a href="#查看systrace的进程状态" class="headerlink" title="查看systrace的进程状态"></a>查看systrace的进程状态</h2><p>如图：<br><img src="systrace14.png" alt="systrace截图分析"></p><h3 id="选中一个函数的区域（使用箭头）查看进程状态"><a href="#选中一个函数的区域（使用箭头）查看进程状态" class="headerlink" title="选中一个函数的区域（使用箭头）查看进程状态"></a>选中一个函数的区域（使用箭头）查看进程状态</h3><p>如图：<br><img src="systrace15.png" alt="systrace截图分析"></p><blockquote><p>可以选择整个function的process state并确认统计信息,判断是否有runnable/sleep(D/S)过长的现象。</p></blockquote><p>如图：<br><img src="systrace16.png" alt="systrace截图分析"></p><hr><blockquote><p>以下是确定是哪个部分异常，进一步详细调查的方式。</p></blockquote><h2 id="APP-Owner（view模块异常）"><a href="#APP-Owner（view模块异常）" class="headerlink" title="APP Owner（view模块异常）"></a>APP Owner（view模块异常）</h2><blockquote><p>如果已经确定Measure/Layout 占的时间很多。</p></blockquote><ol><li>adb shell setprop debug.view.systraceMeasure true</li><li>adb shell setprop debug.view.systraceLayout true</li><li>adb shell stop</li><li>adb shell start (or make sure your app restart)</li><li>抓取systrace again</li></ol><p>例如下面的例子， 可以发现ListView layout耗时过长。如图：<br><img src="systrace17.png" alt="systrace截图分析"></p><h2 id="APP-Owner（HWUI模块异常）"><a href="#APP-Owner（HWUI模块异常）" class="headerlink" title="APP Owner（HWUI模块异常）"></a>APP Owner（HWUI模块异常）</h2><blockquote><p>到这一步已经没有异常耗时的draw operation, 所以主要是分析<code>APP画图</code>的行为。抓取方式：</p></blockquote><ol><li>adb shell setprop debug.hwui.log.systrace 1</li><li>adb shell dumpsys gfxinfo</li><li>抓取 systrace again (<code>must turn on view,input,freq,res,hwui/gfx</code>)</li></ol><p>如图：<br><img src="systrace18.png" alt="systrace截图分析"></p><hr><h2 id="App-owner-Consult-SS"><a href="#App-owner-Consult-SS" class="headerlink" title="App owner (Consult SS)"></a>App owner (Consult SS)</h2><blockquote><p>进入此状态大多是因为当下系统资源不足而导致，需要case by case 确认可以解决的方案。</p></blockquote><p>如图：<br><img src="systrace19.png" alt="systrace截图分析"></p><ul><li>系统配置信息：</li></ul><p>需要先确定对比机和测试机的系统配置信息<code>CPU cores/freq</code> 可以直接参考systrace (需确认<code>CPU_FREQUENCY event</code>有打开)</p><p>如图：<br><img src="systrace20.png" alt="systrace截图分析"></p><hr><h2 id="App-owner-Consult-SF合成"><a href="#App-owner-Consult-SF合成" class="headerlink" title="App owner (Consult SF合成)"></a>App owner (Consult SF合成)</h2><blockquote><p>需要看trace判断具体问题方向，例如以下几种问题：</p></blockquote><h3 id="Buffer是新的，但是内容还是和上一帧相同"><a href="#Buffer是新的，但是内容还是和上一帧相同" class="headerlink" title="Buffer是新的，但是内容还是和上一帧相同"></a>Buffer是新的，但是内容还是和上一帧相同</h3><p><code>Mali GPU</code>有种<code>smart partial update机制</code>（局部更新）, 不会整个buffer重刷。可以利用<code>debug property</code>先关闭, 视觉上比较容易看：</p><ul><li>adb shell setprop debug.gpu.hwcrc_disabled 1</li><li>adb shell stop</li><li>adb shell start</li></ul><p>如图：<br><img src="systrace21.png" alt="systrace截图分析"></p><h3 id="检查buffer-fence-time同步时间"><a href="#检查buffer-fence-time同步时间" class="headerlink" title="检查buffer fence time同步时间"></a>检查buffer fence time同步时间</h3><p>如图：<br><img src="systrace22.png" alt="systrace截图分析"></p><h3 id="强制GPU合成检查"><a href="#强制GPU合成检查" class="headerlink" title="强制GPU合成检查"></a>强制GPU合成检查</h3><p>在开发者选项中打开GPU强制合成，如果关掉就正常, 问题方向转回到 HWC/driver。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;UI流畅平滑的systrace&quot;&gt;&lt;a href=&quot;#UI流畅平滑的systrace&quot; class=&quot;headerlink&quot; title=&quot;UI流畅平滑的systrace&quot;&gt;&lt;/a&gt;UI流畅平滑的systrace&lt;/h2&gt;&lt;h3 id=&quot;Systrace获取：&quot;&gt;&lt;a href=&quot;#Systrace获取：&quot; class=&quot;headerlink&quot; title=&quot;Systrace获取：&quot;&gt;&lt;/a&gt;Systrace获取：&lt;/h3&gt;&lt;p&gt;Android\Sdk\platform-tools\systrace&lt;/p&gt;
&lt;p&gt;systrace.py：&lt;br&gt;&lt;code&gt;python systrace.py --time=10 -o trace.html gfx input view webview wm am sm audio video hal  res dalvik bionic power pm ss pdx sched freq idle load  binder_driver binder_lock&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;默认Tag with: &lt;code&gt;sched freq idle res ss gfx input view am&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="android" scheme="http://wizzie.top/categories/android/"/>
    
    
      <category term="graphics" scheme="http://wizzie.top/tags/graphics/"/>
    
  </entry>
  
  <entry>
    <title>Android LCD背光驱动节电技术LABC/CABC</title>
    <link href="http://wizzie.top/2020/01/05/2020/200105_android_lcd_cabc/"/>
    <id>http://wizzie.top/2020/01/05/2020/200105_android_lcd_cabc/</id>
    <published>2020-01-05T12:32:00.000Z</published>
    <updated>2020-03-08T10:24:30.225Z</updated>
    
    <content type="html"><![CDATA[<h2 id="LCD背光驱动节电技术LABC-CABC"><a href="#LCD背光驱动节电技术LABC-CABC" class="headerlink" title="LCD背光驱动节电技术LABC/CABC"></a>LCD背光驱动节电技术LABC/CABC</h2><blockquote><p>手机屏幕大部分是LCD（还有OLED屏幕），而手机的部分电量就是LCD背光消耗的。随着分辨率/尺寸的增大，LCD的背光驱动电路也越来越复杂。而高分辨率、高显示颜色、大尺寸的LCD，需要大的背光系统、大的TFT-LCD 面版、高运算速度的驱动IC，这些都造成了高的功率消耗。<br>主要了解一下背光驱动节电技术CABC的概念和功能。<a href="https://blog.csdn.net/sinat_30545941/article/details/72874775" target="_blank" rel="noopener">参考博客</a></p></blockquote><a id="more"></a><hr><h2 id="OEM和ODM"><a href="#OEM和ODM" class="headerlink" title="*OEM和ODM"></a>*OEM和ODM</h2><p><strong>Note:</strong></p><ol><li>OEM：自主加工，英文全称Original Equipment Manufacturer，即原设备生产商。原始设备生产商(OEM)是指拥有自己的产品或产品理念，但有时会为了开发和/或制造这些产品而购买某些服务的公司。</li><li>ODM：自主设计，即ORIGINAL DESIGN MANUFACTURER，意为“原始设计制造商”，是指一家公司根据另一家公司的规格来设计和生产一个产品。例如，计算机公司如HP公司可能会就其想推向市场的一款笔记本电脑作出具体规格。它们会具体地列明产品的外观要求，如屏幕的尺寸和技术要求、输入/输出端口、键盘的前倾度、电脑包的外形和颜色、扬声器的位置等。它们还通常会具体列明对产品的主要内部细节如CPU或视频控制器的规格要求。但是，它们并不设计图样，不具体列明电源用的交换晶体管的型号，也不对背光变流器频率加以选择。这些都是ODM的工作。ODM根据计算机公司提出的规格要求来设计和生产笔记本电脑。有时候，ODM也可根据现有样品来生产。ODM方式往往更加注重合作，而在OEM的情形下，购买方对产品的具体规格基本不参与意见。</li><li>OBM：自主品牌</li></ol><p><strong>OEM和ODM的区别:</strong></p><p>OEM和ODM两者最大的区别不单单是名称而已。OEM产品是为品牌厂商度身订造的，生产后也只能使用该品牌名称，绝对不能冠上生产者自己的名称再进行生产。而ODM则要看品牌企业有没有买断该产品的版权。如果没有的话，制造商有权自己组织生产，只要没有企业公司的设计识别即可。</p><p>在工业社会中，OEM和ODM可谓司空见惯。因为出于制造成本、运输方便性、节省开发时间等方面的考虑，知名品牌企业一般都愿意找其他厂商OEM或ODM。在找别的企业进行OEM或ODM时，知名品牌企业也要承担不少责任。毕竟产品冠的是自己的牌子，如果产品质量不佳的话，少则有顾客找上门投诉，重则可能要上法庭。所以，品牌企业在委托加工期间肯定会进行严格的质量控制。但代工结束后，质量不敢保证。故此，当有的商家告诉你某件产品的生产商是某大品牌的OEM或ODM产品时，绝不要相信其质量就等同于该品牌。你唯一能够相信的，是这家制造商有一定的生产能力。</p><hr><h2 id="背光节电技术"><a href="#背光节电技术" class="headerlink" title="背光节电技术"></a>背光节电技术</h2><p>显示屏在移动设备里一直的是耗电大户。目前手机背光节电技术，即对应性背光控制技术（Adaptive Brightness Control- ABC），主要有下面2种：</p><ol><li>LABC：(LightAdaptive Brightness Control) <code>环境光侦测适应背光控制</code>。根据环境光的变化来控制背光亮度。需要一个光传感器，感应环境光强。</li><li>CABC：(ContentAdaptive Brightness Control）<code>显示内容对应背光控制</code>。根据显示内容来调节背光和gamma值，从而降低了背光LED的功耗。其中C是内容的意思，驱动IC新增了一个内容分析器电路。</li></ol><h2 id="LABC"><a href="#LABC" class="headerlink" title="LABC"></a>LABC</h2><p>LABC技术需要搭配光传感器实现，主机端处理器读取光感数值，然后处理器对数值进行处理，直接控制PMIC(MT6329)输出PWM控制背光的亮度。在比较暗光线下，降低背光达到省电效果</p><h2 id="CABC"><a href="#CABC" class="headerlink" title="CABC"></a>CABC</h2><p>CABC功能需要在LCD驱动IC内新增一个内容分析器(imagecontent analyzer)电路，当手机处理器传送了一张图片数据到驱动IC，内容分析器会计算并统计图片的数据后依据设定与算法自动的将其灰阶亮度提高30%（此时图片变亮），再将背光亮度降低30%（此时图片变暗）。由于我们事先已经将图片经过分析器电路补偿亮度，因此使用者可以得到与原先电路相差无几的显示效果，但减少了30%的背光功耗。</p><p>简单来说，CABC功能就是根据<code>显示内容</code>来降低背光，然后通过调<code>节gamma</code>(gamma越高灰度越低图像越暗)来补偿显示亮度。CABC就是通过增加内容灰阶标准同时降低背光亮度来达到省功耗的目的。</p><p>CABC主要有四种状态：</p><ol><li>Off Mode，CABC功能全部关闭；</li><li>UI Image Mode，优化显示UI图片时的功耗，尽可能的保证图片质量的同时可省10%的功耗；</li><li>Still Image Mode，优化显示静态图片时的功耗，该模式下图片质量损耗在可接受的范围内，同时可省30%的功耗；</li><li>Moving Image Mode，优化显示动态图片时的功耗，该模式下会最大限度的降低功耗，但是会带来图片质量的损耗，可省30%+的功耗。</li></ol><p>自然对应Off Mode，标准对应UI Mode，照片对应UI Mode，电影对应Still Image Mode。用户可根据实际情况自行选择。</p><p>三种模式省电级别依次降低: <code>UI mode &lt; Movie mode &lt; Still mode</code>， 也就是说Still mode是最省电的模式。</p><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p>工作流程如下：</p><ol><li>使能PMIC(MT6329)CABC功能;</li><li>设置LCD驱动IC的相关配置(使能CABC和配置gamma参数，需要FAE协助)；</li><li>CABC模块分析显示内容输出LED_PWM信号给PMIC，PMIC通过一定算法控制driver模块BL_DRV信号的输出波形；</li><li>预期结果是背光亮度降低，LCD驱动IC降低gamma值以补偿屏幕亮度。</li></ol><p>CABC模块分析显示内容输出<code>PWM波形</code>，占空比越大，表示需要输出的电流越大。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;LCD背光驱动节电技术LABC-CABC&quot;&gt;&lt;a href=&quot;#LCD背光驱动节电技术LABC-CABC&quot; class=&quot;headerlink&quot; title=&quot;LCD背光驱动节电技术LABC/CABC&quot;&gt;&lt;/a&gt;LCD背光驱动节电技术LABC/CABC&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;手机屏幕大部分是LCD（还有OLED屏幕），而手机的部分电量就是LCD背光消耗的。随着分辨率/尺寸的增大，LCD的背光驱动电路也越来越复杂。而高分辨率、高显示颜色、大尺寸的LCD，需要大的背光系统、大的TFT-LCD 面版、高运算速度的驱动IC，这些都造成了高的功率消耗。&lt;br&gt;主要了解一下背光驱动节电技术CABC的概念和功能。&lt;a href=&quot;https://blog.csdn.net/sinat_30545941/article/details/72874775&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;参考博客&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="android" scheme="http://wizzie.top/categories/android/"/>
    
    
      <category term="display" scheme="http://wizzie.top/tags/display/"/>
    
  </entry>
  
  <entry>
    <title>Android SurfaceFlinger和HWC2概述</title>
    <link href="http://wizzie.top/2019/12/22/2019/191222_android_HWC2/"/>
    <id>http://wizzie.top/2019/12/22/2019/191222_android_HWC2/</id>
    <published>2019-12-22T15:32:00.000Z</published>
    <updated>2020-03-08T10:22:18.357Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>转载夕月风大佬博客： <a href="https://www.jianshu.com/p/824a9ddf68b9" target="_blank" rel="noopener">https://www.jianshu.com/p/824a9ddf68b9</a><br>参考Android Q AOSP源码添加修改部分内容<br>参考源码： <a href="http://aosp.opersys.com/xref/android-10.0.0_r14/" target="_blank" rel="noopener">http://aosp.opersys.com/xref/android-10.0.0_r14/</a></p></blockquote><a id="more"></a><h2 id="SurfaceFlinger概述"><a href="#SurfaceFlinger概述" class="headerlink" title="SurfaceFlinger概述"></a>SurfaceFlinger概述</h2><p>大多数APP在屏幕通常显示三个部分：</p><ul><li>屏幕顶部的状态栏</li><li>底部或者侧边的导航栏</li><li>应用的界面</li></ul><p>有些应用会显示更多或者更少的层。例如主屏幕会有一个单独的壁纸层；全屏幕的游戏可能会隐藏状态栏目。这些可以通过<code>Dump Surfacelinger</code>查看BufferLayers部分的信息来获取具体信息（<code>adb shell dumpsys SurfaceFlinger</code>）。从Dump结果看，layer呈树形结构(<code>Tree</code>)分布。</p><p>每个层都可以单独更新。状态栏和导航栏由系统进程渲染，而应用层由应用渲染，两者之间不进行协调。</p><h3 id="SurfaceFlinger类定义"><a href="#SurfaceFlinger类定义" class="headerlink" title="SurfaceFlinger类定义"></a>SurfaceFlinger类定义</h3><figure class="highlight c++"><figcaption><span>frameworks/native/services/surfaceflinger/SurfaceFlinger.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SurfaceFlinger</span> :</span> <span class="keyword">public</span> BnSurfaceComposer,</span><br><span class="line">                       <span class="keyword">public</span> PriorityDumper,</span><br><span class="line">                       <span class="keyword">private</span> IBinder::DeathRecipient,</span><br><span class="line">                       <span class="keyword">private</span> HWC2::ComposerCallback</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">SurfaceFlingerBE&amp; <span class="title">getBE</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> mBE; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> SurfaceFlingerBE&amp; <span class="title">getBE</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> mBE; &#125;</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure><p>继承BnSurfaceComposer，实现ISurfaceComposer接口；实现ComposerCallback；继承辅助类PriorityDumper，主要提供SurfaceFlinger的Dump信息，并且提高提供信息的分离和格式设置。</p><h3 id="ISurfaceComposer接口实现"><a href="#ISurfaceComposer接口实现" class="headerlink" title="ISurfaceComposer接口实现"></a>ISurfaceComposer接口实现</h3><p>ISurfaceComposer是提供给上层Client端的接口（Bp端），此处的SurfaceFlinger是Server端（Bn端）。接口内容包括：</p><figure class="highlight c++"><figcaption><span>frameworks/native/include/gui/ISurfaceComposer.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ISurfaceComposer</span>:</span> <span class="keyword">public</span> IInterface &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    DECLARE_META_INTERFACE(SurfaceComposer)</span><br><span class="line">    ......</span><br><span class="line">        <span class="comment">/* returns information for each configuration of the given display</span></span><br><span class="line"><span class="comment">     * intended to be used to get information about built-in displays */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">status_t</span> <span class="title">getDisplayConfigs</span><span class="params">(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; <span class="built_in">display</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">            Vector&lt;DisplayInfo&gt;* configs)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure><p>接口在SurfaceFlinger中都有对应的方法实现。Client端通过Binder跨进程调到SurfaceFlinger中。获取Display的信息，其实现就是SurfaceFlinger的<code>getDisplayConfig</code>函数。</p><h3 id="ComposerCallback接口实现"><a href="#ComposerCallback接口实现" class="headerlink" title="ComposerCallback接口实现"></a>ComposerCallback接口实现</h3><p>ComposerCallback是HWC2的callback接口，包括以下接口：</p><figure class="highlight c++"><figcaption><span>frameworks/native/services/surfaceflinger/DisplayHardware/HWC2.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> HWC2 &#123;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Display</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Layer</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Implement this interface to receive hardware composer events.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// These callback functions will generally be called on a hwbinder thread, but</span></span><br><span class="line"><span class="comment">// when first registering the callback the onHotplugReceived() function will</span></span><br><span class="line"><span class="comment">// immediately be called on the thread calling registerCallback().</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// All calls receive a sequenceId, which will be the value that was supplied to</span></span><br><span class="line"><span class="comment">// HWC2::Device::registerCallback(). It's used to help differentiate callbacks</span></span><br><span class="line"><span class="comment">// from different hardware composer instances.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ComposerCallback</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onHotplugReceived</span><span class="params">(<span class="keyword">int32_t</span> sequenceId, <span class="keyword">hwc2_display_t</span> <span class="built_in">display</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   Connection connection)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onRefreshReceived</span><span class="params">(<span class="keyword">int32_t</span> sequenceId,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">hwc2_display_t</span> <span class="built_in">display</span>)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onVsyncReceived</span><span class="params">(<span class="keyword">int32_t</span> sequenceId, <span class="keyword">hwc2_display_t</span> <span class="built_in">display</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">int64_t</span> timestamp)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~ComposerCallback() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line">.....</span><br></pre></td></tr></table></figure><p>Callback提供了注册接口<code>registerCallback</code>，在SurfaceFlinger初始化的时候注册：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ALOGI(  <span class="string">"SurfaceFlinger's main thread ready to run. "</span></span><br><span class="line">            <span class="string">"Initializing graphics H/W..."</span>);</span><br><span class="line">....</span><br><span class="line">mCompositionEngine-&gt;getHwComposer().registerCallback(<span class="keyword">this</span>, getBE().mComposerSequenceId);</span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>此处<code>registerCallback</code>的<code>this</code>就是SurfaceFlinger对ComposerCallback接口的实现。</p><ul><li>onHotplugReceived： 热插拔事件的回调，显示屏幕连接或者断开时回调。</li><li>onRefreshReceived： 接收底层HWComposer的刷新请求。在<code>repaintEverythingForHWC</code>中，<code>mRepaintEverything</code>为<code>true</code>的时候，将触发一次刷新，重新进行合成显示。重新绘制说明底层配置、参数等有变动，SurfaceFlinger前面给的数据不能用，需要重新根据变动后的配置进行合成，给适合当前配置的显示数据。</li></ul><figure class="highlight c++"><figcaption><span>frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::onRefreshReceived</span><span class="params">(<span class="keyword">int</span> sequenceId, <span class="keyword">hwc2_display_t</span> <span class="comment">/*hwcDisplayId*/</span>)</span> </span>&#123;</span><br><span class="line">    <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mStateLock)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (sequenceId != getBE().mComposerSequenceId) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    repaintEverythingForHWC();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::repaintEverythingForHWC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mRepaintEverything = <span class="literal">true</span>;</span><br><span class="line">    mEventQueue-&gt;invalidate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>onVsyncReceived： Vsync事件上报，接收底层硬件上报的垂直同步信号。此处可以通过抓取<code>Systrace</code>的方式查看具体的Vsync的信息（底层硬件、SurfaceFlinger、APP三部分的Vsync，一般Android版本升级的时候会进行<code>vsync的tuning</code>）</li><li><strong>显示周期Vsync</strong>： 设备显示会按照一定速率更新（一般是一秒60帧，即16.6ms刷新一次）。如果显示内容在刷新期间更新，则会出现撕裂现象，因此必须在周期之间更新（<code>这也是vsync tunning的必要性，保持SurfaceFlinger和draw frame都在vsync周期里面，并且不重叠</code>）在可以安全更新内容时，系统便会接收来自显示设备的信号。</li></ul><p>刷新率可能会随时间而变化，例如一些设备的刷新范围在58fps至62fps之间，具体视当前条件而定。对于连接了HDMI的电视，刷新率在理论上可以下降到24Hz或者48Hz，以便和视频匹配。由于每个刷新周期只能更新屏幕一次，因此以200fps的刷新率为显示设备提交缓冲区并没有必要性，因为大部分桢不能被看到（人眼合适的是60fps）。SurfaceFlinger不会在应用提交缓冲区时进行操作，而是在显示设备准备好接收新缓冲区的时候才会唤醒。</p><p>当Vsync信号到达的时候，SurfaceFlinger会遍历层列表，以寻找新的缓冲区。如果找到会获取该缓冲区，否则会使用以前获取的缓冲区。SurfaceFlinger总是需要可显示的内容，因此会保留一个缓冲区。如果在某个层没有提交缓冲区，则该层会被忽略。</p><p>此处会在合成调用到<code>handlePageFlip</code>函数，函数中先调用<code>latchBuffer</code>从BufferQueue取Buffer，然后等待Vsync信号更新到FrameBuffer。</p><ul><li><strong>合成方式</strong>： 目前SurfaceFlinger支持两种合成方式：一种是Device合成，一种是Client合成。SurfaceFlinger在收集可见层的所有缓冲区之后，便会询问HardwareComposer应该如何进行合成。</li><li><ul><li>Client合成：之前称之为GLES合成，也可以称之为GPU合成，该合成方式是相对于硬件合成来说的，将各个Layer的内容用GPU渲染到暂存缓冲区中，最后将暂存缓冲区传送到显示硬件Client合成采用RenderEngine进行合成。</li></ul></li><li><ul><li>Device合成： 用专门的硬件合成器进行合成HWComposer，所以硬件合成的能力就取决于硬件的实现。其合成方式是将各个Layer的数据全部传给显示硬件，并告知它从不同的缓冲区读取屏幕不同部分的数据。HWComposer是Device合成的抽象。</li></ul></li></ul><p>合成方式可以从Dump SurfaceFlinger中查看到Layer的具体合成方式，GPU合成一般可以通过开发者选项中启动，强制GPU合成；而Device合成在Dump信息中一般显示成SDE合成。</p><p>GPU合成数据后，作为一个特殊的Layer传给显示硬件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Display 0 HWC layers:</span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line"> Layer name</span><br><span class="line">           Z |  Comp Type |   Disp Frame (LTRB) |          Source Crop (LTRB)</span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line"> com.android.systemui.ImageWallpaper#0</span><br><span class="line">  rel      0 |     Client |    0    0 1080 2280 |    0.0    0.0 1080.0 2280.0</span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line"> net.oneplus.launcher/net.oneplus.launcher.Launcher#0</span><br><span class="line">  rel      0 |     Client |    0    0 1080 2280 |    0.0    0.0 1080.0 2280.0</span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line"><span class="meta"> StatusBar#</span><span class="bash">0</span></span><br><span class="line">  rel      0 |     Client |    0    0 1080   80 |    0.0    0.0 1080.0   80.0</span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line"><span class="meta"> GestureButtonRegion#</span><span class="bash">0</span></span><br><span class="line">  rel      0 |     Client |    0 2216 1080 2280 |    0.0    0.0 1080.0   64.0</span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line"><span class="meta"> ScreenDecorOverlay#</span><span class="bash">0</span></span><br><span class="line">  rel      0 |     Device |    0    0 1080  106 |    0.0    0.0 1080.0  106.0</span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line"><span class="meta"> ScreenDecorOverlayBottom#</span><span class="bash">0</span></span><br><span class="line">  rel      0 |     Device |    0 2198 1080 2280 |    0.0    0.0 1080.0   82.0</span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line"></span><br><span class="line">|-----|------------|-----------|------|-------------|--------------------------|---------------------|---------------------|----|------------|-----------|----|-----|</span><br><span class="line">| Idx |  Comp Type |   Split   | Pipe |    W x H    |          Format          |  Src Rect (L T R B) |  Dst Rect (L T R B) |  Z |    Flags   | Deci(HxV) | CS | Rng |</span><br><span class="line">|-----|------------|-----------|------|-------------|--------------------------|---------------------|---------------------|----|------------|-----------|----|-----|</span><br><span class="line">|   6 | GPU_TARGET |    Pipe-1 |   94 | 1088 x 2288 |           RGBA_8888_UBWC |    0    0 1080 2280 |    0    0 1080 2280 |  0 | 0x00000002 |   0 x   0 |  0 |   0 |</span><br><span class="line">|   4 |        SDE |    Pipe-1 |  103 | 1088 x  112 |           RGBA_8888_UBWC |    0    0 1080  106 |    0    0 1080  106 |  1 | 0x00000000 |   0 x   0 |  1 |   1 |</span><br><span class="line">|   5 |        SDE |    Pipe-1 |   92 | 1088 x   96 |           RGBA_8888_UBWC |    0    0 1080   82 |    0 2198 1080 2280 |  2 | 0x00000000 |   0 x   0 |  1 |   1 |</span><br><span class="line">|-----|------------|-----------|------|-------------|--------------------------|---------------------|---------------------|----|------------|-----------|----|-----|</span><br></pre></td></tr></table></figure><ul><li>SurfaceFlingerBE: 从Android P上分离出来，定义上看是将Surfacelinger分离为前后端。</li><li>消息队列和主线程： 和应用进程类似，SurfaceFlinger也有一个主线程，主要是进行显示数据的处理，即合成。Surfacelinger是一个服务，将会响应上层的请求，各个进程的请求都在SurfaceFlinger的各个Binder线程中，如果线程很耗时，那么应用端就会被block。主线程将他们分离开来，各干各的。</li></ul><p><strong>Note：</strong></p><ol><li>SurfaceFligner有两个状态，Layer也有两个状态，一个是mCurrentState，一个是mDrawingState。</li><li>两个EventThread，一个是给SurfaceFlinger本身使用，一个是为了给应用分发事件的。</li></ol><hr><h3 id="mCurrentState和mDrawingState"><a href="#mCurrentState和mDrawingState" class="headerlink" title="mCurrentState和mDrawingState"></a><code>mCurrentState</code>和<code>mDrawingState</code></h3><ol><li>这两个成员是Layer类中<code>Layer::State</code>的类型。</li></ol><figure class="highlight c++"><figcaption><span>Layer.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">State</span> &#123;</span></span><br><span class="line">    Geometry active;  <span class="comment">//计算后的实际尺寸</span></span><br><span class="line">    Geometry requested; <span class="comment">//用户设置的尺寸</span></span><br><span class="line">    <span class="keyword">int32_t</span> z; <span class="comment">//Layer的Z轴值，值越小位置就越靠小</span></span><br><span class="line">    <span class="keyword">uint32_t</span> layerStack;  <span class="comment">//和显示设备的关联值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unit8_t</span> alpha; <span class="comment">//Layer的透明度</span></span><br><span class="line">    <span class="keyword">uint8_t</span> flags;  <span class="comment">//Layer的标志（如果上次绘制后用户改变了Layer）</span></span><br><span class="line">    <span class="keyword">uint8_t</span> reserved[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int32_t</span> sequence; <span class="comment">//序列值，Layer的属性变化一次就会加一（例如setAlpha,setSize,setLayer等）</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// the transparentRegion hint is a bit special, it's latched only</span></span><br><span class="line">    <span class="comment">// when we receive a buffer -- this is because it's "content"</span></span><br><span class="line">    <span class="comment">// dependent.</span></span><br><span class="line">    Region activeTransparentRegion; <span class="comment">//实际的透明区域</span></span><br><span class="line">    Region requestedTransparentRegion;  <span class="comment">//用户中的透明区域</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>Surfacelinger创建Surface的时候，会调用<code>createLayer</code>，然后调用<code>addClientLayer</code>函数，这里会把Layer对象放在<code>mCurrentState</code>的layerSortedByZ对象中。</p></li><li><p>Surfacelinger合成的时候，调用<code>preComposition</code>函数，会先调用<code>mDrawingState</code>的layerSortedByZ来获取上次绘图的Layer层列表（并不是所有layer都参与屏幕图像的绘制，因此通过State对象记录参与绘制的Layer对象）</p></li><li><p>Layer对象在绘制图形时，使用的是mDrawingState变量；用户调用接口设置Layer对象属性时，设置的值保存在mCurrentState中。这样就不会因为用户的操作而干扰Layer对象的绘制了。</p></li><li><p><code>Layer::doTransaction</code>函数会比较这两个成员变量，如果有不同的地方，说明上次绘制后，用户改变了Layer的属性，要把这种变化通过flags返回。</p></li><li><p><code>layerStack</code>字段是用户指定的一个值，用户可以给DisplayDevice指定一个layerStack值，只有Layer对象和DisplayDevice对象的layerStack相等，这个Layer才能在这个显示设备输出。这样的好处可以让显示设备只显示某个Surface的内容。例如，可以让HDMI显示设备只显示手机上播放的Surface窗口，但是不显示Activity窗口。</p></li><li><p><code>Layer::doTransaction</code>最后会调用<code>commitTransaction</code>函数，就是将mCurrentState赋值给mDrawingState。</p></li></ol><hr><ol start="8"><li>以上的是在Layer.cpp中的两个成员变量，而在<code>SurfaceFlinger.cpp</code>也有同名的<code>mCurrentState</code>和<code>mDrawingState</code>两个成员变量（定义在SurfaceFlinger.h中），定义不一样，只是名字相同。</li></ol><figure class="highlight c++"><figcaption><span>SF.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">State</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    explicit State(LayerVector::StateSet set) : stateSet(set), layersSortedByZ(set) &#123;&#125;</span><br><span class="line">    State&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> State&amp; other) &#123;</span><br><span class="line">        <span class="comment">// We explicitly don't copy stateSet so that, e.g., mDrawingState</span></span><br><span class="line">        <span class="comment">// always uses the Drawing StateSet.</span></span><br><span class="line">        layersSortedByZ = other.layersSortedByZ;</span><br><span class="line">        displays = other.displays;</span><br><span class="line">        colorMatrixChanged = other.colorMatrixChanged;</span><br><span class="line">        <span class="keyword">if</span> (colorMatrixChanged) &#123;</span><br><span class="line">            colorMatrix = other.colorMatrix;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> LayerVector::StateSet stateSet = LayerVector::StateSet::Invalid;</span><br><span class="line">    LayerVector layersSortedByZ;  <span class="comment">//保存所有参与绘制的Layer对象</span></span><br><span class="line">    DefaultKeyedVector&lt; wp&lt;IBinder&gt;, DisplayDeviceState&gt; displays; <span class="comment">//保存所有输出设备的DisplayDeviceState对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> colorMatrixChanged = <span class="literal">true</span>;</span><br><span class="line">    mat4 colorMatrix;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traverseInZOrder</span><span class="params">(<span class="keyword">const</span> LayerVector::Visitor&amp; visitor)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traverseInReverseZOrder</span><span class="params">(<span class="keyword">const</span> LayerVector::Visitor&amp; visitor)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="9"><li>SF.cpp中的<code>handleTransactionLocked</code>函数会根据<code>eTraversalNeeded</code>标志决定是否要检查所有的Layer对象。如果某个Layer对象有这个标志，将会调用他的<code>doTransaction</code>函数。<code>Layer::doTransaction</code>函数返回的flags如果有<code>eVisibleRegion</code>说明这个Layer需要更新，就把<code>mVisibleRegionDirty</code>设置为true。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::handleTransactionLocked</span><span class="params">(<span class="keyword">uint32_t</span> transactionFlags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Notify all layers of available frames</span></span><br><span class="line">    mCurrentState.traverseInZOrder([](Layer* layer) &#123;</span><br><span class="line">        layer-&gt;notifyAvailableFrames();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Traversal of the children</span></span><br><span class="line"><span class="comment">     * (perform the transaction for each of them if needed)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (transactionFlags &amp; eTraversalNeeded) &#123;</span><br><span class="line">        mCurrentState.traverseInZOrder([&amp;](Layer* layer) &#123;</span><br><span class="line">            <span class="keyword">uint32_t</span> trFlags = layer-&gt;getTransactionFlags(eTransactionNeeded);</span><br><span class="line">            <span class="keyword">if</span> (!trFlags) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">uint32_t</span> flags = layer-&gt;doTransaction(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (flags &amp; Layer::eVisibleRegion)</span><br><span class="line">                mVisibleRegionsDirty = <span class="literal">true</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ......<span class="comment">//这部分代码是根据每种显示设备的不同，设置和显示设备关联在一起的Layer（主要看LayerStack是否和DisplayDevice的layerStack相同）的TransformHint（主要指设备的显示方向orientation）</span></span><br><span class="line"></span><br><span class="line">    commitTransaction();</span><br><span class="line"></span><br><span class="line">    updateCursorAsync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Note:</strong> <code>handleTransaction</code>的作用是处理系统在两次刷新期间的各种变化。Surfacelinger模块中不管是SurfaceFlinger类和Layer类</p><hr><h2 id="硬件合成HWC2概述"><a href="#硬件合成HWC2概述" class="headerlink" title="硬件合成HWC2概述"></a>硬件合成HWC2概述</h2><p>Hardware Composer HAL(HWC)是指硬件完成图像数据组合并显示的能力。</p><p>SurfaceFlinger是一个系统服务（系统启动时启动），作用是接收来自多个源的Buffer数据，并进行合成，然后发送到显示设备进行显示。</p><p>SurfaceFlinger和HWC的相互配合，实现Android系统的合成和显示（非GPU合成）。</p><hr><p>Android 7.0包含新版本的HWC（HWC2），Android需要自行配置。</p><p>Android 8.0，HWC2正式开启，并且版本升级为2.1。（<code>/frameworks/native/services/surfaceflinger/DisplayHardware/</code>）</p><p>HWC2是SurfaceFlinger用来与专门的窗口合成硬件进行通信（Device合成方式）。SurfaceFlinger包含使用3D图形处理器（GPU）执行窗口合成任务的备用途径，但是此路径并不理想（GPU合成方式），因为：</p><ol><li>通常，GPU没有针对此进行优化，因此能耗可能大于执行合成所需的能耗；</li><li>每次SUrfaceFlinger使用GPU合成时，应用都无法使用处理器进行自我渲染，因此应尽可能使用专门的硬件而不是GPU进行合成。</li></ol><p>GPU（Client合成）和HWC（Client合成）两种方式对比：</p><table><thead><tr><th align="center">合成类型</th><th align="center">耗电情况</th><th align="center">性能情况</th><th align="center">Alpha处理</th><th align="center">DRM内容处理</th><th align="center">其他限制</th></tr></thead><tbody><tr><td align="center">Device合成（HWC）</td><td align="center">耗电低</td><td align="center">性能高</td><td align="center">很多Vendor的HWC不支持Alpha的处理和合成</td><td align="center">基本都能访问DRM内容</td><td align="center">能合成的Surface层数有限，对每种Surface类型处理层数有限</td></tr><tr><td align="center">Client合成（GPU）</td><td align="center">耗电高</td><td align="center">性能低</td><td align="center">能处理每个像素的Alpha及每个Layer的Alpha</td><td align="center">早期版本GPU不能访问DRM的内容</td><td align="center">目前的处理层数没有限制</td></tr></tbody></table><p><strong>Note:</strong></p><ol><li>Alpha处理： 图片的透明度（0～255或者0.0f~1.0f），数值越小透明度越高</li><li>DRM内容处理：（Digital Rights Management）一种业界使用广泛的数字内容版权保护技术。</li></ol><h3 id="HWC常规准则"><a href="#HWC常规准则" class="headerlink" title="HWC常规准则"></a>HWC常规准则</h3><p>Hardware Composer抽象层后的物理显示设备硬件可因设备而异。但是一般来说，遵循以下规则：</p><ol><li>HWC应至少支持4个叠加层（状态栏、系统栏、应用、壁纸/背景）</li><li>层可以大于屏幕，因此HWC应能处理大于显示屏的层（例如壁纸）</li><li>应该同时支持预乘每个像素Alpha混合和每个平面Alpha混合</li><li>HWC应能够处理GPU、Camera、视频解码器（Video Decoder）生成的相同缓冲区，因此支持以下某些属性会很有帮助：</li></ol><ul><li><ul><li>RGBA打包顺序</li></ul></li><li><ul><li>YUV格式</li></ul></li><li><ul><li>Tiling,swizzling和步幅属性</li></ul></li></ul><ol start="5"><li>为了支持受保护的内容（Secure layer），必须提供受保护视频播放的硬件路径</li></ol><p><strong>Note：</strong></p><ol><li>RGBA是一种颜色值</li><li>YUV是一种颜色编码格式，可以说YUV流媒体是原始流数据，大部分的视频领域都在使用。他与RGB类似，但RGB更多的用于渲染时，而YUV则用在数据传输，因为它占用更少的频宽。当然，实时通讯为了降低带宽都会采用H264/H265编码。从字面意思理解，YUV的含义:Y代表亮度信息（灰度），UV分别代表色彩信息。YUV的常用名称有许多，如YUV422这是大部分镜头出来的数据，还有许多（yuv420,yuv444等）</li><li>Tiling简单来说就是将image进行切割，切成<code>M * N</code>小块，最后用的时候再进行拼接，类似铺瓷砖</li><li>swizzling是一种拌和技术，这是向量的单元可以被任意的重新排放或重复</li></ol><p>HWC专注于优化，智能的选择要发送到叠加硬件的Surface，以最大限度减轻GPU的负载。<strong>另一种优化是检测屏幕是否正在更新；如果不是，这将合成委托给OpenGL而不是HWC，以节省电量。但屏幕再次更新时，继续将合成分发给HWC</strong>。</p><p>为常见的用例做准备，比如：</p><ul><li>纵向和横向模式下的全屏游戏</li><li>带着字幕和播放控件的全屏视频</li><li>主屏幕（状态栏、系统栏目、应用、动态壁纸）</li><li>受保护的视频播放</li><li>多显示设备支持</li></ul><h3 id="HWC2框架"><a href="#HWC2框架" class="headerlink" title="HWC2框架"></a>HWC2框架</h3><p>从Android 8.0开始的Treble项目，对Android架构做了调整，让制造商以更低的成本更加轻松快速的将设备更新到Android系统。这就对HAL层有了很大的调整，利用提供给Vendor的接口，将Vendor的实现和Android上层分离开来。</p><p>这样的架构也使得HWC架构变得复杂，HWC属于<code>Binderized</code>的HAL类型。<code>Binderized</code>类型的HAL将上层Android和底层HAL分别采用两个不同的进程实现，中间采用Binder进行通信，为了和前面的Binder进行区别，这里采用<code>HWBinder</code>。</p><p>可以将HWC分为以下几个部分：</p><ul><li><p>Binder 1：</p></li><li><ul><li>SurfaceFlinger Service</li></ul></li><li><ul><li>HWC2 Client</li></ul></li><li><p>Binder 2：</p></li><li><ul><li>HWC2 Server</li></ul></li><li><ul><li>HWC2 Vendor Impl</li></ul></li></ul><p><strong>具体解释：</strong></p><ol><li>Client端：Client就是指SurfaceFlinger。不过SurfaceFlinger采用前后端设计，以后和HWC相关的逻辑应该会放到后端（<code>SurfaceFlingerBE</code>），即<code>/frameworks/native/services/surfaceflinger/</code></li><li>HWC Client端： 这一部分属于SurfaceFlinger进程，直接用过Binder通信，和HWC2的HAL Server交互。在SurfaceFlinger中采用<code>namespace HWC2</code>的命名空间，即<code>frameworks/native/services/surfaceflinger/DisplayHardware/HWComposer.cpp</code>。</li><li>HWC2 Server端: 这里将建立一个进程实现HWC的<code>Server端</code>。服务端再调用底层Vendor的具体实现。并且，对于底层合成的实现不同，此处会做一些适配（<code>适配HWC1.x</code>），和FrameBuffer的实现。这部分包含三部分：<strong>接口、实现、服务</strong>，以动态库的形式存在：（<code>hardware/interfaces/graphics/composer/2.1/default/</code>）</li></ol><ul><li><ul><li><a href="mailto:android.hardware.graphics.composer@2.1.so">android.hardware.graphics.composer@2.1.so</a></li></ul></li><li><ul><li><a href="mailto:android.hardware.graphics.composer@2.1-impl.so">android.hardware.graphics.composer@2.1-impl.so</a></li></ul></li><li><ul><li><a href="mailto:android.hardware.graphics.composer@2.1-service.so">android.hardware.graphics.composer@2.1-service.so</a></li></ul></li></ul><ol start="3"><li>HWC Vendor实现： 这部分是HWC的具体实现，由硬件厂商完成，（<code>例如高通QCOM</code>），代码一般是<code>hardware/qcom/display/</code>。HWC必须采用<code>Binderized HAL</code>模式，但是不一定要实现HWC2的HAL版本。HWC2的实现需要配置，以Android 8.0为例，包含：</li></ol><ul><li><ul><li>添加宏定义<code>TARGET_USERS_HWC2</code></li></ul></li><li><ul><li>编译打包HWC2相关的so库</li></ul></li><li><ul><li>SELinux相关的权限添加</li></ul></li><li><ul><li>配置<code>manifest.xml</code>：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;hal format=<span class="string">"hidl"</span>&gt;</span><br><span class="line">        &lt;name&gt;android.hardware.graphics.composer&lt;/name&gt;</span><br><span class="line">        &lt;transport&gt;hwbinder&lt;/transport&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">2.1</span>&lt;/version&gt;</span><br><span class="line">        &lt;interface&gt;</span><br><span class="line">            &lt;name&gt;IComposer&lt;/name&gt;</span><br><span class="line">            &lt;instance&gt;<span class="keyword">default</span>&lt;/instance&gt;</span><br><span class="line">        &lt;/interface&gt;</span><br><span class="line">&lt;/hal&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="HWC2数据结构"><a href="#HWC2数据结构" class="headerlink" title="HWC2数据结构"></a>HWC2数据结构</h3><ol><li>HWC2的一些常用接口定义在头文件<code>hardware/libhardware/include/hardware/hwcomposer2.h</code>中，一些共用的数据定义是HAL的接口中:</li></ol><ul><li><code>hardware/interfaces/graphics/common/1.0/</code></li><li><code>hardware/interfaces/graphics/composer/2.1/</code></li></ul><h3 id="图层Layer"><a href="#图层Layer" class="headerlink" title="图层Layer"></a>图层Layer</h3><p>每个Layer都有一组属性，用来定义和其他Layer的交互方式。他在每一个模块（层）代码定义的实现不一样，但是Layer的理念是一样的。</p><ul><li><p><a href="http://aosp.opersys.com/xref/android-10.0.0_r14/xref/frameworks/native/services/surfaceflinger/" target="_blank" rel="noopener">SurfaceFlinger中</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">frameworks&#x2F;native&#x2F;services&#x2F;surfaceflinger</span><br><span class="line">├── Layer.h</span><br><span class="line">├── Layer.cpp</span><br><span class="line">├── ColorLayer.h</span><br><span class="line">├── ColorLayer.cpp</span><br><span class="line">├── BufferLayer.h</span><br><span class="line">└── BufferLayer.cpp</span><br><span class="line">|__ ...</span><br></pre></td></tr></table></figure></li><li><p><a href="">HWC2中</a></p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">frameworks&#x2F;native&#x2F;services&#x2F;surfaceflinger&#x2F;DisplayHardware</span><br><span class="line">├── HWC2.h</span><br><span class="line">└── HWC2.cpp</span><br></pre></td></tr></table></figure><ul><li>在HAL中实现时，定义为hwc2_layer_t，是在头文件hwcomposer2.h中定义的:<code>typedef uint64_t hwc2_layer_t;</code></li><li>HIDL中定义为Layer，这个Layer和<code>hwc2_layer_t</code>是一样的：<code>typedef uint64_t Layer;</code></li></ul><h4 id="Layer按照类型划分"><a href="#Layer按照类型划分" class="headerlink" title="Layer按照类型划分"></a>Layer按照类型划分</h4><p>大致分为<code>BufferLayer</code>和<code>COlorLayer</code>（在SF中createLayer中），<code>BufferLayer</code>就是有Buffer的Lyaer（Bufferueue，GraphicsBuffer），需要上层应用Producer生长；<code>ColorLayer</code>可以绘制一种制定的颜色和透明度Alpha（取代之前的Dim Layer）。</p><h4 id="Layer按照数据划分"><a href="#Layer按照数据划分" class="headerlink" title="Layer按照数据划分"></a>Layer按照数据划分</h4><p>大致分为<code>RGB Layer</code>和<code>YUV Layer</code>，前者是RGB格式，比较常见的就是UI界面的数据；后者的Buffer是YUV类型的，平常播放Video，Camera预览等，都是YUV类型的。</p><h3 id="Layer属性"><a href="#Layer属性" class="headerlink" title="Layer属性*"></a>Layer属性*</h3><blockquote><p>Layer的属性定义他和其他模块（层）的关系，和显示屏（DeisplayDevice）的关系等。Layer包含的属性类别如下（上述也有部分内容）：</p></blockquote><h4 id="位置属性"><a href="#位置属性" class="headerlink" title="位置属性"></a>位置属性</h4><blockquote><p>定义层在其显示设备上的现实位置，包含层边缘的位置和其相对于其他层的Z-Order等，并且还定义了很多个<strong>区域Region</strong>：</p></blockquote><figure class="highlight c++"><figcaption><span>frameworks/native/services/surfaceflinger/Layer.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Layer</span> :</span> <span class="keyword">public</span> <span class="keyword">virtual</span> RefBase &#123;</span><br><span class="line">    ... ...</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ... ...</span><br><span class="line">    <span class="comment">// regions below are in window-manager space</span></span><br><span class="line">    Region visibleRegion;</span><br><span class="line">    Region coveredRegion;</span><br><span class="line">    Region visibleNonTransparentRegion;</span><br><span class="line">    Region surfaceDamageRegion;</span><br></pre></td></tr></table></figure><p>Region中是很多个Rect的集合，即一个Layer的visibleRegion可能是几个Rect的集合（rect对象用来存储一个矩形框的左上角坐标、宽度和高度。描述矩形的宽度、高度和原点）</p><p>SurfaceFlinger中定义的Region都是从上层（WMS）传递过来的。而在HWC中，是用的下面的结构描述：</p><figure class="highlight c++"><figcaption><span>hardware/libhardware/include/hardware/hwcomposer_defs.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">hwc_color</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> r;</span><br><span class="line">    <span class="keyword">uint8_t</span> g;</span><br><span class="line">    <span class="keyword">uint8_t</span> b;</span><br><span class="line">    <span class="keyword">uint8_t</span> a;</span><br><span class="line">&#125; <span class="keyword">hwc_color_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">hwc_float_color</span> &#123;</span></span><br><span class="line">    <span class="keyword">float</span> r;</span><br><span class="line">    <span class="keyword">float</span> g;</span><br><span class="line">    <span class="keyword">float</span> b;</span><br><span class="line">    <span class="keyword">float</span> a;</span><br><span class="line">&#125; <span class="keyword">hwc_float_color_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">hwc_frect</span> &#123;</span></span><br><span class="line">    <span class="keyword">float</span> left;</span><br><span class="line">    <span class="keyword">float</span> top;</span><br><span class="line">    <span class="keyword">float</span> right;</span><br><span class="line">    <span class="keyword">float</span> bottom;</span><br><span class="line">&#125; <span class="keyword">hwc_frect_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">hwc_rect</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> left;</span><br><span class="line">    <span class="keyword">int</span> top;</span><br><span class="line">    <span class="keyword">int</span> right;</span><br><span class="line">    <span class="keyword">int</span> bottom;</span><br><span class="line">&#125; <span class="keyword">hwc_rect_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">hwc_region</span> &#123;</span></span><br><span class="line">    <span class="keyword">size_t</span> numRects;</span><br><span class="line">    <span class="keyword">hwc_rect_t</span> <span class="keyword">const</span>* rects;</span><br><span class="line">&#125; <span class="keyword">hwc_region_t</span>;</span><br></pre></td></tr></table></figure><ul><li>Transform，这个在SurfaceFlinger中定义的一个重要的结构，意思是变换矩阵，是一个<code>3*3</code>的矩阵。</li></ul><p><strong>联系流程：</strong><br><code>Rect &lt;- Region &lt;- Layer &lt;- State &lt;- Geometry &lt;- Transform &lt;- mat33</code></p><ul><li>Layer的两个状态：mCurrentState和mDrawingState，前者是给SurfaceFlinger的前段准备数据，后者是将数据给到合成。每个状态有两个Geometry的描述<code>request</code>（上层请求的）和<code>active</code>（当前正在使用的）。每个Geometry中有一个Transform矩阵，一个Transform包含一个mat33的整列。</li></ul><p>Transform中包含两部分，一部分是位置Postion，另一部分是真正的2D的变换矩阵。通过下面两个函数设置：（对应Layer中的setPostion和setMatrix函数，这是上层WMS设置下来的）</p><figure class="highlight c++"><figcaption><span>frameworks/native/libs/ui/Transform.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Transform::set</span><span class="params">(<span class="keyword">float</span> tx, <span class="keyword">float</span> ty)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mMatrix[<span class="number">2</span>][<span class="number">0</span>] = tx;</span><br><span class="line">    mMatrix[<span class="number">2</span>][<span class="number">1</span>] = ty;</span><br><span class="line">    mMatrix[<span class="number">2</span>][<span class="number">2</span>] = <span class="number">1.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isZero(tx) &amp;&amp; isZero(ty)) &#123;</span><br><span class="line">        mType &amp;= ~TRANSLATE;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mType |= TRANSLATE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Transform::set</span><span class="params">(<span class="keyword">float</span> a, <span class="keyword">float</span> b, <span class="keyword">float</span> c, <span class="keyword">float</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">mat33&amp; <span class="title">M</span><span class="params">(mMatrix)</span></span>;</span><br><span class="line">    M[<span class="number">0</span>][<span class="number">0</span>] = a;    M[<span class="number">1</span>][<span class="number">0</span>] = b;</span><br><span class="line">    M[<span class="number">0</span>][<span class="number">1</span>] = c;    M[<span class="number">1</span>][<span class="number">1</span>] = d;</span><br><span class="line">    M[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">0</span>;    M[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    mType = UNKNOWN_TYPE;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br></pre></td></tr></table></figure><hr><h4 id="内容属性"><a href="#内容属性" class="headerlink" title="内容属性"></a>内容属性</h4><blockquote><p>定义显示的内容如何呈现（即Buffer）。Layer的显示，除了之前的几个区域Region描述，还有很多结构进一步描述才能显示，例如裁减（用来扩展内容的一部分以填充层的边界）和转换（用来显示旋转或者翻转的内容）等信息。HWCInfo结构体中包括了一些这样的信息：</p></blockquote><figure class="highlight c++"><figcaption><span>frameworks/native/services/surfaceflinger/CompositionEngine/include/compositionengine/impl/OutputLayerCompositionState.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">OutputLayerCompositionState</span> &#123;</span></span><br><span class="line">    <span class="comment">// The region of this layer which is visible on this output</span></span><br><span class="line">    Region visibleRegion;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If true, client composition will be used on this output</span></span><br><span class="line">    <span class="keyword">bool</span> forceClientComposition&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If true, when doing client composition, the target may need to be cleared</span></span><br><span class="line">    <span class="keyword">bool</span> clearClientTarget&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The display frame for this layer on this output</span></span><br><span class="line">    Rect displayFrame;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The source crop for this layer on this output</span></span><br><span class="line">    FloatRect sourceCrop;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The buffer transform to use for this layer o on this output.</span></span><br><span class="line">    Hwc2::Transform bufferTransform&#123;<span class="keyword">static_cast</span>&lt;Hwc2::Transform&gt;(<span class="number">0</span>)&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The Z order index of this layer on this output</span></span><br><span class="line">    <span class="keyword">uint32_t</span> z;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * HWC state</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Hwc</span> &#123;</span></span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">Hwc</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;HWC2::Layer&gt; hwcLayer)</span> : <span class="title">hwcLayer</span><span class="params">(hwcLayer)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The HWC Layer backing this layer</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;HWC2::Layer&gt; hwcLayer;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The HWC composition type for this layer</span></span><br><span class="line">        Hwc2::IComposerClient::Composition hwcCompositionType&#123;</span><br><span class="line">                Hwc2::IComposerClient::Composition::INVALID&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The buffer cache for this layer. This is used to lower the</span></span><br><span class="line">        <span class="comment">// cost of sending reused buffers to the HWC.</span></span><br><span class="line">        HwcBufferCache hwcBufferCache;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The HWC state is optional, and is only set up if there is any potential</span></span><br><span class="line">    <span class="comment">// HWC acceleration possible.</span></span><br><span class="line">    <span class="built_in">std</span>::optional&lt;Hwc&gt; hwc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Debugging</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dump</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>&amp; result)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>关系图：</p><p><img src="Layer_Struct.png" alt="Layer显示结构图"></p><p>解释：</p><ol><li>Layer区域和屏幕区域，就是Layer和屏幕本身的大小区域</li><li>sourceCrop：剪切区域，sourceCrop是对Layer进行剪切的，值截取部分Layer的内容进行显示；sourceCrop不超过Layer的大小，超过没有意义。</li><li>displayFrame：显示区域，displayFrame表示Layer在屏幕上的显示区域，具体说来，是sourceCrop区域在显示屏上的显示区域。displayFrame一般来说，小于屏幕的区域。而displayFrame可能比sourceCrop大，可能小，这都是正常的，只是需要做缩放，这就是合成时需要处理的。</li><li>visibleRegion：可见区域，displayFrame 区域不一定都能看到的，如果存在上层Layer，那么displayFrame区域可能部分或全部被盖住，displayFrame没有被盖住的部分就是可见区域visibleRegion。</li><li>damageRegion 受损区域，或者称之为更新区域。damageRegion表示Layer内容被破坏的区域，也就是说这部分区域的内容变了，所以这个属性一般是和上一帧相比时才有意义。这算是对合成的一种优化，重新合成时，我们只去合成damageRegion区域，其他的可见区域还是用的上一帧的数据。</li><li>visibleNonTransparentRegion：可见非透明区域。透明区域transparentRegion是可见区域visibleRegion的一部分，只是这一部分透明的看到的是底层Layer的内容。在SurfaceFlinger的Layer中定义visibleNonTransparentRegion，表示可见而又不透明的部分。</li><li>coveredRegion：被覆盖的区域。表示Layer被TopLayer覆盖的区域，一看图就很好理解。从图中，你可以简单的认为是displayFrame和TopLayer区域重合的部分。</li></ol><p><strong>注意：</strong> 这里之所以说简单的认为，这是因为HWC空间的区域大小是SurfaceFlinger空间的区域经过缩放，经过Transform旋转，移动等后才得出的，要是混淆了就理解不对了。</p><h4 id="合成属性（确认用哪种合成方式）"><a href="#合成属性（确认用哪种合成方式）" class="headerlink" title="合成属性（确认用哪种合成方式）"></a>合成属性（确认用哪种合成方式）</h4><blockquote><p>定义层应如何与其他层合成。包括混合模式和用于Alpha合成的全层Alpha值等信息。总的说来，合成分为两个大类：<code>GPU合成</code>和<code>HWC合成</code>。根据具体的情况，分为下列几类：</p></blockquote><figure class="highlight c++"><figcaption><span>hardware/libhardware/include/hardware/hwcomposer2.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Composition</span> :</span> <span class="keyword">int32_t</span> &#123;</span><br><span class="line">    Invalid = HWC2_COMPOSITION_INVALID,</span><br><span class="line">    <span class="built_in">Client</span> = HWC2_COMPOSITION_CLIENT,</span><br><span class="line">    Device = HWC2_COMPOSITION_DEVICE,</span><br><span class="line">    SolidColor = HWC2_COMPOSITION_SOLID_COLOR,</span><br><span class="line">    Cursor = HWC2_COMPOSITION_CURSOR,</span><br><span class="line">    Sideband = HWC2_COMPOSITION_SIDEBAND,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>释义：</strong></p><ol><li>Client 相对HWC2硬件合成的概念，主要是处理BufferLayer数据，用GPU处理。</li><li>Device HWC2硬件设备，主要处理BufferLayer数据，用HWC处理</li><li>SolidColor 固定颜色合成，主要处理ColorLayer数据，用HWC处理或GPU处理。</li><li>Cursor 鼠标标识合成，主要处理鼠标等图标，用HWC处理或GPU处理</li><li>Sideband Sideband为视频的边频带，一般需要需要硬件合成器作特殊处理，但是也可以用GPU处理。</li></ol><p>在合成信息HWCInfo中，包含成的类型。通过Layer的setCompositionType方法进行指定：</p><figure class="highlight c++"><figcaption><span>frameworks/native/services/surfaceflinger/Layer.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Layer::setCompositionType</span><span class="params">(<span class="keyword">int32_t</span> hwcId, HWC2::Composition type, <span class="keyword">bool</span> callIntoHwc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getBE().mHwcLayers.count(hwcId) == <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"setCompositionType called without a valid HWC layer"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span>&amp; hwcInfo = getBE().mHwcLayers[hwcId];</span><br><span class="line">    <span class="keyword">auto</span>&amp; hwcLayer = hwcInfo.layer;</span><br><span class="line">    ALOGV(<span class="string">"setCompositionType(%"</span> PRIx64 <span class="string">", %s, %d)"</span>, hwcLayer-&gt;getId(), to_string(type).c_str(),</span><br><span class="line">          <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(callIntoHwc));  <span class="comment">//默认true</span></span><br><span class="line">    <span class="keyword">if</span> (hwcInfo.compositionType != type) &#123;</span><br><span class="line">        ALOGV(<span class="string">"    actually setting"</span>);</span><br><span class="line">        hwcInfo.compositionType = type;</span><br><span class="line">        <span class="keyword">if</span> (callIntoHwc) &#123;</span><br><span class="line">            <span class="keyword">auto</span> error = hwcLayer-&gt;setCompositionType(type);  <span class="comment">//合成方式</span></span><br><span class="line">            ALOGE_IF(error != HWC2::Error::None,</span><br><span class="line">                     <span class="string">"[%s] Failed to set "</span></span><br><span class="line">                     <span class="string">"composition type %s: %s (%d)"</span>,</span><br><span class="line">                     mName.<span class="built_in">string</span>(), to_string(type).c_str(), to_string(error).c_str(),</span><br><span class="line">                     <span class="keyword">static_cast</span>&lt;<span class="keyword">int32_t</span>&gt;(error));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>确定合成类型分成三步：</p><ol><li>SurfaceFlinger制定合成类型，此时<code>callIntoHwc=true</code>，将类型制定给HWC</li><li>HWC根据实际情况看SurfaceFlinger制定的合成类型是否可以执行，如果不满足，作出修改</li><li>SurfaceFlinger根据HWC的修改情况再作出调整，最终确认合成类型，此时<code>callIntoHwc=false</code></li></ol><h4 id="优化属性"><a href="#优化属性" class="headerlink" title="优化属性"></a>优化属性</h4><blockquote><p>提供一些非必须的参数，以供HWC进行合成的优化。包括层的可见区域以及层的哪个部分自上一帧以来已经更新等信息。也就是前面说到的visibleRegion，damageRegion等。</p></blockquote><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><blockquote><p>本篇主要是SurfaceFlinger概述，和HWC2的概述，还有Layer的属性和类型，合成方式的内容。<br>另外还有关于HWC的内容，和Display显示设备的信息重新划分单独的一篇学习。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;转载夕月风大佬博客： &lt;a href=&quot;https://www.jianshu.com/p/824a9ddf68b9&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.jianshu.com/p/824a9ddf68b9&lt;/a&gt;&lt;br&gt;参考Android Q AOSP源码添加修改部分内容&lt;br&gt;参考源码： &lt;a href=&quot;http://aosp.opersys.com/xref/android-10.0.0_r14/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://aosp.opersys.com/xref/android-10.0.0_r14/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="android" scheme="http://wizzie.top/categories/android/"/>
    
    
      <category term="graphics" scheme="http://wizzie.top/tags/graphics/"/>
    
  </entry>
  
  <entry>
    <title>Android Binder实例</title>
    <link href="http://wizzie.top/2019/11/24/2019/191124_android_binder_example/"/>
    <id>http://wizzie.top/2019/11/24/2019/191124_android_binder_example/</id>
    <published>2019-11-24T07:59:40.000Z</published>
    <updated>2020-03-08T10:18:54.622Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Binder通信是Android用的比较多的一种通信机制，它是一种client-server的通信结构。Binder通信具有以下特点：</p></blockquote><ol><li>用驱动程序来推进进程间的通信；</li><li>可以通过共享内存的方式来提供性能；</li><li>可以为进程请求分配每个进程的线程池；</li><li>针对系统中的对象引入了引用计数和跨进程的对象引用映射；</li><li>可以方便的进行进程同步调用。</li></ol><a id="more"></a><blockquote><p>以下简单的Binder实例参考一位大佬。</p></blockquote><h2 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">cmds&#x2F;helloWorld&#x2F;Android.mk                 | 29 +++++++++++++++++++++++</span><br><span class="line">cmds&#x2F;helloWorld&#x2F;BnHelloWorldService.h      | 16 +++++++++++++</span><br><span class="line">cmds&#x2F;helloWorld&#x2F;BpHelloWorldService.h      | 12 ++++++++++</span><br><span class="line">cmds&#x2F;helloWorld&#x2F;HelloWorldService.h        | 17 +++++++++++++</span><br><span class="line">cmds&#x2F;helloWorld&#x2F;IHelloWorldService.h       | 21 +++++++++++++++++</span><br><span class="line">cmds&#x2F;helloWorld&#x2F;main_helloworldclient.cpp  | 36 ++++++++++++++++++++++++++++</span><br><span class="line">cmds&#x2F;helloWorld&#x2F;main_helloworldservice.cpp | 22 +++++++++++++++++</span><br><span class="line">libs&#x2F;helloWorld&#x2F;Android.bp                 | 38 ++++++++++++++++++++++++++++++</span><br><span class="line">libs&#x2F;helloWorld&#x2F;BnHelloWorldService.cpp    | 24 +++++++++++++++++++</span><br><span class="line">libs&#x2F;helloWorld&#x2F;BnHelloWorldService.h      | 16 +++++++++++++</span><br><span class="line">libs&#x2F;helloWorld&#x2F;BpHelloWorldService.cpp    | 25 ++++++++++++++++++++</span><br><span class="line">libs&#x2F;helloWorld&#x2F;BpHelloWorldService.h      | 12 ++++++++++</span><br><span class="line">libs&#x2F;helloWorld&#x2F;HelloWorldService.cpp      | 33 ++++++++++++++++++++++++++</span><br><span class="line">libs&#x2F;helloWorld&#x2F;HelloWorldService.h        | 17 +++++++++++++</span><br><span class="line">libs&#x2F;helloWorld&#x2F;IHelloWorldService.cpp     |  8 +++++++</span><br><span class="line">libs&#x2F;helloWorld&#x2F;IHelloWorldService.h       | 21 +++++++++++++++++</span><br></pre></td></tr></table></figure><h2 id="cmds-helloWorld-Android-mk"><a href="#cmds-helloWorld-Android-mk" class="headerlink" title="cmds/helloWorld/Android.mk"></a><code>cmds/helloWorld/Android.mk</code></h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Copyright 2019 The Android Open Source Project</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">LOCAL_PATH:= <span class="variable">$(<span class="built_in">call</span> my-<span class="built_in">dir</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(CLEAR_VARS)</span></span><br><span class="line">LOCAL_SRC_FILES := main_helloworldservice.cpp</span><br><span class="line"></span><br><span class="line">LOCAL_SHARED_LIBRARIES :=\</span><br><span class="line">libutils \</span><br><span class="line">libbinder \</span><br><span class="line">libhelloworld</span><br><span class="line"></span><br><span class="line">base := <span class="variable">$(LOCAL_PATH)</span>/../../libs/helloWorld</span><br><span class="line"></span><br><span class="line">LOCAL_MODULE := helloworldservice</span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(BUILD_EXECUTABLE)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(CLEAR_VARS)</span></span><br><span class="line">LOCAL_SRC_FILES := main_helloworldclient.cpp</span><br><span class="line"></span><br><span class="line">LOCAL_SHARED_LIBRARIES :=\</span><br><span class="line">libutils \</span><br><span class="line">libbinder \</span><br><span class="line">libhelloworld</span><br><span class="line"></span><br><span class="line">base := <span class="variable">$(LOCAL_PATH)</span>/../../libs/helloWorld</span><br><span class="line"></span><br><span class="line">LOCAL_MODULE := helloworldclient  //编译结果so文件</span><br><span class="line"><span class="keyword">include</span> <span class="variable">$(BUILD_EXECUTABLE)</span></span><br></pre></td></tr></table></figure><h2 id="cmds-helloWorld-BpHelloWorldService-h"><a href="#cmds-helloWorld-BpHelloWorldService-h" class="headerlink" title="cmds/helloWorld/BpHelloWorldService.h"></a><code>cmds/helloWorld/BpHelloWorldService.h</code></h2><blockquote><p>客户端Service头文件，声明<code>BpHelloWorldService</code>函数</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;binder/Parcel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;IHelloWorldService.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> android&#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BpHelloWorldService</span>:</span> <span class="keyword">public</span> BpInterface&lt;IHelloWorldService&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    BpHelloWorldService (<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; impl);</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">status_t</span> <span class="title">helloWorld</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="cmds-helloWorld-BnHelloWorldService-h"><a href="#cmds-helloWorld-BnHelloWorldService-h" class="headerlink" title="cmds/helloWorld/BnHelloWorldService.h"></a><code>cmds/helloWorld/BnHelloWorldService.h</code></h2><blockquote><p>Bn服务端Service头文件，声明<code>onTranscat</code>接口</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ANDROID_BNHELLOWORLD_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ANDROID_BNHELLOWORLD_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;binder/Parcel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;IHelloWorldService.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> android &#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BnHelloWorldService</span> :</span> <span class="keyword">public</span> BnInterface&lt;IHelloWorldService&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">status_t</span> <span class="title">onTransact</span> <span class="params">( <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, Parcel* reply, <span class="keyword">uint32_t</span> flags = <span class="number">0</span> )</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h2 id="cmds-helloWorld-HelloWorldService-h"><a href="#cmds-helloWorld-HelloWorldService-h" class="headerlink" title="cmds/helloWorld/HelloWorldService.h"></a><code>cmds/helloWorld/HelloWorldService.h</code></h2><blockquote><p>Bn服务端实现类的头文件，声明<code>helloworld</code>和<code>onTransact</code>函数，和私有类构造函数和析构函数<br>和另一个库的文件同名，继承Bn服务端接口</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;BnHelloWorldService.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utils/Log.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> android &#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloWorldService</span> :</span> <span class="keyword">public</span> BnHelloWorldService</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">instantiate</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">status_t</span> <span class="title">helloWorld</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">status_t</span> <span class="title">onTransact</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, Parcel* reply, <span class="keyword">uint32_t</span> flags)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    HelloWorldService();</span><br><span class="line">    <span class="keyword">virtual</span> ~HelloWorldService();</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="cmds-helloWorld-IHelloWorldService-h"><a href="#cmds-helloWorld-IHelloWorldService-h" class="headerlink" title="cmds/helloWorld/IHelloWorldService.h"></a><code>cmds/helloWorld/IHelloWorldService.h</code></h2><blockquote><p>Bp和Bn端的中间接口头文件</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ANDROID_HELLOWORLD_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ANDROID_HELLOWORLD_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;binder/IInterface.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> android &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    HW_HELLOWORLD = IBinder::FIRST_CALL_TRANSACTION,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IHelloWorldService</span>:</span> <span class="keyword">public</span> IInterface &#123; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    DECLARE_META_INTERFACE(HelloWorldService);</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">status_t</span> <span class="title">helloWorld</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h2 id="cmds-helloWorld-main-helloworldclient-cpp"><a href="#cmds-helloWorld-main-helloworldclient-cpp" class="headerlink" title="cmds/helloWorld/main_helloworldclient.cpp"></a><code>cmds/helloWorld/main_helloworldclient.cpp</code></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_TAG <span class="meta-string">"main_helloworldclient"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;binder/IPCThreadState.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;binder/ProcessState.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;binder/IServiceManager.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utils/Log.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utils/RefBase.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;IHelloWorldService.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> android;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unused(x) x=x</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//ALOGI("HelloWorldService client is now starting");</span></span><br><span class="line">unused(argc);</span><br><span class="line">unused(argv);</span><br><span class="line"></span><br><span class="line">sp&lt;IServiceManager&gt; sm = defaultServiceManager();</span><br><span class="line">sp&lt;IBinder&gt; b;</span><br><span class="line">sp&lt;IHelloWorldService&gt; sHelloWorldService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    b = sm-&gt;getService(String16(</span><br><span class="line"><span class="string">"android.apps.IHelloWorldService"</span>));</span><br><span class="line">    <span class="keyword">if</span> (b!=<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">//ALOGI("helloworldservice is not working, waiting ...");</span></span><br><span class="line">    usleep(<span class="number">500000</span>);</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">sHelloWorldService = interface_cast&lt;IHelloWorldService&gt;(b);</span><br><span class="line">sHelloWorldService -&gt; helloWorld(<span class="string">"hello, world"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="cmds-helloWorld-main-helloworldservice-cpp"><a href="#cmds-helloWorld-main-helloworldservice-cpp" class="headerlink" title="cmds/helloWorld/main_helloworldservice.cpp"></a><code>cmds/helloWorld/main_helloworldservice.cpp</code></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;binder/IPCThreadState.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;binder/ProcessState.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;binder/IServiceManager.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utils/Log.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;IHelloWorldService.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;HelloWorldService.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> android;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unused(x) x=x</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   unused(argc);</span><br><span class="line">   unused(argv);</span><br><span class="line">    HelloWorldService::instantiate();</span><br><span class="line">    ProcessState::self()-&gt;startThreadPool();</span><br><span class="line">    <span class="comment">//ALOGI("HelloWorldService is starting now");</span></span><br><span class="line">    <span class="comment">//ALOGI("HelloWorldService is starting now   tempChar = %s", tempChar);</span></span><br><span class="line">    IPCThreadState::self()-&gt;joinThreadPool();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="libs-helloWorld-Android-bp"><a href="#libs-helloWorld-Android-bp" class="headerlink" title="libs/helloWorld/Android.bp"></a><code>libs/helloWorld/Android.bp</code></h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">// Copyright (C) 2010 The Android Open Source Project</span><br><span class="line">//</span><br><span class="line">// Licensed under the Apache License, Version 2.0 (the <span class="string">"License"</span>);</span><br><span class="line">// you may not use this file except in compliance with the License.</span><br><span class="line">// You may obtain a copy of the License at</span><br><span class="line">//</span><br><span class="line">//      http://www.apache.org/licenses/LICENSE-2.0</span><br><span class="line">//</span><br><span class="line">// Unless required by applicable law or agreed to in writing, software</span><br><span class="line">// distributed under the License is distributed on an <span class="string">"AS IS"</span> BASIS,</span><br><span class="line">// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span><br><span class="line">// See the License for the specific language governing permissions and</span><br><span class="line">// limitations under the License.</span><br><span class="line">cc_library_shared &#123;</span><br><span class="line">    name: <span class="string">"libhelloworld"</span>,</span><br><span class="line">    srcs: [</span><br><span class="line">        <span class="string">"BnHelloWorldService.cpp"</span>,</span><br><span class="line">        <span class="string">"BpHelloWorldService.cpp"</span>,</span><br><span class="line">        <span class="string">"HelloWorldService.cpp"</span>,</span><br><span class="line">        <span class="string">"IHelloWorldService.cpp"</span>,</span><br><span class="line">    ],</span><br><span class="line"></span><br><span class="line">    shared_libs: [</span><br><span class="line">        <span class="string">"libcutils"</span>,</span><br><span class="line">        <span class="string">"liblog"</span>,</span><br><span class="line">        <span class="string">"libutils"</span>,</span><br><span class="line">        <span class="string">"libbinder"</span>,</span><br><span class="line">    ],</span><br><span class="line"></span><br><span class="line">    include_dirs: [<span class="string">"frameworks/base/cmds"</span>], //上面创建的库</span><br><span class="line"></span><br><span class="line">    cflags: [</span><br><span class="line">        <span class="string">"-Wall"</span>,</span><br><span class="line">        <span class="string">"-Wextra"</span>,</span><br><span class="line">        <span class="string">"-Werror"</span>,</span><br><span class="line">    ],</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="libs-helloWorld-BnHelloWorldService-h"><a href="#libs-helloWorld-BnHelloWorldService-h" class="headerlink" title="libs/helloWorld/BnHelloWorldService.h"></a><code>libs/helloWorld/BnHelloWorldService.h</code></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ANDROID_BNHELLOWORLD_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ANDROID_BNHELLOWORLD_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;binder/Parcel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;IHelloWorldService.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> android &#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BnHelloWorldService</span> :</span> <span class="keyword">public</span> BnInterface&lt;IHelloWorldService&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">status_t</span> <span class="title">onTransact</span> <span class="params">( <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, Parcel* reply, <span class="keyword">uint32_t</span> flags = <span class="number">0</span> )</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h2 id="libs-helloWorld-BnHelloWorldService-cpp"><a href="#libs-helloWorld-BnHelloWorldService-cpp" class="headerlink" title="libs/helloWorld/BnHelloWorldService.cpp"></a><code>libs/helloWorld/BnHelloWorldService.cpp</code></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;BnHelloWorldService.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;binder/Parcel.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> android &#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">BnHelloWorldService::onTransact</span><span class="params">(<span class="keyword">uint32_t</span> code,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">const</span> Parcel &amp;data,</span></span></span><br><span class="line"><span class="function"><span class="params">                              Parcel *reply,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">uint32_t</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(code) &#123;</span><br><span class="line">    <span class="keyword">case</span> HW_HELLOWORLD: &#123;</span><br><span class="line">        CHECK_INTERFACE(IHelloWorldService, data, reply);   <span class="comment">//检查接口</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *str;</span><br><span class="line">        str = data.readCString(); <span class="comment">//读取数据</span></span><br><span class="line">        reply-&gt; writeInt32(helloWorld(str)); <span class="comment">//写入数据</span></span><br><span class="line">        <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">    &#125; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">       <span class="keyword">return</span> BBinder::onTransact(code, data, reply, flags); <span class="comment">//服务端接口接收数据</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="libs-helloWorld-BpHelloWorldService-h"><a href="#libs-helloWorld-BpHelloWorldService-h" class="headerlink" title="libs/helloWorld/BpHelloWorldService.h"></a><code>libs/helloWorld/BpHelloWorldService.h</code></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;binder/Parcel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;IHelloWorldService.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> android&#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BpHelloWorldService</span>:</span> <span class="keyword">public</span> BpInterface&lt;IHelloWorldService&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    BpHelloWorldService (<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; impl);</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">status_t</span> <span class="title">helloWorld</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="libs-helloWorld-BpHelloWorldService-cpp"><a href="#libs-helloWorld-BpHelloWorldService-cpp" class="headerlink" title="libs/helloWorld/BpHelloWorldService.cpp"></a><code>libs/helloWorld/BpHelloWorldService.cpp</code></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;binder/Parcel.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;BpHelloWorldService.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utils/Log.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> android&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">BpHelloWorldService::helloWorld</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span> </span>&#123;</span><br><span class="line">    Parcel data, reply;</span><br><span class="line">    data.writeInterfaceToken(</span><br><span class="line">IHelloWorldService::getInterfaceDescriptor());</span><br><span class="line">    data.writeCString(str);  <span class="comment">//写入数据</span></span><br><span class="line">    <span class="keyword">status_t</span> status = remote()-&gt;transact(HW_HELLOWORLD, data, &amp;reply); <span class="comment">//远程传输数据</span></span><br><span class="line">    <span class="keyword">if</span> (status != NO_ERROR) &#123;</span><br><span class="line">        ALOGI(<span class="string">"print helloworld error : %s"</span>, strerror(-status));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        status = reply.readInt32();  <span class="comment">//读取数据</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BpHelloWorldService::BpHelloWorldService (<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; impl)</span><br><span class="line">: BpInterface&lt;IHelloWorldService&gt;(impl)</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="libs-helloWorld-HelloWorldService-h"><a href="#libs-helloWorld-HelloWorldService-h" class="headerlink" title="libs/helloWorld/HelloWorldService.h"></a><code>libs/helloWorld/HelloWorldService.h</code></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;BnHelloWorldService.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utils/Log.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> android &#123;</span><br><span class="line"><span class="comment">//继承Bn服务端</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloWorldService</span> :</span> <span class="keyword">public</span> BnHelloWorldService</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">instantiate</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">status_t</span> <span class="title">helloWorld</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">status_t</span> <span class="title">onTransact</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, Parcel* reply, <span class="keyword">uint32_t</span> flags)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    HelloWorldService();</span><br><span class="line">    <span class="keyword">virtual</span> ~HelloWorldService();</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="libs-helloWorld-HelloWorldService-cpp"><a href="#libs-helloWorld-HelloWorldService-cpp" class="headerlink" title="libs/helloWorld/HelloWorldService.cpp"></a><code>libs/helloWorld/HelloWorldService.cpp</code></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;binder/IServiceManager.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;binder/IPCThreadState.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;BnHelloWorldService.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;HelloWorldService.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utils/Log.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> android &#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HelloWorldService::instantiate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    defaultServiceManager()-&gt;addService(</span><br><span class="line">            String16(<span class="string">"android.apps.IHelloWorldService"</span>), <span class="keyword">new</span> HelloWorldService());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">HelloWorldService::helloWorld</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span> </span>&#123;</span><br><span class="line">    ALOGI(<span class="string">"%s\n"</span>, str);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, str);</span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HelloWorldService::HelloWorldService()&#123;</span><br><span class="line">    ALOGI(<span class="string">"HelloWorldService is created"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HelloWorldService::~HelloWorldService()&#123;</span><br><span class="line">    ALOGI(<span class="string">"HelloWorldService is destroyed"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">HelloWorldService::onTransact</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, Parcel* reply, <span class="keyword">uint32_t</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> BnHelloWorldService::onTransact(code, data, reply, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="libs-helloWorld-IHelloWorldService-h"><a href="#libs-helloWorld-IHelloWorldService-h" class="headerlink" title="libs/helloWorld/IHelloWorldService.h"></a><code>libs/helloWorld/IHelloWorldService.h</code></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ANDROID_HELLOWORLD_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ANDROID_HELLOWORLD_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;binder/IInterface.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> android &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    HW_HELLOWORLD = IBinder::FIRST_CALL_TRANSACTION,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IHelloWorldService</span>:</span> <span class="keyword">public</span> IInterface &#123; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    DECLARE_META_INTERFACE(HelloWorldService);</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">status_t</span> <span class="title">helloWorld</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h2 id="libs-helloWorld-IHelloWorldService-cpp"><a href="#libs-helloWorld-IHelloWorldService-cpp" class="headerlink" title="libs/helloWorld/IHelloWorldService.cpp"></a><code>libs/helloWorld/IHelloWorldService.cpp</code></h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;IHelloWorldService.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;BpHelloWorldService.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> android &#123;</span><br><span class="line"></span><br><span class="line">IMPLEMENT_META_INTERFACE(HelloWorldService, <span class="string">"android.apps.IHelloWorldService"</span>);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Binder通信是Android用的比较多的一种通信机制，它是一种client-server的通信结构。Binder通信具有以下特点：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;用驱动程序来推进进程间的通信；&lt;/li&gt;
&lt;li&gt;可以通过共享内存的方式来提供性能；&lt;/li&gt;
&lt;li&gt;可以为进程请求分配每个进程的线程池；&lt;/li&gt;
&lt;li&gt;针对系统中的对象引入了引用计数和跨进程的对象引用映射；&lt;/li&gt;
&lt;li&gt;可以方便的进行进程同步调用。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="android" scheme="http://wizzie.top/categories/android/"/>
    
    
      <category term="graphics" scheme="http://wizzie.top/tags/graphics/"/>
    
  </entry>
  
  <entry>
    <title>Android Graphics 调试技巧（十一月份更新）</title>
    <link href="http://wizzie.top/2019/11/23/2019/191121_android_debug2/"/>
    <id>http://wizzie.top/2019/11/23/2019/191121_android_debug2/</id>
    <published>2019-11-23T15:52:00.000Z</published>
    <updated>2020-03-08T10:18:54.698Z</updated>
    
    <content type="html"><![CDATA[<h2 id="更新adb"><a href="#更新adb" class="headerlink" title="更新adb"></a>更新adb</h2><ul><li>更新命令：   sudo apt-get install android-tools-adb</li><li>查看当前adb指令的目录: which adb</li><li>查看版本：adb version</li></ul><a id="more"></a><h2 id="adb-shell相关"><a href="#adb-shell相关" class="headerlink" title="adb shell相关"></a>adb shell相关</h2><h3 id="ps（正在运行的进程）"><a href="#ps（正在运行的进程）" class="headerlink" title="ps（正在运行的进程）"></a>ps（正在运行的进程）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">USER 进程当前用户</span><br><span class="line">PID 进程ID</span><br><span class="line">PPID 父进程ID</span><br><span class="line">VSZ进程的虚拟内存大小，以KB为单位</span><br><span class="line">RSS 实际占用的内存大小，以KB为单位</span><br><span class="line">WCHAN 进程正在睡眠的内核函数名称；该函数的名称是从&#x2F;root&#x2F;system.map文件中获得的。</span><br><span class="line">PC 计算机中提供要从[存储器]中取出的下一个指令地址的[寄存器]</span><br><span class="line">NAME 进程状态及名称</span><br></pre></td></tr></table></figure><h3 id="top（CPU使用率）"><a href="#top（CPU使用率）" class="headerlink" title="top（CPU使用率）"></a>top（CPU使用率）</h3><blockquote><p>top命令提供了实时的对系统处理器的状态监视。它将显示系统中CPU最“敏感”的任务列表。该命令可以按CPU使用，内存使用和执行时间对任务进行排序。</p></blockquote><ol><li><code>VIRT</code>：这个内存使用就是一个应用占有的地址空间，只是要应用程序要求的，就全算在这里，而不管它真的用了没有。写程序怕出错，又不在乎占用的时候，多开点内存也是很正常的;</li><li><code>RES</code>：resident memory usage。常驻内存。这个值就是该应用程序真的使用的内存，但还有两个小问题，一是有些东西可能放在交换盘上了（SWAP），二是有些内存可能是共享的;</li><li><code>SHR</code>：shared memory。共享内存。就是说这一块内存空间有可能也被其他应用程序使用着;</li><li><code>DATA</code>：数据占用的内存。这一块是真正的该程序要求的数据空间，是真正在运行中要使用的。</li></ol><h3 id="vmstat（显示系统信息的）"><a href="#vmstat（显示系统信息的）" class="headerlink" title="vmstat（显示系统信息的）"></a>vmstat（显示系统信息的）</h3><p>vmstat是一个显示系统信息的命令。例如，它显示主存储器的可用容量和CPU的操作状态。<br>如果按原样执行vmstat命令，则会显示有关当前进程，内存，交换，设备，中断和CPU的信息。此外，如果附加“ - d”或“ - p”选项，将显示分区和磁盘上的读/写状态等。指定“-f”选项时，从系统启动到命令执行将显示创建进程的次数。</p><p>如果在vmstat之后指定以秒为单位的时间间隔，则每隔指定时间显示一次系统状态。此外，当您指定次数时，会显示指定的信息次数。</p><p>对于容量，可以使用“-S”选项指定单位。指定“-SM”时，容量单位以M字节显示。</p><p>例如：<br>以10秒为间隔显示内存和CPU信息三次： <code>vmstat 10 3</code></p><h3 id="meminfo（内存系统信息）"><a href="#meminfo（内存系统信息）" class="headerlink" title="meminfo（内存系统信息）"></a>meminfo（内存系统信息）</h3><p><code>cat /proc/meminfo</code></p><h3 id="free（显示内存使用情况）"><a href="#free（显示内存使用情况）" class="headerlink" title="free（显示内存使用情况）"></a>free（显示内存使用情况）</h3><blockquote><p>可以知道当前的内存使用情况。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-b以字节显示容量（默认）</span><br><span class="line">-k显示容量，以千字节为单位</span><br><span class="line">-m显示容量，以MB为单位</span><br><span class="line">-h  显示容量单位，包含Ｇ、Ｍ</span><br><span class="line">-t还显示物理内存和交换内存的总和</span><br></pre></td></tr></table></figure><h3 id="strace（跟踪进程执行时的系统调用和所接收的信号）"><a href="#strace（跟踪进程执行时的系统调用和所接收的信号）" class="headerlink" title="strace（跟踪进程执行时的系统调用和所接收的信号）"></a>strace（跟踪进程执行时的系统调用和所接收的信号）</h3><blockquote><p>strace常用来跟踪进程执行时的系统调用和所接收的信号。<br>在Linux世界，进程不能直接访问硬件设备，当进程需要访问硬件设备(比如读取磁盘文件，接收网络数据等等)时，必须由用户态模式切换至内核态模式，通 过系统调用访问硬件设备。strace可以跟踪到一个进程产生的系统调用,包括参数，返回值，执行消耗的时间。</p></blockquote><p>通用的完整用法：<br><code>strace -o output.txt -T -tt -e trace=all -p 12345</code></p><p>上面的含义是跟踪28979进程的所有系统调用（-e trace=all），并统计系统调用的花费时间，以及开始时间（并以可视化的时分秒格式显示），最后将记录结果存在output.txt文件里面。</p><h3 id="time（linux命令，ADB通用）"><a href="#time（linux命令，ADB通用）" class="headerlink" title="time（linux命令，ADB通用）"></a>time（linux命令，ADB通用）</h3><blockquote><p>测量从调用指定命令到结束所花费的时间，用户CPU时间和系统CPU时间。在指定命令的输出结果之后，将测量结果输出到标准错误输出。命令代码实际使用CPU的时间是用户CPU时间。因此，如果将不存在的命令作为time命令的参数，则用户CPU时间变为0。睡眠时间不计算在内。</p></blockquote><p>例如：<br>显示ls命令的执行时间： <code>time ls -a</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">real0m0.006s</span><br><span class="line">user0m0.006s</span><br><span class="line">sys0m0.000s</span><br></pre></td></tr></table></figure><h3 id="size"><a href="#size" class="headerlink" title="size"></a>size</h3><blockquote><p>显示一个目标文件或者链接库文件中的目标文件的各个段的大小(可执行文件段的大小,默认为a.out)</p></blockquote><p>例如（linux下）：   <code>size libui.so</code></p><p>text表示正文段大小，data表示包含静态变量和已经初始化（可执行文件包含了初始化的值）的全局变量的数据段大小，bss由可执行文件中不含其初始化值的全局变量组成。</p><h3 id="file（辨识文件类型）"><a href="#file（辨识文件类型）" class="headerlink" title="file（辨识文件类型）"></a>file（辨识文件类型）</h3><blockquote><p>file确定并显示文件类型，例如可执行文件或文本或其他数据。</p></blockquote><p>例如：<br><code>file libui.so</code><br>或者 <code>adb shell file ……</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-b以简单模式显示</span><br><span class="line">-i使文件成为mime类型字符串</span><br><span class="line">-z还要检查压缩文件</span><br><span class="line">-v显示版本</span><br></pre></td></tr></table></figure><hr><h2 id="fastboot相关"><a href="#fastboot相关" class="headerlink" title="fastboot相关"></a>fastboot相关</h2><ul><li>重启进入Recovery界面： adb reboot recovery</li><li>重启进入bootloader界面： adb reboot bootloader</li></ul><h3 id="进入Recovery模式"><a href="#进入Recovery模式" class="headerlink" title="进入Recovery模式"></a>进入Recovery模式</h3><ol><li>查看设备： adb devices</li><li>adb root</li><li>adb shell</li><li>进入fastboot： adb reboot fastboot</li><li>fastboot devices </li><li>查看当前使用分区： fastboot getvar current-slot</li><li>接着擦除分区和用户数据，然后flash烧录</li></ol><p>如果不能识别或者没权限，优先检查lsusb添加序列号到<code>/etc/udev/rules.d/</code></p><p>如果出现错误:<code>no permissions fastboot</code></p><p>用fastboot命令查看设备提示无权限，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fastboot -l devices</span><br><span class="line">no permissions         fastboot usb:1.2-1</span><br></pre></td></tr></table></figure><p>因为权限问题，是fastboot没有权限， 解决步骤：</p><ol><li>将fastboot的所有者属性改成root,用<code>which fastboot</code>命令找到fastboot所在的目录，然后进入此目录</li><li>用命令chown改其属性:<code>sudo chown root:root fastboot</code></li><li>将其权限更改一下：<code>sudo chmod +s fastboot</code></li></ol><p>还存在一种可能性，就是<code>adb</code>版本过低。</p><h3 id="部分参数"><a href="#部分参数" class="headerlink" title="部分参数"></a>部分参数</h3><table><thead><tr><th align="center">fastboot [options]</th><th align="center">Notes</th></tr></thead><tbody><tr><td align="center">-w</td><td align="center">清空用户数据分区和缓存分区.相当于recovery中的”wipe data/factoryreset”</td></tr><tr><td align="center">-s &lt;串口号&gt;</td><td align="center">指定要操作的设备的串口号</td></tr><tr><td align="center">-p &lt;产品名&gt;</td><td align="center">指定要操作的设备的产品名.比如hero,bravo,dream…</td></tr><tr><td align="center">-c &lt;命令行&gt;</td><td align="center">用命令行替换系统的启动命令行</td></tr></tbody></table><hr><h2 id="解析so文件addr2line"><a href="#解析so文件addr2line" class="headerlink" title="解析so文件addr2line"></a>解析so文件addr2line</h2><p><code>addr2line [address] -e test.so -f</code><br>或者<br><code>readelf -a [.so/.bin]</code></p><h3 id="根据解析结果查询函数"><a href="#根据解析结果查询函数" class="headerlink" title="根据解析结果查询函数"></a>根据解析结果查询函数</h3><p>C++在linux系统编译后会变成类似<code>_ZNK...</code>的修饰名。使用<code>c++filt</code>获取函数的原始名称：</p><p><code>c++filt [_ZNK...函数修饰名]</code></p><hr><h2 id="跳过开机向导"><a href="#跳过开机向导" class="headerlink" title="跳过开机向导"></a>跳过开机向导</h2><p><code>adb shell settings put global device_provisioned 1（默认是0）</code></p><h2 id="Android-10-AOSP源码打开模拟Vsync（Systrace可查看）"><a href="#Android-10-AOSP源码打开模拟Vsync（Systrace可查看）" class="headerlink" title="Android 10 AOSP源码打开模拟Vsync（Systrace可查看）"></a>Android 10 AOSP源码打开模拟Vsync（Systrace可查看）</h2><ul><li>源码： Android 10的AOSP</li><li>方法： 修改<code>surfaceflinger/Scheduler/DispSync.cpp</code>的<code>static const bool kEnableZeroPhaseTracer = false;</code>为<code>True</code></li><li>另外在查看<code>ZeroPhaseTracer</code>还需要打开<code>mTraceDetailedInfo</code>，即<code>const bool mTraceDetailedInfo = true;</code></li></ul><h2 id="对比文件和文件夹区别（可用于git解决冲突）"><a href="#对比文件和文件夹区别（可用于git解决冲突）" class="headerlink" title="对比文件和文件夹区别（可用于git解决冲突）"></a>对比文件和文件夹区别（可用于git解决冲突）</h2><p><code>meld 文件/文件夹</code></p><p>比较文件: <code>vimdiff a.txt b.txt</code></p><h2 id="repo"><a href="#repo" class="headerlink" title="repo"></a>repo</h2><blockquote><p>Android代码包含几百个git库，下载和管理都需要一个方便的工具，Google开发了repo用来管理多个git库，通过manifest.xml文件将一个个的git库管理起来,形成一个系统。</p></blockquote><h3 id="Gerrit"><a href="#Gerrit" class="headerlink" title="Gerrit"></a>Gerrit</h3><blockquote><p><code>Gerrit</code>是Google开发的一个代码审核工具。它是一个Web工具,它靠git来存放代码,靠repo这个接口来提交和下载修改。 提交到Gerrit时,每个Git库的修改都会变成一次提交,每个提交可以有一个或多个人来review和verify。当你的修改被批准之后,Gerrit会把修改真正提交到指定的分支中。</p></blockquote><p>Gerrit上代码提交的三种状态：<br><code>Open、Merged、Abandoned</code></p><ol><li><code>Open</code>: 状态的代码需要经过Review,Verify,Submit操作后才会真正入库,即成为Merged状态</li><li><code>Merged</code>: 状态的代码已经入库,不能再Abandoned,只能Revert</li><li><code>Open</code>: 状态的代码由于各种原因不能入库的可以放弃,即Abandoned状态。Abandoned 状态的代码不能再入库,如有需要,可以“Restore”。</li></ol><h3 id="Jenkins"><a href="#Jenkins" class="headerlink" title="Jenkins"></a>Jenkins</h3><p>一个持续集成工具,一个运行任务的平台。能实施编译、监控集成中存在的错误，提供详细的日志文件和提醒功能。能用图表形象地展示项目构建的趋势和稳定性。</p><h3 id="repo链接指定版本的manifest-xml"><a href="#repo链接指定版本的manifest-xml" class="headerlink" title="repo链接指定版本的manifest.xml"></a>repo链接指定版本的<code>manifest.xml</code></h3><p><code>repo init -m manifest_TEST.xml</code><br>然后可以在目录查看结果，再同步代码。</p><h2 id="ssh生成publickey（指定邮箱）"><a href="#ssh生成publickey（指定邮箱）" class="headerlink" title="ssh生成publickey（指定邮箱）"></a>ssh生成publickey（指定邮箱）</h2><p><code>ssh-keygen -t rsa -C ****@mail.com</code></p><hr><h2 id="Git相关命令"><a href="#Git相关命令" class="headerlink" title="Git相关命令"></a>Git相关命令</h2><h3 id="git用户设置"><a href="#git用户设置" class="headerlink" title="git用户设置"></a>git用户设置</h3><ul><li><p><code>git config --global user.name ***</code></p></li><li><p><code>git config --global user.email ****@mail.com</code></p></li><li><p>查看config： <code>git config -l</code></p></li></ul><h3 id="生成补丁"><a href="#生成补丁" class="headerlink" title="生成补丁"></a>生成补丁</h3><p><code>git format-patch -1 [最近的提交CommitID]</code></p><h3 id="生成指定某个commit提交的补丁"><a href="#生成指定某个commit提交的补丁" class="headerlink" title="生成指定某个commit提交的补丁"></a>生成指定某个commit提交的补丁</h3><p><code>git format-patch abc123d^..abc123d</code></p><h3 id="获取补丁"><a href="#获取补丁" class="headerlink" title="获取补丁"></a>获取补丁</h3><ol><li>申请生成在本地，但是没有加入暂存区： <code>git apply [PatchA]</code></li><li>直接申请生成提交： <code>git am [PatchB]</code></li></ol><h3 id="git-add用法"><a href="#git-add用法" class="headerlink" title="git add用法"></a>git add用法</h3><ul><li><code>git add .</code>:提交所有修改的文件,包括新增文件,不包括删除文件</li><li><code>git add -u</code>:提交所有修改文件,包括删除文件,不包括新增文件</li><li><code>git add -A</code>:提交包括新增和删除文件的所有文件</li></ul><h3 id="从暂存区域移除等其他命令"><a href="#从暂存区域移除等其他命令" class="headerlink" title="从暂存区域移除等其他命令"></a>从暂存区域移除等其他命令</h3><table><thead><tr><th align="center">Command</th><th align="center">Notes</th></tr></thead><tbody><tr><td align="center">git rm</td><td align="center">从暂存区域移除,并连带从工作目录中删除指定的文件</td></tr><tr><td align="center">git rm -f</td><td align="center">如果删除之前修改过并且已经放到暂存区域的话,则必须要用强制删除选项<code>-f</code></td></tr><tr><td align="center">git reset HEAD <file>…</td><td align="center">取消对文件的修改,把之前版本的文件复制过来重写此文件。</td></tr><tr><td align="center">git checkout – <file>…</td><td align="center">取消已经暂存的文件</td></tr><tr><td align="center">git clean</td><td align="center">删除未暂存的文件</td></tr><tr><td align="center">git diff</td><td align="center">查看尚未暂存的文件更新了哪些部分(和暂存区中)</td></tr><tr><td align="center">git diff –cached</td><td align="center">看已经暂存起来的文件和上次提交时的快照之间的差异</td></tr><tr><td align="center">git log –graph</td><td align="center">显示图形表示的分支合并历史</td></tr><tr><td align="center">git log –since=2.weeks</td><td align="center">列出所有最近两周内的提交</td></tr><tr><td align="center">git log –p</td><td align="center">以patch形式显示提交</td></tr><tr><td align="center">git log -p -2</td><td align="center">常用 -p 选项展开显示每次提交的内容差异，用 -2 则仅显示最近的两次更新</td></tr><tr><td align="center">git log –stat</td><td align="center">仅显示简要的增改行数统计。</td></tr></tbody></table><hr><h2 id="GDB命令"><a href="#GDB命令" class="headerlink" title="GDB命令"></a>GDB命令</h2><table><thead><tr><th align="center">Command</th><th align="center">Notes</th></tr></thead><tbody><tr><td align="center">bt</td><td align="center">查看各级函数调用及参数</td></tr><tr><td align="center">bt full</td><td align="center">详细堆栈信息</td></tr><tr><td align="center">bt PID</td><td align="center">查看PID信息</td></tr><tr><td align="center">frame</td><td align="center">选择栈帧</td></tr><tr><td align="center">info locals</td><td align="center">查看当前栈帧局部变量的值</td></tr><tr><td align="center">info registers</td><td align="center">可以看函数入参</td></tr><tr><td align="center">thread n</td><td align="center">切换到线程n</td></tr><tr><td align="center">info threads</td><td align="center">查看线程</td></tr><tr><td align="center">disassemble</td><td align="center">反汇编（默认范围是选择帧的pc附近的函数）</td></tr><tr><td align="center">info frame</td><td align="center">选择堆栈帧</td></tr><tr><td align="center">info args</td><td align="center">显示函数参数和局部变量的内容</td></tr><tr><td align="center">info reg（或者i r）</td><td align="center">查看地址</td></tr><tr><td align="center">disas</td><td align="center">反汇编查看函数（包含地址信息）</td></tr><tr><td align="center">i proc m （info proc mappings 的简写）</td><td align="center">核查零是不是有效地址</td></tr></tbody></table><h3 id="Bt"><a href="#Bt" class="headerlink" title="Bt"></a>Bt</h3><blockquote><p>跟踪堆栈的信息: <code>bt [-a|-g|-r|-t|-T|-l|-e|-E|-f|-F|-o|-O] [-R ref] [-I ip] [-S sp] [pid | task]</code></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Bt 无参数则显示当前任务的堆栈信息</span><br><span class="line">Bt –a 以任务为单位，显示每个任务的堆栈信息</span><br><span class="line">Bt –t 显示当前任务的堆栈中所有的文本标识符</span><br><span class="line">Bt –f 显示当前任务的所有堆栈数据，通过用来检查每个函数的参数传递</span><br></pre></td></tr></table></figure><h3 id="mod命令"><a href="#mod命令" class="headerlink" title="mod命令"></a>mod命令</h3><blockquote><p>用来加载调试符号，有时一些结构或者函数的符号信息不在调试版本内核里面，需要用<code>gcc -g</code>选项编译自己的模块，然后用mod命令加载里面的调试信息。这样<code>sym</code>和<code>whatis</code>命令就能正确解释我们自己模块里面自定义的结构等信息。</p></blockquote><hr><h2 id="ffmpeg-转换jpg和png格式"><a href="#ffmpeg-转换jpg和png格式" class="headerlink" title="ffmpeg 转换jpg和png格式"></a>ffmpeg 转换jpg和png格式</h2><p><code>ffmpeg -i test.png test1.jpg</code></p><h2 id="远程服务器使用ssh链接并且映射"><a href="#远程服务器使用ssh链接并且映射" class="headerlink" title="远程服务器使用ssh链接并且映射"></a>远程服务器使用ssh链接并且映射</h2><p>在用户根目录的<code>.bashrc</code>添加：</p><ol><li>链接：<br><code>alias sshTest=&#39;function _ssh() {  echo &quot;提示信息&quot;; ssh -p 端口 服务器用户名@IP; unset -f ssh; }; _ssh&#39;</code></li><li>映射：<br><code>alias sshreferenceTest=&#39;echo &quot;提示信息&quot;;sshfs -p 端口 -o cache=yes,reconnect 服务器用户名@IP:/home/服务器映射目录 /home/user/本地映射目录&#39;</code></li></ol><p>执行<code>source .bashrc</code>生效</p><blockquote><p>如果服务器映射报错<code>bad mount point</code>/mnt/‘: Transport endpoint is not connected`</p></blockquote><p>解决方法：</p><ol><li><code>sudo  umount  --all</code>（或者指定目录）</li><li>重新mount，即<code>sudo mount --all</code></li></ol><h2 id="linux下修改图片尺寸（jpg、png…）"><a href="#linux下修改图片尺寸（jpg、png…）" class="headerlink" title="linux下修改图片尺寸（jpg、png…）"></a>linux下修改图片尺寸（jpg、png…）</h2><ol><li><code>sudo apt-get install imagemagick</code></li><li><code>convert example.png -resize 200×100 example.png //按照原有比例缩放</code></li><li><code>convert example.png -resize 200×100! example.png</code></li></ol><h2 id="查看网络地址情况"><a href="#查看网络地址情况" class="headerlink" title="查看网络地址情况"></a>查看网络地址情况</h2><p><code>route -n</code></p><h2 id="文件压缩、解压"><a href="#文件压缩、解压" class="headerlink" title="文件压缩、解压"></a>文件压缩、解压</h2><ol><li>zip文件：<br><code>zip -r   a.zip  /dir</code></li></ol><p>直接unzip解压</p><ol start="2"><li>tar.bz：<br>Linux下压缩比率较tgz大，即压缩后占用更小的空间，使得压缩包看起来更小。<br>但同时在压缩，解压的过程却是非常耗费CPU时间。</li></ol><ul><li><ul><li>打包压缩格式，举例：<br><code>tar -jcvf file.tar.bz2 dir #dir目录</code></li></ul></li><li><ul><li>解压，举例：<br><code>tar -jxvf file.tar.bz2</code><br><code>tar -jxvf file.tar.bz2 -C /temp</code></li></ul></li></ul><hr><h2 id="ls-命令"><a href="#ls-命令" class="headerlink" title="ls 命令"></a>ls 命令</h2><table><thead><tr><th align="center">Command</th><th align="center">Notes</th></tr></thead><tbody><tr><td align="center">ls -a</td><td align="center">列出文件下所有的文件，包括以“.“开头的隐藏文件（Linux下文件隐藏文件是以.开头的，如果存在..代表存在着父目录）。</td></tr><tr><td align="center">ls -l</td><td align="center">列出文件的详细信息，如创建者，创建时间，文件的读写权限列表等等。</td></tr><tr><td align="center">ls -F</td><td align="center">在每一个文件的末尾加上一个字符说明该文件的类型。”@”表示符号链接、”</td></tr><tr><td align="center">ls -s</td><td align="center">在每个文件的后面打印出文件的大小。  size(大小)</td></tr><tr><td align="center">ls -t</td><td align="center">按时间进行文件的排序  Time(时间)</td></tr><tr><td align="center">ls -A</td><td align="center">列出除了”.”和”..”以外的文件。</td></tr><tr><td align="center">ls -R</td><td align="center">将目录下所有的子目录的文件都列出来，相当于我们编程中的“递归”实现</td></tr><tr><td align="center">ls -L</td><td align="center">列出文件的链接名。Link（链接）</td></tr><tr><td align="center">ls -S</td><td align="center">以文件的大小进行排序</td></tr><tr><td align="center">ls -h</td><td align="center">显示文件大小</td></tr></tbody></table><h2 id="firefox修改中文"><a href="#firefox修改中文" class="headerlink" title="firefox修改中文"></a>firefox修改中文</h2><ol><li>打开浏览器，在地址栏中输入<code>about:config</code>，然后按下回车。</li><li>在列表中找到“general.useragent.locale”，然后双击，将内容改为”zh-CH”</li><li>重启之后就会默认为中文了（注：如果想改回英文就改为:  en-US )</li></ol><h2 id="Ubuntu系统log路径-var-log"><a href="#Ubuntu系统log路径-var-log" class="headerlink" title="Ubuntu系统log路径/var/log"></a>Ubuntu系统log路径<code>/var/log</code></h2><p>查看: <code>ls -tl</code></p><h2 id="hidl接口生成命令"><a href="#hidl接口生成命令" class="headerlink" title="hidl接口生成命令"></a>hidl接口生成命令</h2><p><code>hidl-gen</code>是Android架构HIDL编译工具，可以手动将哈希加到<code>current.txt</code>中，也可以使用以下命令添加：<br><code>hidl-gen -L hash -r .../interfaces -r android.hidl:...</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;更新adb&quot;&gt;&lt;a href=&quot;#更新adb&quot; class=&quot;headerlink&quot; title=&quot;更新adb&quot;&gt;&lt;/a&gt;更新adb&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;更新命令：   sudo apt-get install android-tools-adb&lt;/li&gt;
&lt;li&gt;查看当前adb指令的目录: which adb&lt;/li&gt;
&lt;li&gt;查看版本：adb version&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="android" scheme="http://wizzie.top/categories/android/"/>
    
    
      <category term="graphics" scheme="http://wizzie.top/tags/graphics/"/>
    
  </entry>
  
  <entry>
    <title>Android @hide接口注释</title>
    <link href="http://wizzie.top/2019/11/03/2019/191103_android_hideDoc/"/>
    <id>http://wizzie.top/2019/11/03/2019/191103_android_hideDoc/</id>
    <published>2019-11-03T04:32:00.000Z</published>
    <updated>2020-03-08T10:18:54.622Z</updated>
    
    <content type="html"><![CDATA[<h2 id="hide和-hide"><a href="#hide和-hide" class="headerlink" title="@hide和{@hide}"></a>@hide和{@hide}</h2><p>类或API是否开放是通过doc的注释｛＠hide｝来控制的</p><p>比如android.media.Metadata这个类就是android没有公开的类</p><p>因为在frameworks\base\media\libmedia\Metadata.java文件中，定义Metadata类之前有/<em>*｛＠hide｝</em>/doc注释，所以Metadata类被定义为了非公开类，即在android应用程序中无法直接访问的类</p><a id="more"></a><p><strong>google 给了两个选择：</strong></p><p>在你添加的API或者变量前面增加javadoc 注释＠hide，但是要注意并不是简单写个＠hide或者 /<em>@hide</em>/就可以了，这些都是错误的javadoc注释格式。标准的javadoc都是这样的 /** <em>/ 而且对于 format 变量应该加上 { }，所以我们应该这样写/*</em> {@hide} */</p><p>想要生成的javadoc里面出现这个方法或者变量，你必须输入:<code>make update-api</code>。但是如果修改的是google没有开放出来的类，比如RIL、PhoneFactory，就不会出现这个问题。</p><h2 id="访问被-hide的API（android-如何引用-hide（隐藏）的类，方法和常量）"><a href="#访问被-hide的API（android-如何引用-hide（隐藏）的类，方法和常量）" class="headerlink" title="访问被@hide的API（android 如何引用@hide（隐藏）的类，方法和常量）"></a>访问被@hide的API（android 如何引用@hide（隐藏）的类，方法和常量）</h2><h3 id="直接将-hide标记去掉，将重新编译了的android-jar包换掉"><a href="#直接将-hide标记去掉，将重新编译了的android-jar包换掉" class="headerlink" title="直接将@hide标记去掉，将重新编译了的android.jar包换掉"></a>直接将@hide标记去掉，将重新编译了的android.jar包换掉</h3><p>不过强烈的建议不要这样做，别人隐藏起来的类或者方法肯定是不安全的，如果你把@hide放出来可能引起一些程序不可预知的错误。</p><h3 id="利用反射机制使用-hide方法，这种方法在网上看到一篇不错的，简单易懂，要深入的自己再到网上搜"><a href="#利用反射机制使用-hide方法，这种方法在网上看到一篇不错的，简单易懂，要深入的自己再到网上搜" class="headerlink" title="利用反射机制使用@hide方法，这种方法在网上看到一篇不错的，简单易懂，要深入的自己再到网上搜"></a>利用反射机制使用@hide方法，这种方法在网上看到一篇不错的，简单易懂，要深入的自己再到网上搜</h3><h3 id="修改android-mk文件"><a href="#修改android-mk文件" class="headerlink" title="修改android.mk文件"></a>修改android.mk文件</h3><p>删除LOCAL_SDK_VERSION := current</p><h3 id="将LOCAL-SDK-VERSION-注释掉之后提到服务器编译出现了代码混淆错误。"><a href="#将LOCAL-SDK-VERSION-注释掉之后提到服务器编译出现了代码混淆错误。" class="headerlink" title="将LOCAL_SDK_VERSION 注释掉之后提到服务器编译出现了代码混淆错误。"></a>将LOCAL_SDK_VERSION 注释掉之后提到服务器编译出现了代码混淆错误。</h3><p>这个时候可以在android.mk文件中将LOCAL_PROGUARD_ENABLED := disabled加上。LOCAL_PROGUARD_ENABLED := disabled不使用代码混淆的工具进行代码混淆,如果不设置，默认使用LOCAL_PROGUARD_ENABLED := full.即将该工程代码全部混淆。</p><h2 id="Android-10的变化"><a href="#Android-10的变化" class="headerlink" title="Android 10的变化"></a>Android 10的变化</h2><p>在Android 10对非SDK接口进行了限制，因而<code>@hide</code>注释的方法被列入黑名单，外部不能访问。</p><p>但是可以通过<code>adb shell settings put global hidden_api_policy  1</code>命令打开权限访问。</p><p>通过<code>adb shell settings delete global hidden_api_policy</code>解除设置。（<a href="https://developer.android.google.cn/about/versions/10/non-sdk-q?hl=en）" target="_blank" rel="noopener">https://developer.android.google.cn/about/versions/10/non-sdk-q?hl=en）</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;hide和-hide&quot;&gt;&lt;a href=&quot;#hide和-hide&quot; class=&quot;headerlink&quot; title=&quot;@hide和{@hide}&quot;&gt;&lt;/a&gt;@hide和{@hide}&lt;/h2&gt;&lt;p&gt;类或API是否开放是通过doc的注释｛＠hide｝来控制的&lt;/p&gt;
&lt;p&gt;比如android.media.Metadata这个类就是android没有公开的类&lt;/p&gt;
&lt;p&gt;因为在frameworks\base\media\libmedia\Metadata.java文件中，定义Metadata类之前有/&lt;em&gt;*｛＠hide｝&lt;/em&gt;/doc注释，所以Metadata类被定义为了非公开类，即在android应用程序中无法直接访问的类&lt;/p&gt;
    
    </summary>
    
    
      <category term="android" scheme="http://wizzie.top/categories/android/"/>
    
    
      <category term="android" scheme="http://wizzie.top/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>Android Shell脚本应用</title>
    <link href="http://wizzie.top/2019/10/23/2019/191023_android_shell/"/>
    <id>http://wizzie.top/2019/10/23/2019/191023_android_shell/</id>
    <published>2019-10-23T15:52:00.000Z</published>
    <updated>2020-03-08T10:17:25.211Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本结构-sh（系统中文-ch-sh）"><a href="#基本结构-sh（系统中文-ch-sh）" class="headerlink" title="基本结构.sh（系统中文.ch.sh）"></a>基本结构.sh（系统中文.ch.sh）</h2><p><code>#!/bin/bash</code> 脚本开头</p><p><code>#!/bin/csh</code> 是 C shell 的命令解</p><a id="more"></a><h2 id="export"><a href="#export" class="headerlink" title="export"></a>export</h2><blockquote><p>功能说明：设置或显示环境变量。<br>语　　法：export [-fnp][变量名称]=[变量设置值]<br>补充说明：在 shell 中执行程序时，shell 会提供一组环境变量。export 可新增，修改或删除环境变量，供后续执行的程序使用。export 的效力仅限于该次登陆操作。</p></blockquote><ol><li>用户登录到Linux系统后，系统将启动一个用户shell。在这个shell中，可以使用shell命令或声明变量，也可以创建并运行 shell 脚本程序。</li><li>运行shell脚本程序时，系统将创建一个子shell。此时，系统中将有两个shell，一个是登录时系统启动的 shell，另一个是系统为运行脚本程序创建的shell。</li><li>当一个脚本程序运行完毕，脚本shell将终止，返回到执行该脚本之前的shell。从这种意义上来说，用户可以有许多shell，每个shell都是由某个 shell（称为父 shell）派生的。</li><li>在子shell中定义的变量只在该子shell内有效。</li><li>如果在一个shell脚本程序中定义了一个变量，当该脚本程序运行时，这个定义的变量只是该脚本程序内的一个局部变量，其他的 shell 不能引用它，要使某个变量的值可以在其他 shell 中被改变，可以使用 export 命令对已定义的变量进行输出。</li><li>export命令将使系统在创建每一个新的shell时，定义这个变量的一个拷贝。这个过程称之为变量输出。</li></ol><h2 id="用语句给变量赋值，如将-etc下目录的文件名循环出来"><a href="#用语句给变量赋值，如将-etc下目录的文件名循环出来" class="headerlink" title="用语句给变量赋值，如将/etc下目录的文件名循环出来"></a>用语句给变量赋值，如将<code>/etc</code>下目录的文件名循环出来</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for file in `ls /etc`</span><br><span class="line">或</span><br><span class="line">for file in $(ls /et)</span><br></pre></td></tr></table></figure><p>使用<code>$</code>符号来取一个变量的值，常见的就是<code>$VAR</code></p><p>变量定义：<code>app_name=”test”</code></p><h2 id="、-0、-1、-2"><a href="#、-0、-1、-2" class="headerlink" title="$、$0、$1、$2.."></a><code>$、$0、$1、$2..</code></h2><p><code>$0</code>就是你写的shell脚本本身的名字，<code>$1</code>是你给你写的shell脚本传的第一个参数，<code>$2</code>是你给你写的shell脚本传的第二个参数。</p><h2 id="ps-ef-grep-surfaceFlinger-awk-‘-print-2-’的含义"><a href="#ps-ef-grep-surfaceFlinger-awk-‘-print-2-’的含义" class="headerlink" title="ps -ef |grep surfaceFlinger |awk ‘{print $2}’的含义"></a><code>ps -ef |grep surfaceFlinger |awk ‘{print $2}’</code>的含义</h2><ul><li><code>$2</code>：表示第二个字段</li><li><code>print $2</code>：打印第二个字段</li><li><code>-e</code>: 显示所有进程。</li><li><code>-f</code>:全格式</li><li><code>awk &#39;{print $2}&#39; $fileName</code>: 一行一行的读取指定的文件， 以空格作为分隔符，打印每行的第二个字段（即 pid）。</li><li><code>ps</code>: 打印的信息：</li><li>字段含义如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UID PID PPID C STIME TTY TIME CMD</span><br><span class="line">zzw 14124 13991 0 00:38 pts&#x2F;0 00:00:00 grep --color&#x3D;auto dae</span><br></pre></td></tr></table></figure></li></ul><h2 id="两种方式声明函数"><a href="#两种方式声明函数" class="headerlink" title="两种方式声明函数"></a>两种方式声明函数</h2><ol><li>”function”不可以省略(建议)<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function find &#123; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>不得添加参数<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">find() &#123; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>两种声明方式效果等价。<br><strong>注意：</strong><br>（1）函数名和”{“之间必须有空格；<br>（2）不得声明形式参数；<br>（3）必须在调用前声明；<br>（4）无法重载；<br>（5）后来的声明会覆盖之前的声明</p><h2 id="while-语句"><a href="#while-语句" class="headerlink" title="while 语句"></a>while 语句</h2><p><code>while</code>循环用于不断执行一系列命令，也用于从输入文件中读取数据；命令通常为测试条件。其格式为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while condition</span><br><span class="line">do</span><br><span class="line">    command</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>以下是一个基本的while循环，测试条件是：如果int小于等于5，那么条件返回真。int从0开始，每次循环处理时，<code>int</code>加1运行上述脚本，返回数字1到5，然后终止。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">int=1</span><br><span class="line">while(( $int&lt;=5 ))</span><br><span class="line">do</span><br><span class="line">    echo $int</span><br><span class="line">    let "int++"</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h2 id="android-serial-adb-shell-getprop-“re-serialno”-获取设备序列号"><a href="#android-serial-adb-shell-getprop-“re-serialno”-获取设备序列号" class="headerlink" title="$android_serial=$(adb shell getprop “re.serialno”)获取设备序列号"></a><code>$android_serial=$(adb shell getprop “re.serialno”)</code>获取设备序列号</h2><h2 id="adb-shell-input-swipe-359-1600-359-340-500"><a href="#adb-shell-input-swipe-359-1600-359-340-500" class="headerlink" title="adb shell input swipe 359 1600 359 340 500"></a><code>adb shell input swipe 359 1600 359 340 500</code></h2><p><code>input</code>后可以跟很多参数，text相当于输入内容，keyevent相当于手机物理或是屏幕按键，tap相当于touch事件，<code>swipe</code>相当于滑动。<br><code>input/swipe</code>模拟的是滑动事件，<code>input swipe &lt;x1&gt; &lt;y1&gt; &lt;x2&gt; &lt;y2&gt; [duration(ms)] (Default: touchscreen)</code>，需要将起始的坐标传进去。</p><ul><li>向左滑动：<br><code>shell@lentk6735_66t_l1:/ $ input swipe 600 800 300 800</code></li><li>向右滑动：<br><code>shell@lentk6735_66t_l1:/ $ input swipe 300 800 600 800</code></li><li>滑动：<br><code>adb shell input swipe 100 100 200 200 300 //从 100 100 经历 300 毫秒滑动到 200 200</code></li><li>长按：<br><code>adb shell input swipe 100 100 100 100 1000 //在 100 100 位置长按 1000 毫秒</code></li></ul><h2 id="if-ps-ef-grep-c-quot-ssh-quot-gt-1-then-echo-quot-true-quot-fi（适合中断，写成一行）"><a href="#if-ps-ef-grep-c-quot-ssh-quot-gt-1-then-echo-quot-true-quot-fi（适合中断，写成一行）" class="headerlink" title="if [ $(ps -ef | grep -c &quot;ssh&quot;) -gt 1 ]; then echo &quot;true&quot;; fi（适合中断，写成一行）"></a><code>if [ $(ps -ef | grep -c &quot;ssh&quot;) -gt 1 ]; then echo &quot;true&quot;; fi（适合中断，写成一行）</code></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if condition</span><br><span class="line">then</span><br><span class="line"> command1 </span><br><span class="line"> command2</span><br><span class="line"> ...</span><br><span class="line"> commandN</span><br><span class="line">else</span><br><span class="line"> command</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><ul><li><code>-eq</code>:等于</li><li><code>-ne</code>:不等于</li><li><code>-le</code>:小于等于</li><li><code>-ge</code>:大于等于</li><li><code>-lt</code>:小于</li><li><code>-gt</code>：大于</li><li><code>-a</code>: 双方都成立（and） 逻辑表达式 –a 逻辑表达式</li><li><code>-o</code>: 单方成立（or） 逻辑表达式 –o 逻辑表达式</li></ul><h2 id="sed-i-‘s-15-g’-tmp-txt"><a href="#sed-i-‘s-15-g’-tmp-txt" class="headerlink" title="sed -i ‘s/^.\{15\}//g’ tmp.txt"></a><code>sed -i ‘s/^.\{15\}//g’ tmp.txt</code></h2><p><code>adb shell wm size &gt; tmp.txt</code> //分辨率导出文件</p><p><code>sed -i ‘s/^.\{15\}//g’ tmp.txt</code> //此处 <code>\{</code>是转义成 `{</p><p><code>wm_size=$(cat tmp.txt)</code></p><h3 id="sed-i就是直接对文本文件进行操作"><a href="#sed-i就是直接对文本文件进行操作" class="headerlink" title="sed -i就是直接对文本文件进行操作"></a><code>sed -i</code>就是直接对文本文件进行操作</h3><p><code>sed -i &#39;s/原字符串/新字符串/&#39; /home/1.txt</code></p><p><code>sed -i &#39;s/原字符串/新字符串/g&#39; /home/1.txt</code></p><h3 id="正则"><a href="#正则" class="headerlink" title="正则"></a>正则</h3><ul><li><code>^</code>: 匹配输入字符串的开始位置。如果设置了<code>RegExp</code>对象的<code>Multiline</code>属性，<code>^</code>也匹配<code>\n</code>或<code>\r</code>之后的位置。</li><li><code>.</code>: 匹配除“\n”之外的任何单个字符。要匹配包括“\n”在内的任何字符，请使用像“(.|\n)”的模式。</li><li><code>\</code>: 将下一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符。例如，<code>n</code>匹配字符<code>n</code>。<code>\n</code>匹配一个换行符。串行<code>\\</code>匹配<code>\</code>而<code>\(</code>则匹配<code>(</code>。</li><li><code>{n}</code>:n是一个非负整数。匹配确定的n次。例如，<code>o{2}</code>不能匹配<code>Bob</code>中的<code>o</code>，但是能匹配<code>food</code>中的两个<code>o</code>。</li></ul><h3 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h3><ul><li><code>-n</code>：只打印模式匹配的行</li><li><code>-e</code>：直接在命令行模式上进行 sed 动作编辑，此为默认选项</li><li><code>-f</code>：将 sed 的动作写在一个文件内，用–f filename 执行 filename 内的 sed 动作</li><li><code>-r</code>：支持扩展表达式（配合正则表达式）</li><li><code>-i</code>：直接修改文件内容</li></ul><p>例如：</p><ul><li>删除该行的第一个字符：<code>sed -r &#39;s/^.//g&#39; &lt;&lt;&lt; $line</code></li><li>删除文件每行的第二个字符: <code>sed -r &#39;s/^(.)(.)/\2/g&#39; passwd</code></li><li>删除文件每行的倒数第二个字符: <code>sed -r &#39;s/(.)(.)$/\2/g&#39; passwd</code></li><li>交换每行的第一个字符和第二个字符:<code>sed -r &#39;s/^(.)(.)/\2\1/g&#39; passwd</code></li><li>交换每行的第一个单词和最后一个单词:<code>sed -r &#39;s/^([a-Z0-9]+)([^a-Z0-9]+)(.+)([^a-Z0-9]+)([a-Z0-9]+)/\5\2\3\4\1/g&#39; passwd</code></li></ul><h2 id="多选择语句case"><a href="#多选择语句case" class="headerlink" title="多选择语句case"></a>多选择语句<code>case</code></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">echo '你输入的数字为:'</span><br><span class="line">read aNum</span><br><span class="line">case $aNum in</span><br><span class="line">    1) echo '你选择了 1'</span><br><span class="line">    ;;</span><br><span class="line">    2) echo '你选择了 2'</span><br><span class="line">    ;;</span><br><span class="line">    3) echo '你选择了 3'</span><br><span class="line">    ;;</span><br><span class="line">    4) echo '你选择了 4'</span><br><span class="line">    ;;</span><br><span class="line">    *) echo '你没有输入 1 到 4 之间的数字'</span><br><span class="line">    ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure><h2 id="adb-shell-pidof-”mediaserver“"><a href="#adb-shell-pidof-”mediaserver“" class="headerlink" title="adb shell pidof ”mediaserver“"></a><code>adb shell pidof ”mediaserver“</code></h2><p>按名称检查正在运行的进程，可以使用<code>pidof</code>命令：<code>adb shell pidof com.android.phone</code></p><p>如果找到此类进程，则返回<code>PID</code>,否则返回空字符串。</p><h2 id="adb-shell-am-start-n"><a href="#adb-shell-am-start-n" class="headerlink" title="adb shell am start -n"></a><code>adb shell am start -n</code></h2><p><code>adb shell am start -n com.android.camera...</code> //使用组件名方式启动照相机功能</p><p>可以使用<code>adb shell activity|grep ACTIVITY</code> 或者<code>dump SF</code>获取Activity名称</p><h2 id="adb-shell-input-tap-x-y"><a href="#adb-shell-input-tap-x-y" class="headerlink" title="adb shell input tap x y"></a><code>adb shell input tap x y</code></h2><p>模拟点击事件（点击屏幕），可以用来进入清除任务。</p><h2 id="adb-shell-dumpsys-window-windows-grep-Current-tee-tmp-txt"><a href="#adb-shell-dumpsys-window-windows-grep-Current-tee-tmp-txt" class="headerlink" title="adb shell dumpsys window windows |grep Current |tee tmp.txt"></a><code>adb shell dumpsys window windows |grep Current |tee tmp.txt</code></h2><p><strong>实现功能：</strong></p><ul><li><p>获得当前活动窗口的信息，包名以及活动窗体。</p></li><li><p>过滤<code>Current</code>信息，获得<code>window</code>的<code>dump</code>信息。</p></li><li><p><code>|tee</code>的作用：输出到控制台</p></li></ul><hr><h2 id="date-Y-m-d-H-M-S输出日期"><a href="#date-Y-m-d-H-M-S输出日期" class="headerlink" title="date + %Y%m%d_%H%M%S输出日期"></a><code>date + %Y%m%d_%H%M%S</code>输出日期</h2><p>输入格式：20181128_174323</p><h2 id="date-N-cut-c-3"><a href="#date-N-cut-c-3" class="headerlink" title="date + %N | cut -c -3"></a><code>date + %N | cut -c -3</code></h2><p><code>%N</code>: 纳秒</p><p><code>cut</code>： 从指定的范围中提取字节（-b）、或字符（-c）、或字段（-f）</p><ul><li><code>cut -b -3</code>//-3 表示从第一个字节到第三个字节</li><li><code>cut -b 3-</code>//3-表示从第三个字节到行尾</li><li><code>cut -b -3,3-</code> //输出整行，不会出现连续两个重叠的</li></ul><h2 id="cat-systrace-html-grep-postComp-wc-l"><a href="#cat-systrace-html-grep-postComp-wc-l" class="headerlink" title="cat **systrace.html |grep postComp |wc -l"></a><code>cat **systrace.html |grep postComp |wc -l</code></h2><p> <code>（linux 命令）WC</code>：<code>wc - print newline, word, and byte counts for each file</code></p><p>参数及含义：</p><ul><li><code>-c</code>: print the byte counts 统计字节数</li><li><code>-l</code>: print the newline counts：统计行数</li><li><code>-m</code>: print the character counts：将每个文件的字符数及文件名输出到屏幕上，如果当前系统不支持多字节字符其将显示与-c 参数相同的结果</li><li><code>-w</code>: print the word counts：统计字数</li></ul><h2 id="（视频播放时）旋转屏幕"><a href="#（视频播放时）旋转屏幕" class="headerlink" title="（视频播放时）旋转屏幕"></a>（视频播放时）旋转屏幕</h2><p><code>adb shell settings put system user_rotation 1</code>  //获取参数是get</p><h2 id="shell判断数组中是否包含某个元素"><a href="#shell判断数组中是否包含某个元素" class="headerlink" title="shell判断数组中是否包含某个元素"></a>shell判断数组中是否包含某个元素</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ary=(1 2 3)</span><br><span class="line">a=2</span><br><span class="line">if [[ "$&#123;ary[@]&#125;" =~ "$a" ]] ; then</span><br><span class="line"> echo "a in ary"</span><br><span class="line">else</span><br><span class="line"> echo "a not in ary"</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h2 id="解决播放结束后，判断当前activity然后重新播放"><a href="#解决播放结束后，判断当前activity然后重新播放" class="headerlink" title="解决播放结束后，判断当前activity然后重新播放"></a>解决播放结束后，判断当前activity然后重新播放</h2><ul><li><code>adb shell dumpsys activity top | grep &quot;ACTIVITY&quot;</code> //获得当前的 activity</li><li><code>adb shell am start -n com.home...</code> //返回桌面 activity</li></ul><h2 id="包含关系"><a href="#包含关系" class="headerlink" title="包含关系"></a>包含关系</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">testPlay=$(adb shell dumpsys activity top | grep "ACTIVITY")testPlaySuccess="com...Activity"</span><br><span class="line">                if [[ $testPlay =~ $testPlaySuccess ]];then</span><br><span class="line">                        echo "包含"</span><br><span class="line">                else</span><br><span class="line">                        echo "不包含"</span><br><span class="line">                fi</span><br></pre></td></tr></table></figure><h2 id="查找手机文件"><a href="#查找手机文件" class="headerlink" title="查找手机文件"></a>查找手机文件</h2><p><code>adb shell find /storage -name &quot;*.mp4&quot; | grep FileName</code></p><h2 id="播放视频"><a href="#播放视频" class="headerlink" title="播放视频"></a>播放视频</h2><p><code>adb shell am start -a android.intent.action.VIEW -d &quot;file:///storage/...../Test.mp4&quot; -t &quot;video/&quot;</code></p><h2 id="逐行读某个文件"><a href="#逐行读某个文件" class="headerlink" title="逐行读某个文件"></a>逐行读某个文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while read line</span><br><span class="line">do</span><br><span class="line">…</span><br><span class="line">done &lt; file // `&lt;`是读，`&gt;`是写入，`&gt;&gt;`是写入到某个文件的末尾</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;基本结构-sh（系统中文-ch-sh）&quot;&gt;&lt;a href=&quot;#基本结构-sh（系统中文-ch-sh）&quot; class=&quot;headerlink&quot; title=&quot;基本结构.sh（系统中文.ch.sh）&quot;&gt;&lt;/a&gt;基本结构.sh（系统中文.ch.sh）&lt;/h2&gt;&lt;p&gt;&lt;code&gt;#!/bin/bash&lt;/code&gt; 脚本开头&lt;/p&gt;
&lt;p&gt;&lt;code&gt;#!/bin/csh&lt;/code&gt; 是 C shell 的命令解&lt;/p&gt;
    
    </summary>
    
    
      <category term="android" scheme="http://wizzie.top/categories/android/"/>
    
    
      <category term="shell" scheme="http://wizzie.top/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>Android色彩空间（ColorSpace）</title>
    <link href="http://wizzie.top/2019/10/21/2019/191021_android_basis/"/>
    <id>http://wizzie.top/2019/10/21/2019/191021_android_basis/</id>
    <published>2019-10-21T15:52:00.000Z</published>
    <updated>2020-03-14T17:24:45.821Z</updated>
    
    <content type="html"><![CDATA[<h1 id="色彩空间Color-Space"><a href="#色彩空间Color-Space" class="headerlink" title="色彩空间Color Space"></a>色彩空间<code>Color Space</code></h1><h2 id="广色域WCG"><a href="#广色域WCG" class="headerlink" title="广色域WCG"></a>广色域<code>WCG</code></h2><p>WCG（Wide Color Gamut），是Adobe System开发的一种RGB色彩空间，使用纯光谱原色提供较大的色域。与Adove RGB和sRGB相比，能够存储更大范围的颜色值。<strong>相比之下，WCG包含<code>CIELAB色彩空间</code>可见颜色的77.6%，而Adobe RGB色彩空间仅覆盖52.1%，sRGB仅覆盖35.9%。</strong></p><a id="more"></a><p><img src="WCG_ColorSpace.png" alt="WCG色彩空间"></p><p><strong>Note：</strong><br><code>CIELAB色彩空间</code>（也称为CIE L<em>a</em>b，抑或Lab色彩空间），是国际照明委员会（CIE）于1976年定义的色彩空间。它将色彩表示为三个值：</p><table><thead><tr><th align="center">符号</th><th align="center">释义</th></tr></thead><tbody><tr><td align="center"><code>L*</code></td><td align="center">为从黑色（0）到白色（100）的亮度</td></tr><tr><td align="center"><code>a*</code></td><td align="center">为从绿色（-）到红色（+）的亮度</td></tr><tr><td align="center"><code>b*</code></td><td align="center">为从蓝色（-）到黄色（+）的亮度</td></tr></tbody></table><p>CIELAB被设计为从这些值中相同数量的数字变化对应于大致相同数量的视觉感知变化。</p><hr><h2 id="sRGB色彩空间"><a href="#sRGB色彩空间" class="headerlink" title="sRGB色彩空间"></a>sRGB色彩空间</h2><p>sRG色彩空间是惠普和微软于1996年一起开发的用于显示器、打印机、因特网的一种标准RGB色彩空间。最初的目的是作为生成在因特网以及万维网上浏览的图像的通用色彩空间，最后选择的是使用<code>Gamma校准</code>（伽马）系数为2.2的色彩空间，即CRT显示器在这种情况下的平均线性电压响应。</p><p>sRGB定义了红色、绿色、蓝色三原色的颜色（又称三基色，用于电视机、投影仪等显示设备，对应RGB），即在其他两种颜色值都为零时该颜色的最大值。在<code>CIE xy</code>（Lab色彩空间）坐标系中坐标如下表。对于任何RGB色彩空间来说，非负的R、G、B都不可能表示超出原色定义的三角形即色域范围，它刚好在人眼的色彩感知范围之内。</p><table><thead><tr><th align="center">颜色</th><th align="center">X</th><th align="center">Y</th></tr></thead><tbody><tr><td align="center">红色</td><td align="center">0.6400</td><td align="center">0.3300</td></tr><tr><td align="center">绿色</td><td align="center">0.3000</td><td align="center">0.6000</td></tr><tr><td align="center">蓝色</td><td align="center">0.1500</td><td align="center">0.0600</td></tr><tr><td align="center">白色（D65）</td><td align="center">0.3127</td><td align="center">0.3290</td></tr></tbody></table><p>sRGB定义了原色强度与实际保存的数值之间的非线性变化，曲线类似于CRT显示器的伽马响应。这个非线性变化意味着sRGB非常搞笑的使图像文件中的整数值标识了人眼可以分辨的颜色。</p><p>但是由于它的色域不够大，尤其是蓝绿颜色色域无法表示SMYK印刷中的所有颜色。所以印刷行业的经常使用的是Adobe RGB色彩空间。</p><p><img src="sRGB_ColorSpace.png" alt="sRGB色彩空间"></p><p><strong>Note:</strong><br>伽马校正（伽马非线性变化、伽马编码），是用来正对影片或者影像系统里对于管线的辉度或者三色刺激值所进行非线性的运算或反运算。</p><hr><h2 id="Adobe-RGB色彩空间"><a href="#Adobe-RGB色彩空间" class="headerlink" title="Adobe RGB色彩空间"></a>Adobe RGB色彩空间</h2><p>Adobe RGB色彩空间是一种由Adobe System于1998年开发的色彩空间。开发的目的是为了尽可能在<code>CMYK彩色印刷</code>中利用计算机显示器等设备的RGB颜色模式上囊括的更多的颜色。</p><p>在Adobe RGB标准中，色彩被指定为<code>（R,G,B）</code>三个组员，其中R，G，B每个的值介于0和1之间。但在显示器显示出来时，白色点(1,1,1)，黑色点（0,0,0），原色点（1,0,0）的准确值会被指定。</p><p>与sRGB相比，Adobe RGB中的RGB色彩分量和亮度并不是呈线性关系，他的伽马值是<code>563/256结果是2.19921875</code>。并且三原色点坐标只有绿色坐标不同。</p><table><thead><tr><th align="center">颜色</th><th align="center">X</th><th align="center">Y</th></tr></thead><tbody><tr><td align="center">红色</td><td align="center">0.6400</td><td align="center">0.3300</td></tr><tr><td align="center">绿色</td><td align="center">0.2100</td><td align="center">0.7100</td></tr><tr><td align="center">蓝色</td><td align="center">0.1500</td><td align="center">0.0600</td></tr><tr><td align="center">白色（D65）</td><td align="center">0.3127</td><td align="center">0.3290</td></tr></tbody></table><p><img src="AdobeRGB_ColorSpace.png" alt="Adobe RGB色彩空间"></p><hr><h2 id="ProPhoto-RGB色彩空间"><a href="#ProPhoto-RGB色彩空间" class="headerlink" title="ProPhoto RGB色彩空间"></a>ProPhoto RGB色彩空间</h2><p>ProPhoto RGB色彩空间（抑或ROMM RGB色彩空间），专为摄影输出所开发设计。该色彩空间的色域十分宽裕，甚至包含<code>CIE Lab色彩空间</code>中90%以上的表面色彩和1980年Poniter所记录的可能出现的表面色彩。<strong>该色域的表现范围甚至比WCG色彩空间还要大</strong></p><p>标准参考白点由<code>CIE标准光源D50</code>的色度决定。</p><table><thead><tr><th align="center">颜色</th><th align="center">X</th><th align="center">Y</th></tr></thead><tbody><tr><td align="center">红色</td><td align="center">0.7347</td><td align="center">0.2653</td></tr><tr><td align="center">绿色</td><td align="center">0.1596</td><td align="center">0.8404</td></tr><tr><td align="center">蓝色</td><td align="center">0.0366</td><td align="center">0.0001</td></tr><tr><td align="center">白色（D50）</td><td align="center">0.3457</td><td align="center">0.3585</td></tr></tbody></table><p><img src="ProPhotoRGB_ColorSpace.png" alt="ProPhoto RGB色彩空间"></p><p>缺点是该色彩空间包含大约13%的通常不存在色彩。</p><hr><h2 id="DCI-P3色彩空间"><a href="#DCI-P3色彩空间" class="headerlink" title="DCI-P3色彩空间"></a>DCI-P3色彩空间</h2><p>DCI-P3（抑或DCI/P3）是美国电影行业推出的一种色彩空间。在CIE 1931xy色彩空间中，覆盖了45.5%的全色于和86.9%的常见色域。在CIE 1976uv色度图覆盖率分别是41.7%和85.5%。</p><p>DCI-P3将来应该会在电视系统和家庭影院领域有更广泛的应用。</p><table><thead><tr><th align="center">颜色</th><th align="center">X</th><th align="center">Y</th></tr></thead><tbody><tr><td align="center">红色</td><td align="center">0.6800</td><td align="center">0.3200</td></tr><tr><td align="center">绿色</td><td align="center">0.2650</td><td align="center">0.6900</td></tr><tr><td align="center">蓝色</td><td align="center">0.1500</td><td align="center">0.0600</td></tr><tr><td align="center">白色（D65）</td><td align="center">0.3127</td><td align="center">0.3290</td></tr></tbody></table><p><img src="DCIP3_ColorSpace.png" alt="DCI-P3色彩空间"></p><hr><h2 id="Display-P3色彩空间"><a href="#Display-P3色彩空间" class="headerlink" title="Display P3色彩空间"></a>Display P3色彩空间</h2><p>Display P3使用DCI-P3的原色，但是使用D65白点，这在计算机显示色彩空间中（sRGB,AdobeRGB都使用D65）更为常见。和DCI-P3的纯伽马曲线不同。Display-P3使用sRGB曲线。</p><hr><h1 id="Android中启用-禁止WCG功能"><a href="#Android中启用-禁止WCG功能" class="headerlink" title="Android中启用/禁止WCG功能"></a>Android中启用/禁止WCG功能</h1><h2 id="APP获取设备是否支持WCG"><a href="#APP获取设备是否支持WCG" class="headerlink" title="APP获取设备是否支持WCG"></a>APP获取设备是否支持WCG</h2><p>APP通过以下两种API来决定设备是否支持WCG：</p><ol><li><code>android.content.res.Configuration::isScreenWideColorGamut</code>：如果display和设备能够支持WCG则返回true。</li><li><code>android.view.Display::isWideColorGamut()</code>：返回显示display设备是否可用于WCG显示。这个并不意味着设备自己可以渲染WCG内容。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;色彩空间Color-Space&quot;&gt;&lt;a href=&quot;#色彩空间Color-Space&quot; class=&quot;headerlink&quot; title=&quot;色彩空间Color Space&quot;&gt;&lt;/a&gt;色彩空间&lt;code&gt;Color Space&lt;/code&gt;&lt;/h1&gt;&lt;h2 id=&quot;广色域WCG&quot;&gt;&lt;a href=&quot;#广色域WCG&quot; class=&quot;headerlink&quot; title=&quot;广色域WCG&quot;&gt;&lt;/a&gt;广色域&lt;code&gt;WCG&lt;/code&gt;&lt;/h2&gt;&lt;p&gt;WCG（Wide Color Gamut），是Adobe System开发的一种RGB色彩空间，使用纯光谱原色提供较大的色域。与Adove RGB和sRGB相比，能够存储更大范围的颜色值。&lt;strong&gt;相比之下，WCG包含&lt;code&gt;CIELAB色彩空间&lt;/code&gt;可见颜色的77.6%，而Adobe RGB色彩空间仅覆盖52.1%，sRGB仅覆盖35.9%。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="android" scheme="http://wizzie.top/categories/android/"/>
    
    
      <category term="android" scheme="http://wizzie.top/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>C++ 单例模式</title>
    <link href="http://wizzie.top/2019/10/20/2019/191020_cpp_singletonMode/"/>
    <id>http://wizzie.top/2019/10/20/2019/191020_cpp_singletonMode/</id>
    <published>2019-10-20T15:39:00.000Z</published>
    <updated>2020-03-08T10:17:25.211Z</updated>
    
    <content type="html"><![CDATA[<h2 id="懒汉式单例模式"><a href="#懒汉式单例模式" class="headerlink" title="懒汉式单例模式"></a>懒汉式单例模式</h2><blockquote><p>缺点是延迟加载，比如配置文件，只有在使用的时候才会加载。</p></blockquote><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CSingleton</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> CSingleton <span class="title">GetInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m_pInstance == <span class="literal">NULL</span>)</span><br><span class="line">            m_pInstance = <span class="keyword">new</span> CSingleton();</span><br><span class="line">        reutrn m_pInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    CSingleton() &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> CSingleton * m_pInstace;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多线程下的懒汉模式"><a href="#多线程下的懒汉模式" class="headerlink" title="多线程下的懒汉模式"></a>多线程下的懒汉模式</h3><blockquote><p>使用double-check来保证线程安全。但是如果处理大量数据时，该锁才成为严重的性能瓶颈。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">    <span class="keyword">static</span> Singleton* m_instance;  </span><br><span class="line">    Singleton()&#123;&#125;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="function">Singleton* <span class="title">Singleton::getInstance</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == m_instance)  </span><br><span class="line">    &#123;  </span><br><span class="line">        Lock(); <span class="comment">//借用其它类来实现，如boost  </span></span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">NULL</span> == m_instance)  </span><br><span class="line">        &#123;  </span><br><span class="line">            m_instance = <span class="keyword">new</span> Singleton;  </span><br><span class="line">        &#125;  </span><br><span class="line">        UnLock();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> m_instance;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="饿汉式单例模式"><a href="#饿汉式单例模式" class="headerlink" title="饿汉式单例模式"></a>饿汉式单例模式</h2><blockquote><p>一开始就创建实例对象并且加载，每次使用的时候直接返回就好了。<br>饿汉式会出现线程安全问题，在多线程下，或个线程都初始化一个单例，得到的指针并不是指向同一个地方，就不满足单例类的定义，此时就需要进行修改。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CSingletonB</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    CSingletonB () &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> CSingletonB * <span class="title">GetInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> CSingleton instance;</span><br><span class="line">        <span class="keyword">return</span> &amp;instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;懒汉式单例模式&quot;&gt;&lt;a href=&quot;#懒汉式单例模式&quot; class=&quot;headerlink&quot; title=&quot;懒汉式单例模式&quot;&gt;&lt;/a&gt;懒汉式单例模式&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;缺点是延迟加载，比如配置文件，只有在使用的时候才会加载。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="cpp" scheme="http://wizzie.top/categories/cpp/"/>
    
    
      <category term="cpp" scheme="http://wizzie.top/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>Java 单例模式</title>
    <link href="http://wizzie.top/2019/10/20/2019/191020_java_singletonMode/"/>
    <id>http://wizzie.top/2019/10/20/2019/191020_java_singletonMode/</id>
    <published>2019-10-20T14:59:00.000Z</published>
    <updated>2020-03-08T10:17:25.211Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>单例：保证一个类仅有一个实例，并提供一个访问它的全局访问点。<br>单例模式是一种常用的软件设计模式之一，其目的是保证整个应用中只存在类的唯一个实例。<br>比如我们在系统启动时，需要加载一些公共的配置信息，对整个应用程序的整个生命周期中都可见且唯一，这时需要设计成单例模式。如：spring容器，session工厂，缓存，数据库连接池等等。</p></blockquote><a id="more"></a><p><strong>保证实例的唯一:</strong></p><ol><li>防止外部初始化</li><li>由类本身进行实例化</li><li>保证实例化一次</li><li>对外提供获取实例的方法</li><li>线程安全</li></ol><h2 id="饿汉式单例模式"><a href="#饿汉式单例模式" class="headerlink" title="饿汉式单例模式"></a>饿汉式单例模式</h2><blockquote><p>线程安全，调用效率高，但是不能延时加载</p></blockquote><p>直接创建单例对象，使用的时候直接返回即可。缺点是单例在未使用的时候就已经初始化完成，如果程序一直没有使用，单例对象还是会创建，从而造成不必要的资源浪费。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestA</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> TestA t1 = <span class="keyword">new</span> TestA;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">TestA</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TestA <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="懒汉式单例模式"><a href="#懒汉式单例模式" class="headerlink" title="懒汉式单例模式"></a>懒汉式单例模式</h2><blockquote><p>线程安全，调用效率不高，但是可以延时加载</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestB</span> </span>&#123;</span><br><span class="line">    <span class="comment">//类初始化时，不初始化对象（延时加载，真正使用的时候再创建）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> TestB t2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器私有化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">TestB</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法同步，调用效率低</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> TestB <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (testB == <span class="keyword">null</span>) &#123;</span><br><span class="line">            TestB = <span class="keyword">new</span> TestB();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> testB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="双重锁判断机制（DCL）"><a href="#双重锁判断机制（DCL）" class="headerlink" title="双重锁判断机制（DCL）"></a>双重锁判断机制（DCL）</h2><p>即Double CheckLock实现单例模式（由于JVM底层模型原因，偶尔会出现问题，不建议使用）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestC</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> TestC t3;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">TestC</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TestC <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (TestC == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (TestC<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (TestC == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    TestC = <span class="keyword">new</span> TestC();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> t3;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态内部类实现单例模式"><a href="#静态内部类实现单例模式" class="headerlink" title="静态内部类实现单例模式"></a>静态内部类实现单例模式</h2><blockquote><p>线程安全，调用效率高，可以延迟加载</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestD</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">GetInfoClass</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> TestD t4 = <span class="keyword">new</span> TestD();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">TestD</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TestA <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> GetInfoClass.t4;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="枚举类实现单例模式"><a href="#枚举类实现单例模式" class="headerlink" title="枚举类实现单例模式"></a>枚举类实现单例模式</h2><blockquote><p>线程安全，调用效率高，不能延时加载，可以天然防止反射和反序列化调用）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestE</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//枚举元素本身就是单例</span></span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加自己需要的操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getInfoOperation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;单例：保证一个类仅有一个实例，并提供一个访问它的全局访问点。&lt;br&gt;单例模式是一种常用的软件设计模式之一，其目的是保证整个应用中只存在类的唯一个实例。&lt;br&gt;比如我们在系统启动时，需要加载一些公共的配置信息，对整个应用程序的整个生命周期中都可见且唯一，这时需要设计成单例模式。如：spring容器，session工厂，缓存，数据库连接池等等。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://wizzie.top/categories/java/"/>
    
    
      <category term="java" scheme="http://wizzie.top/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Android Property</title>
    <link href="http://wizzie.top/2019/10/16/2019/191016_adndroid_property_setTypes/"/>
    <id>http://wizzie.top/2019/10/16/2019/191016_adndroid_property_setTypes/</id>
    <published>2019-10-16T15:52:00.000Z</published>
    <updated>2020-03-08T10:17:25.211Z</updated>
    
    <content type="html"><![CDATA[<h2 id="property的相关生成文件和设置"><a href="#property的相关生成文件和设置" class="headerlink" title="property的相关生成文件和设置"></a>property的相关生成文件和设置</h2><blockquote><p>android通过SystemProperties的set和get方法来控制很多东西，一般上层添加一个控制开关可以使用这个方法，在系统里面存在很多个prop文件。它们分别是system/build.prop,system/etc/prop.default,vendor/build.prop,vendor/default.prop。下面分别来说下这几个文件的构成。</p></blockquote><a id="more"></a><ol><li>system/build.prop</li></ol><p>这个主要是由device\mediateksample\product/system.prop,还有在build目录下添加的ADDITIONAL_BUILD_PROPERTIES</p><ol start="2"><li>system/etc/prop.default</li></ol><p>主要是系统添加的PRODUCT_SYSTEM_DEFAULT_PROPERTIES</p><ol start="3"><li>vendor/build.prop（比较重要）</li></ol><p>主要是系统添加的PRODUCT_PROPERTY_OVERRIDES，添加在device.mk的这个属性会被编译到这里，但是在9.0的系统，加到这里会无效，获取不到值。</p><ol start="4"><li>vendor/default.prop（会被同目录的build.prop相同property覆盖）</li></ol><p>主要是系统添加的PRODUCT_DEFAULT_PROPERTY_OVERRIDES</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;property的相关生成文件和设置&quot;&gt;&lt;a href=&quot;#property的相关生成文件和设置&quot; class=&quot;headerlink&quot; title=&quot;property的相关生成文件和设置&quot;&gt;&lt;/a&gt;property的相关生成文件和设置&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;android通过SystemProperties的set和get方法来控制很多东西，一般上层添加一个控制开关可以使用这个方法，在系统里面存在很多个prop文件。它们分别是system/build.prop,system/etc/prop.default,vendor/build.prop,vendor/default.prop。下面分别来说下这几个文件的构成。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="android" scheme="http://wizzie.top/categories/android/"/>
    
    
      <category term="android" scheme="http://wizzie.top/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>Android Graphics 调试技巧（十月份更新）</title>
    <link href="http://wizzie.top/2019/10/12/2019/191012_android_debug1/"/>
    <id>http://wizzie.top/2019/10/12/2019/191012_android_debug1/</id>
    <published>2019-10-12T15:52:00.000Z</published>
    <updated>2020-03-08T10:17:34.591Z</updated>
    
    <content type="html"><![CDATA[<h2 id="readelf命令查看ELF格式的文件信息"><a href="#readelf命令查看ELF格式的文件信息" class="headerlink" title="readelf命令查看ELF格式的文件信息"></a>readelf命令查看ELF格式的文件信息</h2><p>常见的文件比如动态库(<code>*.so</code>)、静态库（<code>*.a</code>），常用命令：<code>readelf -a libgui.so | grep test_string</code></p><a id="more"></a><h2 id="查看手机内存"><a href="#查看手机内存" class="headerlink" title="查看手机内存"></a>查看手机内存</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">adb shell</span><br><span class="line">cat proc/meminfo</span><br><span class="line"></span><br><span class="line">MemTotal:        7821184 kB</span><br><span class="line">MemFree:          157484 kB</span><br><span class="line">MemAvailable:    2765976 kB</span><br><span class="line">Buffers:          175624 kB</span><br><span class="line">Cached:          2264796 kB</span><br><span class="line">......</span><br></pre></td></tr></table></figure><h2 id="adb-logcat缓存管理"><a href="#adb-logcat缓存管理" class="headerlink" title="adb logcat缓存管理"></a>adb logcat缓存管理</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">adb root;adb remount</span><br><span class="line"></span><br><span class="line">清除缓存  adb logcat -c</span><br><span class="line"></span><br><span class="line">如果不能清除，就指定区域清除  adb logcat -c main&#x2F;system&#x2F;event&#x2F;kernel&#x2F;all(日志缓冲区)</span><br><span class="line"></span><br><span class="line">查看缓存  adb logcat -g</span><br><span class="line">设置最大logcat缓存   adb logcat -G 100M</span><br></pre></td></tr></table></figure><h2 id="linux离线翻译工具sdcv"><a href="#linux离线翻译工具sdcv" class="headerlink" title="linux离线翻译工具sdcv"></a>linux离线翻译工具<code>sdcv</code></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">安装：</span><br><span class="line">sudo apt-get install sdcv</span><br><span class="line"></span><br><span class="line">使用：</span><br><span class="line">sdcv</span><br><span class="line"></span><br><span class="line">只能翻译单词</span><br></pre></td></tr></table></figure><h2 id="apt-get命令列出版本号"><a href="#apt-get命令列出版本号" class="headerlink" title="apt-get命令列出版本号"></a>apt-get命令列出版本号</h2><p><code>sudo apt-cache madison  openssh-client</code></p><h2 id="Linux安装tar-xz软件包"><a href="#Linux安装tar-xz软件包" class="headerlink" title="Linux安装tar.xz软件包"></a>Linux安装tar.xz软件包</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在linux下(node.js)：</span><br><span class="line">解压后将bin目录的命令全局，建立软链接：</span><br><span class="line">sudo ln -s &#x2F;node-v10.16.0-linux-x64&#x2F;bin&#x2F;node &#x2F;usr&#x2F;local&#x2F;bin&#x2F;node</span><br><span class="line">sudo ln -s &#x2F;node-v10.16.0-linux-x64&#x2F;bin&#x2F;npm &#x2F;usr&#x2F;local&#x2F;bin&#x2F;npm</span><br></pre></td></tr></table></figure><h2 id="JNI的jlong类型打印"><a href="#JNI的jlong类型打印" class="headerlink" title="JNI的jlong类型打印"></a>JNI的jlong类型打印</h2><p>不使用%lld和%ld，而是先将其转换成long，然后%ld打印。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALOGD(<span class="string">"Mylog: JNI destroySurface nativeObject=%ld"</span>, (<span class="keyword">long</span>)nativeObject);</span><br></pre></td></tr></table></figure><hr><h2 id="monkey测试"><a href="#monkey测试" class="headerlink" title="monkey测试"></a>monkey测试</h2><h3 id="指令参数"><a href="#指令参数" class="headerlink" title="指令参数"></a>指令参数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">adb shell monkey help查看帮助</span><br><span class="line"></span><br><span class="line">-p 指定包名</span><br><span class="line">-v log详细程度（最高支持-v -v -v）</span><br><span class="line">-s 种子（指定后，同一个命令在任意时间地点的执行顺序相同）</span><br><span class="line">--throttle 单步延时（每步操作间隔，单位ms），如果不知定系统会尽快的发送事件序列</span><br><span class="line">--kill-process-offer-error 出错是杀掉进程</span><br><span class="line">--ignore-timeouts 忽略超时错误(程序未响应)，不会应ANR而停止</span><br><span class="line">--ignore-security-exceptions 忽略证书或认证异常 </span><br><span class="line">--hprof 测试前后会生成app内存快照文件（一般在&#x2F;data&#x2F;misc目录下生成hprof文件，可以使用Android Studio查看）</span><br><span class="line">--ignore-crashes 忽略crash，不会因crash而停止</span><br><span class="line">--ignore-native-crashes 忽略native代码发生的crash崩溃，不会因此停止</span><br><span class="line">--monitor-native-crashes 监视native代码发生的崩溃</span><br></pre></td></tr></table></figure><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>(1) adb shell monkey -p PackageName -v -v -v -s 12 –throttle 500 1000 &gt; monkey.txt<br>随机数种子是12，log详细程度最高，单步延时500ms，总执行1000步，日志输出到monkey.txt</p><p>(2) adb shell monkey -p PackageName –throttle 200 –ignore-security-exceptions -v 100000000</p><p>(3) adb shell monkey -p PackageName –throttle 200 –ignore-crashes –ignore-timeouts –ignore-security-exceptions –ignore-native-crashes –monitor-native-crashes -v -v -v 1000000 &gt; monkeylog.txt</p><p>(4) 不指定包：<br>adb -s DeviceID shell monkey –throttle 200 –ignore-crashes –ignore-timeouts –ignore-security-exceptions –ignore-native-crashes –monitor-native-crashes –ignore-security-exceptions -v -v -v 100 &gt; monkeylog.txt</p><p>(5) 正常测试验证问题使用（不忽略crash,压力测试，所以不指定间隔时间）：<br>adb -s DeviceID shell monkey -p PackageName –throttle 200 –ignore-security-exceptions -v 100000000 &gt; monkeyLog.txt</p><h3 id="停止monkey测试"><a href="#停止monkey测试" class="headerlink" title="停止monkey测试"></a>停止monkey测试</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(1) ps -A|grep monkey</span><br><span class="line">(2) kill pid（11111）</span><br></pre></td></tr></table></figure><h3 id="重现monkey测出的bug"><a href="#重现monkey测出的bug" class="headerlink" title="重现monkey测出的bug"></a>重现monkey测出的bug</h3><p>monkey日志搜索<code>ANR exception</code>，将之前的事件重新操作。尤其是seed值要一样，如<code>monkey -p PackageName -v seed(-s) 100(seed的值) 500(随机时间次数)</code></p><hr><h2 id="dump-meminfo"><a href="#dump-meminfo" class="headerlink" title="dump meminfo"></a>dump meminfo</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">adb shell dumpsys meminfo</span><br><span class="line">或者具体包</span><br><span class="line">adb shell dumpsys meminfo packageName</span><br></pre></td></tr></table></figure><h2 id="kernel使用printk调试"><a href="#kernel使用printk调试" class="headerlink" title="kernel使用printk调试"></a>kernel使用printk调试</h2><ul><li>打印调试log</li></ul><p><code>printk(&quot;%d&quot;,intA);</code></p><ul><li>打印变量所占内存大小</li></ul><p><code>printk(&quot;sizeof(*intA)=%d&quot;,sizeof(*intA);</code></p><h2 id="查看设别是否支持Project-Teable"><a href="#查看设别是否支持Project-Teable" class="headerlink" title="查看设别是否支持Project Teable"></a>查看设别是否支持Project Teable</h2><p>Project Treble是在最新的Android上应用兼容的芯片驱动，加快最新系统适配的速度。</p><p><code>adb shell getprop ro.treble.enabled</code></p><h2 id="查看cpu架构"><a href="#查看cpu架构" class="headerlink" title="查看cpu架构"></a>查看cpu架构</h2><p><code>adb shell getprop ro.product.cpu.abi</code></p><h2 id="Service服务命令"><a href="#Service服务命令" class="headerlink" title="Service服务命令"></a>Service服务命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">服务列表：    adb shell service list</span><br><span class="line">检测某服务是否存在：   adb shell service check SurfaceFlinger</span><br></pre></td></tr></table></figure><h2 id="测试CtsMediaTestCases需要CTS媒体文件（连接外网）"><a href="#测试CtsMediaTestCases需要CTS媒体文件（连接外网）" class="headerlink" title="测试CtsMediaTestCases需要CTS媒体文件（连接外网）"></a>测试CtsMediaTestCases需要CTS媒体文件（连接外网）</h2><p>Google官网下载，例如CTS媒体文件1.4，解压后阅读README文件，按照提示copy文件到device。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">chmod 544 copy_media.sh</span><br><span class="line">.&#x2F;copy_media.sh</span><br><span class="line">chmod 544 copy_images.sh</span><br><span class="line">.&#x2F;copy_images.sh</span><br><span class="line"></span><br><span class="line">例如：run cts-dev --module CtsMediaTestCases --compatibility:module-arg CtsMediaTestCases:include-annotation:android.platform.test.annotations.RequiresDevice</span><br></pre></td></tr></table></figure><hr><h2 id="当前活动Activiy"><a href="#当前活动Activiy" class="headerlink" title="当前活动Activiy"></a>当前活动Activiy</h2><h3 id="获取当前ACTIVITY"><a href="#获取当前ACTIVITY" class="headerlink" title="获取当前ACTIVITY"></a>获取当前ACTIVITY</h3><p><code>adb shell dumpsys activity top|grep ACTIVITY</code></p><h3 id="命令启动指定Activity"><a href="#命令启动指定Activity" class="headerlink" title="命令启动指定Activity"></a>命令启动指定Activity</h3><p><code>adb shell am start -n ActivityName</code></p><hr><h2 id="Android-SDK抓取systrace"><a href="#Android-SDK抓取systrace" class="headerlink" title="Android SDK抓取systrace"></a>Android SDK抓取systrace</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">进入Android&#x2F;Sdk&#x2F;platform-tools&#x2F;systrace目录下</span><br><span class="line">python  systrace.py -b 8000 -t 5 -o systrace.html</span><br></pre></td></tr></table></figure><h3 id="打开模拟Vsync，从Systrace查看到"><a href="#打开模拟Vsync，从Systrace查看到" class="headerlink" title="打开模拟Vsync，从Systrace查看到"></a>打开模拟Vsync，从Systrace查看到</h3><ul><li>源码： Android 10的AOSP</li><li>方法： 修改<code>surfaceflinger/Scheduler/DispSync.cpp</code>的<code>static const bool kEnableZeroPhaseTracer = false;</code>为True</li></ul><h2 id="adb-devices很少识别"><a href="#adb-devices很少识别" class="headerlink" title="adb devices很少识别"></a>adb devices很少识别</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">方法一：</span><br><span class="line">lsusb  查看usb是否识别到手机</span><br><span class="line">如果没有，检查“开发者选项 -&gt; USB调试”是否打开</span><br><span class="line"></span><br><span class="line">方法二： 重启ADB服务</span><br><span class="line">adb kill-server</span><br><span class="line">adb start-server</span><br></pre></td></tr></table></figure><h3 id="添加usb设备自动识别信息-etc-udev-rules-d"><a href="#添加usb设备自动识别信息-etc-udev-rules-d" class="headerlink" title="添加usb设备自动识别信息/etc/udev/rules.d/"></a>添加usb设备自动识别信息/etc/udev/rules.d/</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">（1）lsusb查看usb链接设备</span><br><span class="line">（2）然后编辑&#x2F;新增文件(&#x2F;etc&#x2F;udev&#x2F;rules.d&#x2F;)：</span><br><span class="line">sudo vi 51-android.rules 文件内容：</span><br><span class="line">SUBSYSTEM&#x3D;&#x3D;&quot;usb&quot;,ATTRS&#123;idVendor&#125;&#x3D;&#x3D;&quot;093a&quot;,ATTRS&#123;idProduct&#125;&#x3D;&#x3D;&quot;120d&quot;,MODE&#x3D;&quot;0666&quot;</span><br><span class="line">（3）保存后重启udev服务</span><br><span class="line">sudo &#x2F;etc&#x2F;init.d&#x2F;udev restart或者sudo service udev restart</span><br><span class="line">（4）重新连接设备测试</span><br></pre></td></tr></table></figure><h2 id="adb-shell获取设备信息参数（序列号）"><a href="#adb-shell获取设备信息参数（序列号）" class="headerlink" title="adb shell获取设备信息参数（序列号）"></a>adb shell获取设备信息参数（序列号）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">getprop 查看机器的全部信息参数</span><br><span class="line">getprop ro.serialno 查看机器的序列号</span><br><span class="line">getprop ro.carrier 查看机器的CID号</span><br><span class="line">getprop ro.hardware 查看机器板子代号</span><br><span class="line">getprop ro.bootloader 查看SPL(Hboot)版本号</span><br><span class="line">getprop ro.build.version.release 查看系统版本（8、9...）</span><br><span class="line">getprop ro.build.display.id  获得厂商系统版本</span><br></pre></td></tr></table></figure><h2 id="Android中CPU频率查看和修改"><a href="#Android中CPU频率查看和修改" class="headerlink" title="Android中CPU频率查看和修改"></a>Android中CPU频率查看和修改</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root权限（直接输入su命令）</span><br><span class="line">cd sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;cpu0&#x2F;cpufreq</span><br><span class="line">ls文件如下</span><br><span class="line"></span><br><span class="line">cpuinfo_cur_freq： 当前cpu正在运行的工作频率</span><br><span class="line">cpuinfo_max_freq：该文件指定了处理器能够运行的最高工作频率 （单位: 千赫兹）</span><br><span class="line">cpuinfo_min_freq ：该文件指定了处理器能够运行的最低工作频率 （单位: 千赫兹）</span><br></pre></td></tr></table></figure><h2 id="Ubuntu下载更新杀毒软件"><a href="#Ubuntu下载更新杀毒软件" class="headerlink" title="Ubuntu下载更新杀毒软件"></a>Ubuntu下载更新杀毒软件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">下载：</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install clamav</span><br><span class="line"></span><br><span class="line">sudo chmod 777 freshclam.lg</span><br><span class="line">freshclamg更新</span><br><span class="line"></span><br><span class="line">扫描：</span><br><span class="line">clamav -a &#x2F;</span><br></pre></td></tr></table></figure><h2 id="安装deb包"><a href="#安装deb包" class="headerlink" title="安装deb包"></a>安装deb包</h2><blockquote><p>sudo dpkg -i gapid-1.3.1-linux.deb</p></blockquote><h2 id="查看手机服务"><a href="#查看手机服务" class="headerlink" title="查看手机服务"></a>查看手机服务</h2><blockquote><p>开发者选项 -&gt; Running services可以查看正在运行的服务，以及运行内存情况</p></blockquote><h2 id="查看修改屏幕分辨率和密度"><a href="#查看修改屏幕分辨率和密度" class="headerlink" title="查看修改屏幕分辨率和密度"></a>查看修改屏幕分辨率和密度</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">查看：</span><br><span class="line">adb shell</span><br><span class="line">wm   size  获得手机当前分辨率</span><br><span class="line">wm  density   获得手机当前屏幕密度（例如560dpi）</span><br><span class="line"></span><br><span class="line">修改：</span><br><span class="line">wm size 1096*2560</span><br><span class="line">wm density 420</span><br><span class="line"></span><br><span class="line">恢复：</span><br><span class="line">wm size reset</span><br><span class="line">wm density reset</span><br></pre></td></tr></table></figure><h2 id="查看进程map虚拟地址"><a href="#查看进程map虚拟地址" class="headerlink" title="查看进程map虚拟地址"></a>查看进程map虚拟地址</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">adb root;adb remount</span><br><span class="line">adb shell  </span><br><span class="line">ps -A|grep camera 查看服务的进程号(例如4712)  </span><br><span class="line">cd proc&#x2F;4712  进入进程号的文件夹  </span><br><span class="line">more maps 查看虚拟内存地址</span><br></pre></td></tr></table></figure><h2 id="SELinux模式开启关闭"><a href="#SELinux模式开启关闭" class="headerlink" title="SELinux模式开启关闭"></a>SELinux模式开启关闭</h2><p>SELinux(Security-Enabled Linux)是美国国家安全局（NSA）对于强制访问控制的实现（安全子系统）</p><p>临时生效方法：</p><ul><li><code>adb shell setenforce 0（临时生效，关闭SELinux模式）</code></li><li><code>adb shell setenforce 1（启用，开启SELinux模式）</code></li></ul><hr><h2 id="adb命令-–-录制手机视频"><a href="#adb命令-–-录制手机视频" class="headerlink" title="adb命令 – 录制手机视频"></a>adb命令 – 录制手机视频</h2><ul><li><code>adb shell screenrecord sdcard/record.mp4</code>  </li><li><code>1adb pull sdcard/record.mp4 .</code></li></ul><h2 id="adb命令-–-截图"><a href="#adb命令-–-截图" class="headerlink" title="adb命令 – 截图"></a>adb命令 – 截图</h2><ul><li><code>adb shell screencap -p sdcard/1.png</code></li></ul><h2 id="adb命令-–-输入文本"><a href="#adb命令-–-输入文本" class="headerlink" title="adb命令 – 输入文本"></a>adb命令 – 输入文本</h2><p>节省手动输入的时间：</p><ul><li><code>adb shell input text ****</code></li></ul><h2 id="adb命令-–-获取APP路径"><a href="#adb命令-–-获取APP路径" class="headerlink" title="adb命令 – 获取APP路径"></a>adb命令 – 获取APP路径</h2><ul><li><code>adb shell dumpsys SurfaceFlinger  最下方查看正在运行的APK</code></li><li><code>adb shell pm path &quot;com.**&quot; 获取路径</code></li></ul><h2 id="台式机通过WIFI建立adb连接，实现无线连接手机"><a href="#台式机通过WIFI建立adb连接，实现无线连接手机" class="headerlink" title="台式机通过WIFI建立adb连接，实现无线连接手机"></a>台式机通过WIFI建立adb连接，实现无线连接手机</h2><p>通常在需要手机连接外设显示设备的同时需要抓取Log、Dump等操作：</p><ol><li>两台手机连上同一个无线网</li><li>其中一台A关闭开发者选项的USB调试，并且连接到电脑作为热点（无线网卡）</li><li>另一台B连接电脑输入<code>adb tcpip 5555</code>，然后输入<code>adb shell ifconfig wlan0</code>查看B的IP地址</li><li>连接B手机的IP： adb connect IP</li><li>断开B，保持A连接在电脑</li></ol><h2 id="连接DP继续dump-SurfaceFlinger的方法"><a href="#连接DP继续dump-SurfaceFlinger的方法" class="headerlink" title="连接DP继续dump SurfaceFlinger的方法"></a>连接DP继续dump SurfaceFlinger的方法</h2><ol><li>连接DP前启动：<br><code>adb shell dumpsys SurfaceFlinger --file --no-limit</code></li><li>断开DP后再次执行结束Dump：<br><code>adb shell dumpsys SurfaceFlinger --file --no-limit</code></li><li>接过文件pull出来：<br><code>adb pull /data/misc/wmtrace/dumpsys.txt</code></li></ol><hr><h2 id="md5sum命令检测文件"><a href="#md5sum命令检测文件" class="headerlink" title="md5sum命令检测文件"></a>md5sum命令检测文件</h2><p>通过<code>md5sum filename</code>查看文件的<code>md5sum值</code>是否一样</p><h2 id="GSI含义"><a href="#GSI含义" class="headerlink" title="GSI含义"></a>GSI含义</h2><blockquote><p>GSI是替换成google的frameworks等(即system.img, 即google的原生AOSP)<br>system.img包含整个系统，framework、application等，被挂接到”/“目录下，包含系统的所有二进制文件。大概是编译出来的out/target/product/ProductName/system目录的映射</p></blockquote><h3 id="GSI方法"><a href="#GSI方法" class="headerlink" title="GSI方法"></a>GSI方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">常用步骤：</span><br><span class="line">adb reboot bootloader   (fastboot devices检测设备)</span><br><span class="line">fastboot erase system</span><br><span class="line">fastboot -w</span><br><span class="line">fastboot flash system GSI(.img file)</span><br><span class="line">fastboot reboot</span><br></pre></td></tr></table></figure><h2 id="CTS-VTS跑测注意点"><a href="#CTS-VTS跑测注意点" class="headerlink" title="CTS VTS跑测注意点"></a>CTS VTS跑测注意点</h2><ul><li>重跑：<code>run retry --retry 序列号</code></li><li>跑测arm64-v8a还是armeabi-v7a等:<code>run cts-suite -s ... -a arm64-v8 -m ...</code></li></ul><h2 id="linxu命令查找命令"><a href="#linxu命令查找命令" class="headerlink" title="linxu命令查找命令"></a>linxu命令查找命令</h2><h3 id="查找字符串"><a href="#查找字符串" class="headerlink" title="查找字符串"></a>查找字符串</h3><ul><li><code>grep -rn  字符串</code></li><li><code>grep 字符串 -Rin *    //查找该目录下包含该字符串的文件</code></li></ul><h3 id="查找文件"><a href="#查找文件" class="headerlink" title="查找文件"></a>查找文件</h3><ul><li><code>find . -iname Test*</code></li></ul><hr><h2 id="Git命令"><a href="#Git命令" class="headerlink" title="Git命令"></a>Git命令</h2><ol><li>回退到某个commitID： <code>git reset --hard commitID</code></li><li>新建一个Commit用于Revert某个分支： <code>git revert commitID</code></li><li>修改commit信息<br><code>git commit --amend --author=&quot;**&quot; --date=&quot;**&quot; 修改作者和日期</code></li><li>添加topic的方法(提交到Gerrit)<br><code>git push origin HEAD:refs/for/BRANCH_Name%topic=&quot;name&quot;</code></li><li>使用新的change ID覆盖原来已经提交的Patch<br><code>git push origin HEAD:refs/changes/99999 (gerrit上的已有Commit的Patch ID)</code></li></ol><h2 id="git-stash暂时储藏"><a href="#git-stash暂时储藏" class="headerlink" title="git stash暂时储藏"></a><strong><code>git stash</code>暂时储藏</strong></h2><p>用于修改的代码暂时保存起来，并且不影响下次的修改(这个比生成本地补丁方便<code>git format-patch -1 commitID</code>)：</p><ul><li><code>git stash save &quot;Remarks&quot;</code> 执行存储，并且添加备注</li><li><code>git stash list</code> 查看储藏列表</li><li><code>git stash show stash@{1}</code> 查看某次储藏的修改</li><li><code>git stash apply stash@{$Num}</code>  应用某次储藏</li><li><code>git stash pop stash@{$Num}</code>  从缓存堆栈中删除某次储藏并且应用到代码中，默认第一个stash</li><li><code>git stash drop stash@{$Num}</code> 从列表删除这个存储</li><li><code>git stash clear</code>  删除所有缓存的stash</li></ul><hr><h2 id="Repo下载项目方法"><a href="#Repo下载项目方法" class="headerlink" title="Repo下载项目方法"></a>Repo下载项目方法</h2><ol><li>下载<code>.repo</code>：<br><code>repo init -u Git远程仓库 -b Branch_Name(分支选择)</code></li><li>Sync项目：<code>repo sync -c -j4</code>（当前分支）</li><li>如果值Sync指定目录，则在指定目录下执行：<code>repo sync -c . -j4</code></li></ol><h2 id="Android常用编译方式"><a href="#Android常用编译方式" class="headerlink" title="Android常用编译方式"></a>Android常用编译方式</h2><ol><li><code>source build/envsetup.sh</code></li><li><code>lunch //选择指定Product</code></li><li><code>make fullbuild -j4</code></li><li>如果只编译部分模块：</li></ol><ul><li>framework模块：<code>make framework -j4</code>，结果生成framework.jar包到/system/framework</li><li>编译<code>kernal/msm</code>使用： <code>make bootimage -j4</code></li><li>指定目录下执行:<code>mm/mmm/mma(依赖编译)</code></li></ul><hr>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;readelf命令查看ELF格式的文件信息&quot;&gt;&lt;a href=&quot;#readelf命令查看ELF格式的文件信息&quot; class=&quot;headerlink&quot; title=&quot;readelf命令查看ELF格式的文件信息&quot;&gt;&lt;/a&gt;readelf命令查看ELF格式的文件信息&lt;/h2&gt;&lt;p&gt;常见的文件比如动态库(&lt;code&gt;*.so&lt;/code&gt;)、静态库（&lt;code&gt;*.a&lt;/code&gt;），常用命令：&lt;code&gt;readelf -a libgui.so | grep test_string&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="android" scheme="http://wizzie.top/categories/android/"/>
    
    
      <category term="graphics" scheme="http://wizzie.top/tags/graphics/"/>
    
  </entry>
  
  <entry>
    <title>nReal搭建Samepl APK</title>
    <link href="http://wizzie.top/2019/09/30/2019/190930_nReal_Sample/"/>
    <id>http://wizzie.top/2019/09/30/2019/190930_nReal_Sample/</id>
    <published>2019-09-30T13:52:00.000Z</published>
    <updated>2020-03-08T10:14:08.790Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>nrsdk是nreal开发混合现实体验的平台。使用简单的开发过程和高级api，nrsdk提供了一组强大的mr特性，并使nreal眼镜能够了解真实世界。</p><p>nrsdk为开发者提供了五个核心特性：</p><ol><li>空间计算使眼镜能够跟踪它们相对于世界的实时位置，并了解周围的环境，例如检测和跟踪平面和图像。</li><li>优化的渲染自动应用于应用程序并在后端运行，以最小化延迟并减少抖动，增强总体用户体验。</li><li>多模态交互为不同的用例提供了交互的直观选择。</li><li>提供了开发工具，以便您可以更好地开发和调试应用程序。</li><li>第三方集成是通过为第三方sdk提供数据来实现的，这允许您充分利用nreal light的硬件功能并构建功能强大的mr/ar应用程序。<a id="more"></a><h2 id="开发工具包"><a href="#开发工具包" class="headerlink" title="开发工具包"></a>开发工具包</h2></li></ol><p>开发混合现实应用程序需要一个nreal开发工具包。开发工具包由一对nreal光学眼镜、nreal计算单元和nreal光学控制器组成。如果没有，请在这里注册nreal开发工具包！<br>到目前为止，你还不能直接在android手机上开发应用程序。安卓手机开发将于2020年初推出。</p><h2 id="选择开发平台"><a href="#选择开发平台" class="headerlink" title="选择开发平台"></a>选择开发平台</h2><p>nrsdk支持许多最流行的开发环境。通过这些功能，您可以构建全新的mr体验，或者使用mr功能增强现有的原生android应用程序。<br>Unity （Support Unity 2018.2.X） Android Native (to be released) Unreal (to be released)</p><h2 id="与Android本机应用程序兼容"><a href="#与Android本机应用程序兼容" class="headerlink" title="与Android本机应用程序兼容"></a>与Android本机应用程序兼容</h2><p>nreal眼镜现在与android原生应用程序兼容，这意味着只要应用程序安装在设备上，用户就可以通过眼镜查看所有应用程序活动。在你这边什么都不需要改变。要使2d应用程序更具沉浸感和三维感，可以使用nrsdk在现有应用程序中添加mr功能或3d虚拟对象。</p><h1 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h1><h2 id="空间计算"><a href="#空间计算" class="headerlink" title="空间计算"></a>空间计算</h2><p>nreal眼镜使用各种传感器和相机，以建立对周围环境和用户本身的复杂理解，创造身临其境的体验，无缝融合数字世界和现实世界。</p><hr><h1 id="HelloMR-APP"><a href="#HelloMR-APP" class="headerlink" title="HelloMR APP"></a>HelloMR APP</h1><h2 id="硬件清单"><a href="#硬件清单" class="headerlink" title="硬件清单"></a>硬件清单</h2><ol><li>一个nreal计算单元（把它想象成一个没有屏幕的android手机，所以所有的开发过程都将非常类似于移动应用程序开发）。</li><li>一副自然光眼镜</li><li>没有nreal设备？注册nreal开发工具包！或者尝试仿真器在没有nreal眼镜和计算单元的情况下引导nreal应用程序功能。</li><li>连接nReal计算单元和PC的USB-C电缆</li><li>不需要Wi-Fi连接。但是，可以使用Wi-Fi Android调试桥（ADB）连接进行调试和测试。</li></ol><h2 id="软件清单"><a href="#软件清单" class="headerlink" title="软件清单"></a>软件清单</h2><ol><li>Unity 2018.2.x或更高版本，支持Android构建</li><li>下载Unity 1.1的nrsdk(sdk作为nrsdkforunity_1.1.unitypackage下载)</li><li>android sdk 7.0（api级别24）或更高版本，使用android studio中的sdk管理器安装</li></ol><h2 id="创建统一项目"><a href="#创建统一项目" class="headerlink" title="创建统一项目"></a>创建统一项目</h2><ol><li>打开Unity并创建一个新的3D项目。</li><li>set  player settings&gt;other settings&gt;scriptping runtime version to.net 4.x等效版本</li><li>为unity导入nrsdk</li><li><ol><li>选择“资源&gt;导入包&gt;自定义包”。</li></ol></li><li><ol start="2"><li>选择您下载的nrsdkforunity_1.1.unitypackage。</li></ol></li><li><ol start="3"><li>在“导入包”对话框中，确保选中了所有包选项，然后单击“导入”。</li></ol></li></ol><p>在unity项目窗口中，通过选择assets&gt;nrsk&gt;demos&gt;hellomr找到hellomr示例应用程序。</p><h2 id="配置生成设置"><a href="#配置生成设置" class="headerlink" title="配置生成设置"></a>配置生成设置</h2><ol><li>转到“文件&gt;生成设置”。</li><li>选择android并单击switch platform。</li><li>在“生成设置”窗口中，单击“播放器设置”。</li><li>在Inspector窗口中，按如下方式配置播放机设置：(<a href="https://developer.nreal.ai/develop/unity/android-quickstart" target="_blank" rel="noopener">https://developer.nreal.ai/develop/unity/android-quickstart</a>)</li></ol><h2 id="连接到nReal设备-开发工具包"><a href="#连接到nReal设备-开发工具包" class="headerlink" title="连接到nReal设备(开发工具包)"></a>连接到nReal设备(开发工具包)</h2><p>在计算单元上启用开发人员选项和USB调试。android调试桥（adb）作为默认设置启用，不需要手动设置）。<br>将计算单元连接到Windows PC。</p><h2 id="建立并运行"><a href="#建立并运行" class="headerlink" title="建立并运行"></a>建立并运行</h2><ol><li>在Unity Build设置窗口中，单击Build。在构建成功后，通过wifi android调试桥（adb）安装应用程序。</li><li>断开电脑与电脑的连接，然后将其连接到眼镜上。</li><li>如果这是您第一次运行此应用程序，则需要使用某些工具（如scrcpy）对该应用程序进行身份验证。</li><li>与nReal Light控制器一起启动应用程序。有关如何使用nReal Light控制器的说明，请参阅控制器指南。</li><li>四处移动，直到nrsdk找到一个水平面，检测到的平面将被绿色网格覆盖。</li><li>单击触发器按钮在其上放置nReal徽标对象。</li><li>（可选）使用android logcat查看记录的消息。我们建议使用WiFi Android调试桥（ADB）连接到您的PC，这样您就不必在大多数时间通过数据线连接。</li></ol><hr><h1 id="Sample-APP-立体方块"><a href="#Sample-APP-立体方块" class="headerlink" title="Sample APP(立体方块)"></a>Sample APP(立体方块)</h1><h2 id="scene设置"><a href="#scene设置" class="headerlink" title="scene设置"></a>scene设置</h2><ol><li>在SampleScene删除主摄像头；</li><li>将Assets -&gt; NRSDK -&gt; Prefabs -&gt; NRCameraRig拖拽到SampleScene中；</li><li>将Assets -&gt; NRSDK -&gt; Prefabs -&gt; NRInput拖拽到SampleScene中；</li><li>将Assets -&gt; NRSDK -&gt; Emulator -&gt; Prefabs -&gt; NRTrackableImageTarget拖拽到SampleScene;<br>在其中可以修改场景图像（Image Target）</li><li>在SampleAPP右侧窗口中右击Create -&gt; 3D -&gt; Object -&gt; Cube，创建立方体<br>将Scale均修改成0.25</li><li>右击Create Empty,在Inspector中Add Component<br>(1)Script设置为TrackableFoundTest<br>(2)Observer设置为NRTrackableImageTarget<br>(3)Obj设置为Cube</li><li>打开Assets -&gt; NRSDK -&gt; Emulator -&gt; Scripts -&gt; TrackableFoundTest,编辑源文件C#，添加Update函数，增加每次点击切换立方体颜色</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">using NRKernal;</span><br><span class="line">...</span><br><span class="line">   private void Update()</span><br><span class="line">    &#123;</span><br><span class="line">        if (NRInput.GetButtonDown(ControllerButton.TRIGGER))</span><br><span class="line">            Obj.GetComponent&lt;Renderer&gt;().material.color &#x3D; new Color(Random.value, Random.value, Random.value);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol start="8"><li>File -&gt; BuildSettings添加SampleAPP，然后选择Android，最后Building</li><li>生成APK，安装full screen black</li><li>或者在Unity上方点击Play按钮使用Emulator查看，常用按键操作：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">WASD控制前后左右；</span><br><span class="line">Space+鼠标表示头部旋转；</span><br><span class="line">SHIFT+鼠标移动模拟nReal控制器的旋转（3DOF控制器）；</span><br><span class="line">单击鼠标左键模拟控制器触发器的单击（此处会触发Update函数变化颜色）；</span><br><span class="line">单击鼠标右键以模拟控制器主页按钮的压力；</span><br><span class="line">单击鼠标滚轮按钮以模拟控制器的APP按钮的压力；</span><br><span class="line">使用箭头键模拟在控制器的触摸板上滑动；</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;nrsdk是nreal开发混合现实体验的平台。使用简单的开发过程和高级api，nrsdk提供了一组强大的mr特性，并使nreal眼镜能够了解真实世界。&lt;/p&gt;
&lt;p&gt;nrsdk为开发者提供了五个核心特性：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;空间计算使眼镜能够跟踪它们相对于世界的实时位置，并了解周围的环境，例如检测和跟踪平面和图像。&lt;/li&gt;
&lt;li&gt;优化的渲染自动应用于应用程序并在后端运行，以最小化延迟并减少抖动，增强总体用户体验。&lt;/li&gt;
&lt;li&gt;多模态交互为不同的用例提供了交互的直观选择。&lt;/li&gt;
&lt;li&gt;提供了开发工具，以便您可以更好地开发和调试应用程序。&lt;/li&gt;
&lt;li&gt;第三方集成是通过为第三方sdk提供数据来实现的，这允许您充分利用nreal light的硬件功能并构建功能强大的mr/ar应用程序。
    
    </summary>
    
    
      <category term="VR" scheme="http://wizzie.top/categories/VR/"/>
    
    
      <category term="nReal" scheme="http://wizzie.top/tags/nReal/"/>
    
  </entry>
  
  <entry>
    <title>Android Handler消息循环处理机制(例ActivityThread)</title>
    <link href="http://wizzie.top/2019/09/22/2019/190922-android-handler-cpp/"/>
    <id>http://wizzie.top/2019/09/22/2019/190922-android-handler-cpp/</id>
    <published>2019-09-22T07:01:32.000Z</published>
    <updated>2020-03-08T10:14:08.790Z</updated>
    
    <content type="html"><![CDATA[<h2 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h2><blockquote><p>关键词：Handler、Looper、MessageQueue、handleMessage</p></blockquote><p>消息被存放于消息队列，应用程序的主线程会围绕这个消息队列进入一个无限循环，知道应用程序退出。（消息循环过程是由Looper实现的）</p><ul><li>如果队列中有消息，应用程序的主线程会把它取出来，分发给相应的Handler进行处理；</li><li>如果队列中没有消息，应用程序的主县城就会进入空闲等待状态，等待下一个消息的到来；<a id="more"></a><h2 id="消息循环（以ActivityThread为例）"><a href="#消息循环（以ActivityThread为例）" class="headerlink" title="消息循环（以ActivityThread为例）"></a>消息循环（以ActivityThread为例）</h2></li></ul><p>应用程序的消息循环是从 ActivityThread 的 main()函数入口的，在 main()函数中会调用<code>Looper.prepareMainLooper();</code>和<code>Looper.loop();</code></p><blockquote><p>代码： <a href="http://aosp.opersys.com/xref/android-10.0.0_r2/xref/frameworks/base/core/java/android/app/ActivityThread.java#7310" target="_blank" rel="noopener">http://aosp.opersys.com/xref/android-10.0.0_r2/xref/frameworks/base/core/java/android/app/ActivityThread.java#7310</a></p></blockquote><figure class="highlight java"><figcaption><span>frameworks/base/core/java/android/app/ActivityThread.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"ActivityThreadMain"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Install selective syscall interception</span></span><br><span class="line">        AndroidOs.install();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// CloseGuard defaults to true and can be quite spammy.  We</span></span><br><span class="line">        <span class="comment">// disable it here, but selectively enable it later (via</span></span><br><span class="line">        <span class="comment">// StrictMode) on debug builds, but using DropBox, not logs.</span></span><br><span class="line">        CloseGuard.setEnabled(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        Environment.initForCurrentUser();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Make sure TrustedCertificateStore looks in the right place for CA certificates</span></span><br><span class="line">        <span class="keyword">final</span> File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId());</span><br><span class="line">        TrustedCertificateStore.setDefaultUserDirectory(configDir);</span><br><span class="line"></span><br><span class="line">        Process.setArgV0(<span class="string">"&lt;pre-initialized&gt;"</span>);</span><br><span class="line"></span><br><span class="line">        Looper.prepareMainLooper();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Find the value for &#123;@link #PROC_START_SEQ_IDENT&#125; if provided on the command line.</span></span><br><span class="line">        <span class="comment">// It will be in the format "seq=114"</span></span><br><span class="line">        <span class="keyword">long</span> startSeq = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = args.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (args[i] != <span class="keyword">null</span> &amp;&amp; args[i].startsWith(PROC_START_SEQ_IDENT)) &#123;</span><br><span class="line">                    startSeq = Long.parseLong(</span><br><span class="line">                            args[i].substring(PROC_START_SEQ_IDENT.length()));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ActivityThread thread = <span class="keyword">new</span> ActivityThread();</span><br><span class="line">        thread.attach(<span class="keyword">false</span>, startSeq);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sMainThreadHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">            sMainThreadHandler = thread.getHandler();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">false</span>) &#123;</span><br><span class="line">            Looper.myLooper().setMessageLogging(<span class="keyword">new</span></span><br><span class="line">                    LogPrinter(Log.DEBUG, <span class="string">"ActivityThread"</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// End of event ActivityThreadMain.</span></span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">        Looper.loop();  <span class="comment">//消息循环</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Main thread loop unexpectedly exited"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>创建Looper对象的时候，会同时创建一个 MessageQueue，保存在 Looper 的成员变量 mQueue 中。Looper和MessageQueue就是这样关联起来的。</p><p>JNI层创建 Looper 时会通过 pipe 系统调用来创建一个管道。</p><figure class="highlight java"><figcaption><span>frameworks/base/core/java/android/os/Looper.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Looper</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">    mQueue = <span class="keyword">new</span> MessageQueue(quitAllowed);</span><br><span class="line">    mThread = Thread.currentThread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该Looper对象创建好之后会保存在 NativeMessageQueue 对象的成员变量 mLooper 中，这个对象的作用是，通过管道实现以下功能：当Java层的消息队列中没有消息时，就使 Android 应用程序主线程进入等待状态，而当Java层的消息队列中来了消息时，就唤醒Android应用程序的主线程来处理这个消息。</p><p>ActivityThread调用<code>Looper.loop()</code>才会进入消息循环。</p><p>进入消息循环后，会不断地从消息队列<code>mQueue</code>中去获取下一个要处理的消息msg，如果消息的target为null，就表示要退出消息循环了，否则就会调用target对象的 dispatchMessage 函数来处理这个消息。</p><p>调用 queue 的 next 函数去获取下一个要处理的消息，但调用这个函数有可能会让线程进入等待状态。一是当消息队列中没有消息时，它会使线程进入等待状态；二是消息队列中有消息，但是消息指定了执行的时间，而现在还没有到这个时间，线程也会进入等待状态。</p><figure class="highlight java"><figcaption><span>/frameworks/base/core/java/android/os/Looper.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">final</span> Looper me = myLooper();</span><br><span class="line">     <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">final</span> MessageQueue queue = me.mQueue;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Make sure the identity of this thread is that of the local process,</span></span><br><span class="line">     <span class="comment">// and keep track of what that identity token actually is.</span></span><br><span class="line">     Binder.clearCallingIdentity();</span><br><span class="line">     <span class="keyword">final</span> <span class="keyword">long</span> ident = Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Allow overriding a threshold with a system prop. e.g.</span></span><br><span class="line">     <span class="comment">// adb shell 'setprop log.looper.1000.main.slow 1 &amp;&amp; stop &amp;&amp; start'</span></span><br><span class="line">     <span class="keyword">final</span> <span class="keyword">int</span> thresholdOverride =</span><br><span class="line">             SystemProperties.getInt(<span class="string">"log.looper."</span></span><br><span class="line">                     + Process.myUid() + <span class="string">"."</span></span><br><span class="line">                     + Thread.currentThread().getName()</span><br><span class="line">                     + <span class="string">".slow"</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">boolean</span> slowDeliveryDetected = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">         Message msg = queue.next(); <span class="comment">// might block</span></span><br><span class="line">         <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">             <span class="comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// This must be in a local variable, in case a UI event sets the logger</span></span><br><span class="line">         <span class="keyword">final</span> Printer logging = me.mLogging;</span><br><span class="line">         <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</span><br><span class="line">             logging.println(<span class="string">"&gt;&gt;&gt;&gt;&gt; Dispatching to "</span> + msg.target + <span class="string">" "</span> +</span><br><span class="line">                     msg.callback + <span class="string">": "</span> + msg.what);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// Make sure the observer won't change while processing a transaction.</span></span><br><span class="line">         <span class="keyword">final</span> Observer observer = sObserver;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">final</span> <span class="keyword">long</span> traceTag = me.mTraceTag;</span><br><span class="line">         <span class="keyword">long</span> slowDispatchThresholdMs = me.mSlowDispatchThresholdMs;</span><br><span class="line">         <span class="keyword">long</span> slowDeliveryThresholdMs = me.mSlowDeliveryThresholdMs;</span><br><span class="line">         <span class="keyword">if</span> (thresholdOverride &gt; <span class="number">0</span>) &#123;</span><br><span class="line">             slowDispatchThresholdMs = thresholdOverride;</span><br><span class="line">             slowDeliveryThresholdMs = thresholdOverride;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">final</span> <span class="keyword">boolean</span> logSlowDelivery = (slowDeliveryThresholdMs &gt; <span class="number">0</span>) &amp;&amp; (msg.when &gt; <span class="number">0</span>);</span><br><span class="line">         <span class="keyword">final</span> <span class="keyword">boolean</span> logSlowDispatch = (slowDispatchThresholdMs &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">         <span class="keyword">final</span> <span class="keyword">boolean</span> needStartTime = logSlowDelivery || logSlowDispatch;</span><br><span class="line">         <span class="keyword">final</span> <span class="keyword">boolean</span> needEndTime = logSlowDispatch;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (traceTag != <span class="number">0</span> &amp;&amp; Trace.isTagEnabled(traceTag)) &#123;</span><br><span class="line">             Trace.traceBegin(traceTag, msg.target.getTraceName(msg));</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">final</span> <span class="keyword">long</span> dispatchStart = needStartTime ? SystemClock.uptimeMillis() : <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">final</span> <span class="keyword">long</span> dispatchEnd;</span><br><span class="line">         Object token = <span class="keyword">null</span>;</span><br><span class="line">         <span class="keyword">if</span> (observer != <span class="keyword">null</span>) &#123;</span><br><span class="line">             token = observer.messageDispatchStarting();</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">long</span> origWorkSource = ThreadLocalWorkSource.setUid(msg.workSourceUid);</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             msg.target.dispatchMessage(msg);</span><br><span class="line">             <span class="keyword">if</span> (observer != <span class="keyword">null</span>) &#123;</span><br><span class="line">                 observer.messageDispatched(token, msg);</span><br><span class="line">             &#125;</span><br><span class="line">             dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : <span class="number">0</span>;</span><br><span class="line">         &#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">             <span class="keyword">if</span> (observer != <span class="keyword">null</span>) &#123;</span><br><span class="line">                 observer.dispatchingThrewException(token, msg, exception);</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">throw</span> exception;</span><br><span class="line">         &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">             ThreadLocalWorkSource.restore(origWorkSource);</span><br><span class="line">             <span class="keyword">if</span> (traceTag != <span class="number">0</span>) &#123;</span><br><span class="line">                 Trace.traceEnd(traceTag);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (logSlowDelivery) &#123;</span><br><span class="line">             <span class="keyword">if</span> (slowDeliveryDetected) &#123;</span><br><span class="line">                 <span class="keyword">if</span> ((dispatchStart - msg.when) &lt;= <span class="number">10</span>) &#123;</span><br><span class="line">                     Slog.w(TAG, <span class="string">"Drained"</span>);</span><br><span class="line">                     slowDeliveryDetected = <span class="keyword">false</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 <span class="keyword">if</span> (showSlowLog(slowDeliveryThresholdMs, msg.when, dispatchStart, <span class="string">"delivery"</span>,</span><br><span class="line">                         msg)) &#123;</span><br><span class="line">                     <span class="comment">// Once we write a slow delivery log, suppress until the queue drains.</span></span><br><span class="line">                     slowDeliveryDetected = <span class="keyword">true</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (logSlowDispatch) &#123;</span><br><span class="line">             showSlowLog(slowDispatchThresholdMs, dispatchStart, dispatchEnd, <span class="string">"dispatch"</span>, msg);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</span><br><span class="line">             logging.println(<span class="string">"&lt;&lt;&lt;&lt;&lt; Finished to "</span> + msg.target + <span class="string">" "</span> + msg.callback);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Make sure that during the course of dispatching the</span></span><br><span class="line">         <span class="comment">// identity of the thread wasn't corrupted.</span></span><br><span class="line">         <span class="keyword">final</span> <span class="keyword">long</span> newIdent = Binder.clearCallingIdentity();</span><br><span class="line">         <span class="keyword">if</span> (ident != newIdent) &#123;</span><br><span class="line">             Log.wtf(TAG, <span class="string">"Thread identity changed from 0x"</span></span><br><span class="line">                     + Long.toHexString(ident) + <span class="string">" to 0x"</span></span><br><span class="line">                     + Long.toHexString(newIdent) + <span class="string">" while dispatching to "</span></span><br><span class="line">                     + msg.target.getClass().getName() + <span class="string">" "</span></span><br><span class="line">                     + msg.callback + <span class="string">" what="</span> + msg.what);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         msg.recycleUnchecked();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>调用 queue 的 next 函数去获取下一个要处理的消息，但调用这个函数有可能会让线程进入等待状态。一是当消息队列中没有消息时，它会使线程进入等待状态；二是消息队列中有消息，但是消息指定了执行的时间，而现在还没有到这个时间，线程也会进入等待状态。</p><p><img src="Handler-1.png" alt="消息处理流程"></p><h2 id="消息发送"><a href="#消息发送" class="headerlink" title="消息发送"></a>消息发送</h2><p>从应用程序启动入口分析下消息发送流程。应用程序启动过程中会调用 sendMessage 函数向应用程序的消息队列中加入一个新的消息。<br>sendMessage将参数封装成Message，然后通过mH.sendMessage把该消息加入消息队列。mH是ActivityThread类的成员变量，它的类型为H，继承于<code>Handler</code>类。</p><p>定义： <code>final H mH = new H();</code></p><figure class="highlight java"><figcaption><span>/frameworks/base/core/java/android/app/ActivityThread.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(<span class="keyword">int</span> what, Object obj, <span class="keyword">int</span> arg1, <span class="keyword">int</span> arg2, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_MESSAGES) &#123;</span><br><span class="line">        Slog.v(TAG,</span><br><span class="line">                <span class="string">"SCHEDULE "</span> + what + <span class="string">" "</span> + mH.codeToString(what) + <span class="string">": "</span> + arg1 + <span class="string">" / "</span> + obj);</span><br><span class="line">    &#125;</span><br><span class="line">    Message msg = Message.obtain();</span><br><span class="line">    msg.what = what;</span><br><span class="line">    msg.obj = obj;</span><br><span class="line">    msg.arg1 = arg1;</span><br><span class="line">    msg.arg2 = arg2;</span><br><span class="line">    <span class="keyword">if</span> (async) &#123;</span><br><span class="line">        msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mH.sendMessage(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sendMessage函数是继承于Handler的，Handler在它的构造函数中获取了Looper对象和MessageQueue 对象。</p><figure class="highlight java"><figcaption><span>frameworks/base/core/java/android/os/Handler.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessage</span><span class="params">(@NonNull Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sendMessageDelayed(msg, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessageDelayed</span><span class="params">(@NonNull Message msg, <span class="keyword">long</span> delayMillis)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (delayMillis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        delayMillis = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtTime</span><span class="params">(@NonNull Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">    MessageQueue queue = mQueue;</span><br><span class="line">    <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</span><br><span class="line">        RuntimeException e = <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="keyword">this</span> + <span class="string">" sendMessageAtTime() called with no mQueue"</span>);</span><br><span class="line">        Log.w(<span class="string">"Looper"</span>, e.getMessage(), e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>msg.target = this;</code>表示这个消息最终由这个Handler对象来处理，即由ActivityThread对象的mH成员变量来处理。最终会调到MessageQueue的<code>enqueueMessage</code>函数最后会调到<code>Looper.cpp</code>的<code>wake</code>函数。</p><figure class="highlight java"><figcaption><span>/frameworks/base/core/java/android/os/Handler.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(@NonNull MessageQueue queue, @NonNull Message msg,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">    msg.target = <span class="keyword">this</span>;</span><br><span class="line">    msg.workSourceUid = ThreadLocalWorkSource.getUid();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mAsynchronous) &#123;</span><br><span class="line">        msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>frameworks/base/core/java/android/os/MessageQueue.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Message must have a target."</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (msg.isInUse()) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(msg + <span class="string">" This message is already in use."</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">               IllegalStateException e = <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                       msg.target + <span class="string">" sending message to a Handler on a dead thread"</span>);</span><br><span class="line">               Log.w(TAG, e.getMessage(), e);</span><br><span class="line">               msg.recycle();</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           msg.markInUse();</span><br><span class="line">           msg.when = when;</span><br><span class="line">           Message p = mMessages;</span><br><span class="line">           <span class="keyword">boolean</span> needWake;</span><br><span class="line">           <span class="keyword">if</span> (p == <span class="keyword">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</span><br><span class="line">               <span class="comment">// New head, wake up the event queue if blocked.</span></span><br><span class="line">               msg.next = p;</span><br><span class="line">               mMessages = msg;</span><br><span class="line">               needWake = mBlocked;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">// Inserted within the middle of the queue.  Usually we don't have to wake</span></span><br><span class="line">               <span class="comment">// up the event queue unless there is a barrier at the head of the queue</span></span><br><span class="line">               <span class="comment">// and the message is the earliest asynchronous message in the queue.</span></span><br><span class="line">               needWake = mBlocked &amp;&amp; p.target == <span class="keyword">null</span> &amp;&amp; msg.isAsynchronous();</span><br><span class="line">               Message prev;</span><br><span class="line">               <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                   prev = p;</span><br><span class="line">                   p = p.next;</span><br><span class="line">                   <span class="keyword">if</span> (p == <span class="keyword">null</span> || when &lt; p.when) &#123;</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                       needWake = <span class="keyword">false</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               msg.next = p; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">               prev.next = msg;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// We can assume mPtr != 0 because mQuitting is false.</span></span><br><span class="line">           <span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">               nativeWake(mPtr);   <span class="comment">//此处调用JNI函数</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><figcaption><span>/frameworks/base/core/jni/android_os_MessageQueue.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">android_os_MessageQueue_nativeWake</span><span class="params">(JNIEnv* env, jclass clazz, jlong ptr)</span> </span>&#123;</span><br><span class="line">    NativeMessageQueue* nativeMessageQueue = <span class="keyword">reinterpret_cast</span>&lt;NativeMessageQueue*&gt;(ptr);</span><br><span class="line">    nativeMessageQueue-&gt;wake();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="消息处理"><a href="#消息处理" class="headerlink" title="消息处理"></a>消息处理</h2><p>ActivityThread的main函数在<code>Looper.loop</code>函数中调用<code>msg.target.dispatchMessage(msg)</code>去处理消息。</p><figure class="highlight java"><figcaption><span>frameworks/base/core/java/android/os/Looper.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">              msg.target.dispatchMessage(msg);   <span class="comment">//处理消息</span></span><br><span class="line">              <span class="keyword">if</span> (observer != <span class="keyword">null</span>) &#123;</span><br><span class="line">                  observer.messageDispatched(token, msg);</span><br><span class="line">              &#125;</span><br><span class="line">              dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : <span class="number">0</span>;</span><br><span class="line">          &#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">              <span class="keyword">if</span> (observer != <span class="keyword">null</span>) &#123;</span><br><span class="line">                  observer.dispatchingThrewException(token, msg, exception);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">throw</span> exception;</span><br><span class="line">          &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">              ThreadLocalWorkSource.restore(origWorkSource);</span><br><span class="line">              <span class="keyword">if</span> (traceTag != <span class="number">0</span>) &#123;</span><br><span class="line">                  Trace.traceEnd(traceTag);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure><p>消息对象msg的成员变量<code>target</code>是在发送消息的时候设置好的，通过哪个Handler来发送消息，就通过哪个Handler来处理消息。</p><p>当时是 H 类把消息加入消息队列的，现在也该由 H 类处理消息。 H类没有实现自己的<code>dispatchMessage</code>函数，但它继承了父类Handler的dispatchMessage函数。</p><figure class="highlight java"><figcaption><span>frameworks/base/core/java/android/os/Handler.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(@NonNull Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">        handleCallback(msg);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        handleMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终调用<code>handleMessage</code>处理消息。此处既是调用<code>ActivityThread.java</code>的该函数。</p><figure class="highlight java"><figcaption><span>/frameworks/base/core/java/android/app/ActivityThread.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (DEBUG_MESSAGES) Slog.v(TAG, <span class="string">"&gt;&gt;&gt; handling: "</span> + codeToString(msg.what));</span><br><span class="line">          <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">              <span class="keyword">case</span> BIND_APPLICATION:</span><br><span class="line">                  Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"bindApplication"</span>);</span><br><span class="line">                  AppBindData data = (AppBindData)msg.obj;</span><br><span class="line">                  handleBindApplication(data);</span><br><span class="line">                  Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">                  .......</span><br></pre></td></tr></table></figure><h2 id="SurfaceFlinger的消息处理机制"><a href="#SurfaceFlinger的消息处理机制" class="headerlink" title="SurfaceFlinger的消息处理机制"></a>SurfaceFlinger的消息处理机制</h2><blockquote><p>类似的消息处理机制在SurfaceFlinger也存在，拥有独自的文件<code>frameworks/native/services/surfaceflinger/Scheduler/MessageQueue.cpp</code>等待消息、发送消息、处理消息。从而进行Layer合成事件。</p></blockquote><figure class="highlight c++"><figcaption><span>/frameworks/native/services/surfaceflinger/Scheduler/MessageQueue.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MessageQueue::Handler::handleMessage(<span class="keyword">const</span> Message&amp; message) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (message.what) &#123;</span><br><span class="line">        <span class="keyword">case</span> INVALIDATE:</span><br><span class="line">            android_atomic_and(~eventMaskInvalidate, &amp;mEventMask);</span><br><span class="line">            mQueue.mFlinger-&gt;onMessageReceived(message.what);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> REFRESH:</span><br><span class="line">            android_atomic_and(~eventMaskRefresh, &amp;mEventMask);</span><br><span class="line">            mQueue.mFlinger-&gt;onMessageReceived(message.what);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;整体流程&quot;&gt;&lt;a href=&quot;#整体流程&quot; class=&quot;headerlink&quot; title=&quot;整体流程&quot;&gt;&lt;/a&gt;整体流程&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;关键词：Handler、Looper、MessageQueue、handleMessage&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;消息被存放于消息队列，应用程序的主线程会围绕这个消息队列进入一个无限循环，知道应用程序退出。（消息循环过程是由Looper实现的）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果队列中有消息，应用程序的主线程会把它取出来，分发给相应的Handler进行处理；&lt;/li&gt;
&lt;li&gt;如果队列中没有消息，应用程序的主县城就会进入空闲等待状态，等待下一个消息的到来；
    
    </summary>
    
    
      <category term="android" scheme="http://wizzie.top/categories/android/"/>
    
    
      <category term="android" scheme="http://wizzie.top/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>Android WMS和View基本理解</title>
    <link href="http://wizzie.top/2019/09/21/2019/190921-android-wms-view-cpp/"/>
    <id>http://wizzie.top/2019/09/21/2019/190921-android-wms-view-cpp/</id>
    <published>2019-09-21T13:32:22.000Z</published>
    <updated>2020-03-08T10:14:08.790Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>Window 可以看做是Surface的一个包装，本质上，Window的本体就是一片Surface。将操作对象Surface，对象关联属性集以及操作方法等组合在一起便是 Window。Surface 其实是一块画布，应用可以随心所欲地通过 Canvas 或者 OpenGL 在其上作画，然后通过 SurfaceFlinger 将多块 Surface 的内容按照特定的顺序(ZOrder)进行混合并输出到 FrameBuffer，从而将 Android 漂亮的脸蛋显示给用户。既然每个窗口都有一块 Surface 供自己涂鸦，所以必然需要一个角色对所有窗口的 Surface 进行协调管理。于是,WMS 应运而生。</p></blockquote><blockquote><p>代码： <a href="http://aosp.opersys.com/xref/android-10.0.0_r2/xref/frameworks/base/core/java/android/view/" target="_blank" rel="noopener">http://aosp.opersys.com/xref/android-10.0.0_r2/xref/frameworks/base/core/java/android/view/</a></p></blockquote><a id="more"></a><p><strong>对应的关系：</strong></p><ul><li>1 IDirectFB (顶层) &lt;–&gt; N 屏幕(Screens)</li><li>1 屏幕(Screen) &lt;–&gt; N 层(Layers)</li><li>1 层(Layer) &lt;–&gt; 1 主表面(Primary Surface)</li><li>1 层(Layer) &lt;–&gt; N 窗口(Windows)</li><li>1 窗口(Window) &lt;–&gt; 1 窗口表面(Window Surface)</li><li>1 表面(Surface) &lt;–&gt; N 子表面(Subsurfaces)</li></ul><h3 id="Dump-window信息"><a href="#Dump-window信息" class="headerlink" title="Dump window信息"></a>Dump window信息</h3><p><code>adb shell dumpsys window windows</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">WINDOW MANAGER WINDOWS (dumpsys window windows)</span><br><span class="line">  Window #0 Window&#123;bdae67a u0 InputMethod&#125;:</span><br><span class="line">    mDisplayId=0 stackId=0 mSession=Session&#123;2b3f00f 19539:u0a10056&#125; mClient=android.os.BinderProxy@59092a5</span><br><span class="line">    mOwnerUid=10056 mShowToOwnerOnly=true package=com.baidu.input_yijia appop=NONE</span><br><span class="line">    mAttrs=&#123;(0,0)(fillxwrap) gr=BOTTOM CENTER_VERTICAL sim=&#123;adjust=pan&#125; ty=INPUT_METHOD fmt=TRANSPARENT wanim=0x1030056</span><br><span class="line">      fl=NOT_FOCUSABLE LAYOUT_IN_SCREEN SPLIT_TOUCH HARDWARE_ACCELERATED DRAWS_SYSTEM_BAR_BACKGROUNDS&#125;</span><br><span class="line">    Requested w=1080 h=2280 mLayoutSeq=207584</span><br><span class="line">    mIsImWindow=true mIsWallpaper=false mIsFloatingLayer=true mWallpaperVisible=false</span><br><span class="line">    mBaseLayer=141000 mSubLayer=0 mAnimLayer=0+=0 mLastLayer=0</span><br><span class="line">    mToken=WindowToken&#123;92f628b android.os.Binder@c12205a&#125;</span><br><span class="line">    mViewVisibility=0x8 mHaveFrame=true mObscured=false</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>可以列出当前系统中存在的所有窗口。查看下该命令的输出可以发现Android是一个同时存在着多个窗口的系统。比如 StatusBar、NavigationBar、Activity、InputMethod、WallPaper 等窗口都可能同时存在。因为同时有多个窗口各自为政，所以需要 WMS 作为管理者来协调，以便窗口们能在狭窄的显示屏幕上和睦相处。</p><p>作为协调者，WMS的本职工作主要是负责管理各窗口的生命周期（创建/销毁）、各窗口的位置大小（Layout）、各窗口的显示层级（Z-order）以及窗口的显示属性（可见性等）。</p><hr><h2 id="相关类"><a href="#相关类" class="headerlink" title="相关类"></a>相关类</h2><ul><li>DisplayContent：一个容器，一个 DisplayContent 内收集了所有需要显示到相应屏幕上的窗口</li><li>PhoneWindowManager：定义了 Phone 相关的窗口策略，负责为 WMS 提供各种建议，包括布局，事件处理，屏幕旋转等</li><li>WindowAnimator WindowStateAnimator AppWindowAnimator： 主要负责 Surface 相关操作，包括创建，销毁，Surface 属性变更，动画等</li><li>WindowToken AppWindowToken： WindowToken 的作用是将一组相关性紧密的窗口组织在一起。达到批量管理的效果</li><li>WindowState： 一般被认为是 WMS 眼中的窗口，管理着关联窗口的所有属性状态信息</li><li>AppWindowToken 根据 AMS 侧 Activity 的顺序有序排列，WindowState 根据 Layer 值有序排列。</li></ul><p><img src="displayContent.png" alt="Window分布"></p><h2 id="WMS添加窗口流程（addView）"><a href="#WMS添加窗口流程（addView）" class="headerlink" title="WMS添加窗口流程（addView）"></a>WMS添加窗口流程（addView）</h2><p>WindowManagerGlobal，是一个进程唯一的实例，也就是说无论在应用的任何角落调用addView，都会通过WindowManagerGlobal 来处理相应的请求。从理解出发，可以认为<code>WindowManagerGlobal</code>是一个App进程中窗口管理者。</p><p><img src="addview.png" alt="AddView简单流程"></p><figure class="highlight java"><figcaption><span>frameworks/base/core/java/android/view/WindowManagerImpl.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(@NonNull View view, @NonNull ViewGroup.LayoutParams params)</span> </span>&#123;</span><br><span class="line">    applyDefaultToken(params);</span><br><span class="line">    mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用WindowManagerGlobal的addView函数：</p><figure class="highlight java"><figcaption><span>frameworks/base/core/java/android/view/WindowManagerGlobal.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">     Display display, Window parentWindow) &#123;</span><br><span class="line">    <span class="keyword">if</span> (view == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"view must not be null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (display == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"display must not be null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!(params <span class="keyword">instanceof</span> WindowManager.LayoutParams)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Params must be WindowManager.LayoutParams"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> WindowManager.LayoutParams wparams = (WindowManager.LayoutParams) params;</span><br><span class="line">    <span class="keyword">if</span> (parentWindow != <span class="keyword">null</span>) &#123;</span><br><span class="line">        parentWindow.adjustLayoutParamsForSubWindow(wparams);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// If there's no parent, then hardware acceleration for this view is</span></span><br><span class="line">        <span class="comment">// set from the application's hardware acceleration setting.</span></span><br><span class="line">        <span class="keyword">final</span> Context context = view.getContext();</span><br><span class="line">        <span class="keyword">if</span> (context != <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; (context.getApplicationInfo().flags</span><br><span class="line">                        &amp; ApplicationInfo.FLAG_HARDWARE_ACCELERATED) != <span class="number">0</span>) &#123;</span><br><span class="line">            wparams.flags |= WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ViewRootImpl root;</span><br><span class="line">    View panelParentView = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="comment">// Start watching for system property changes.</span></span><br><span class="line">        <span class="keyword">if</span> (mSystemPropertyUpdater == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mSystemPropertyUpdater = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> i = mRoots.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">                            mRoots.get(i).loadSystemProperties();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            SystemProperties.addChangeCallback(mSystemPropertyUpdater);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = findViewLocked(view, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mDyingViews.contains(view)) &#123;</span><br><span class="line">                <span class="comment">// Don't wait for MSG_DIE to make it's way through root's queue.</span></span><br><span class="line">                mRoots.get(index).doDie();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"View "</span> + view</span><br><span class="line">                        + <span class="string">" has already been added to the window manager."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// The previous removeView() had not completed executing. Now it has.</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If this is a panel window, then find the window it is being</span></span><br><span class="line">        <span class="comment">// attached to for future reference.</span></span><br><span class="line">        <span class="keyword">if</span> (wparams.type &gt;= WindowManager.LayoutParams.FIRST_SUB_WINDOW &amp;&amp;</span><br><span class="line">                wparams.type &lt;= WindowManager.LayoutParams.LAST_SUB_WINDOW) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> count = mViews.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mRoots.get(i).mWindow.asBinder() == wparams.token) &#123;</span><br><span class="line">                    panelParentView = mViews.get(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//新疆一个ViewRootImpl对象，调用构造函数</span></span><br><span class="line">        root = <span class="keyword">new</span> ViewRootImpl(view.getContext(), display);</span><br><span class="line">        <span class="comment">//布局参数</span></span><br><span class="line">        view.setLayoutParams(wparams);</span><br><span class="line"></span><br><span class="line">        mViews.add(view);</span><br><span class="line">        mRoots.add(root);</span><br><span class="line">        mParams.add(wparams);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// do this last because it fires off messages to start doing things</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            root.setView(view, wparams, panelParentView); <span class="comment">//调用setView函数</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">            <span class="comment">// BadTokenException or InvalidDisplayException, clean up.</span></span><br><span class="line">            <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                removeViewLocked(index, <span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>setView做了很多处理，主要的是调用<code>requestLayout()和 mWindowSession.addToDisplay</code>。见下面：</p><h3 id="addWindow"><a href="#addWindow" class="headerlink" title="addWindow"></a>addWindow</h3><figure class="highlight java"><figcaption><span>frameworks/base/core/java/android/view/ViewRootImpl.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setView</span><span class="params">(View view, WindowManager.LayoutParams attrs, View panelParentView)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (mView == <span class="keyword">null</span>) &#123;</span><br><span class="line">               mView = view;</span><br><span class="line"></span><br><span class="line">               mAttachInfo.mDisplayState = mDisplay.getState();</span><br><span class="line">               mDisplayManager.registerDisplayListener(mDisplayListener, mHandler);</span><br><span class="line">               ......</span><br><span class="line">                 <span class="keyword">try</span> &#123;</span><br><span class="line">                   mOrigWindowType = mWindowAttributes.type;</span><br><span class="line">                   mAttachInfo.mRecomputeGlobalAttributes = <span class="keyword">true</span>;</span><br><span class="line">                   collectViewAttributes();</span><br><span class="line">                   <span class="comment">//添加到Display</span></span><br><span class="line">                   res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,</span><br><span class="line">                           getHostVisibility(), mDisplay.getDisplayId(), mTmpFrame,</span><br><span class="line">                           mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,</span><br><span class="line">                           mAttachInfo.mOutsets, mAttachInfo.mDisplayCutout, mInputChannel,</span><br><span class="line">                           mTempInsets);</span><br><span class="line">                   setFrame(mTmpFrame);</span><br><span class="line">               &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                   mAdded = <span class="keyword">false</span>;</span><br><span class="line">                   mView = <span class="keyword">null</span>;</span><br><span class="line">                   mAttachInfo.mRootView = <span class="keyword">null</span>;</span><br><span class="line">                   mInputChannel = <span class="keyword">null</span>;</span><br><span class="line">                   mFallbackEventHandler.setView(<span class="keyword">null</span>);</span><br><span class="line">                   unscheduleTraversals();</span><br><span class="line">                   setAccessibilityFocus(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Adding window failed"</span>, e);</span><br><span class="line">               &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                   <span class="keyword">if</span> (restore) &#123;</span><br><span class="line">                       attrs.restore();</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               .....</span><br></pre></td></tr></table></figure><p>这里出现了mWindowSession，它的类型是 IWindowSession，是WindowManagerGlobal#sWindowSession的一个引用，进程唯一的实例。</p><p>它是常见的Binder远程调用中IWindowSession的Bp端，Bn端是一个Sessio 实例，存在于WMS所属进程，Session代表了WMS关于窗口管理服务的一个子集，Android 系统中，由App进程端主动向WMS发起的请求，都是通过mWindowSession进行的，也就是说Session提供了所有App进程能够请求WMS的服务请求。</p><p>调用到实现类<code>Session.java</code>:</p><figure class="highlight java"><figcaption><span>frameworks/base/services/core/java/com/android/server/wm/Session.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addToDisplay</span><span class="params">(IWindow window, <span class="keyword">int</span> seq, WindowManager.LayoutParams attrs,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> viewVisibility, <span class="keyword">int</span> displayId, Rect outFrame, Rect outContentInsets,</span></span></span><br><span class="line"><span class="function"><span class="params">        Rect outStableInsets, Rect outOutsets,</span></span></span><br><span class="line"><span class="function"><span class="params">        DisplayCutout.ParcelableWrapper outDisplayCutout, InputChannel outInputChannel,</span></span></span><br><span class="line"><span class="function"><span class="params">        InsetsState outInsetsState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mService.addWindow(<span class="keyword">this</span>, window, seq, attrs, viewVisibility, displayId, outFrame,</span><br><span class="line">            outContentInsets, outStableInsets, outOutsets, outDisplayCutout, outInputChannel,</span><br><span class="line">            outInsetsState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终调用到<code>WMS.java</code>的addWindow函数。<strong>addWindow的工作可以分为4步：</strong></p><ul><li>WindowToken 检查</li><li>WindowState 创建</li><li>将新建的 WindowState 插入到现有的 WindowState 有序列表里</li><li>给系统中现有的所有 WindowState 重新分配 Layer</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addWindow</span><span class="params">(Session session, IWindow client, <span class="keyword">int</span> seq,</span></span></span><br><span class="line"><span class="function"><span class="params">            LayoutParams attrs, <span class="keyword">int</span> viewVisibility, <span class="keyword">int</span> displayId, Rect outFrame,</span></span></span><br><span class="line"><span class="function"><span class="params">            Rect outContentInsets, Rect outStableInsets, Rect outOutsets,</span></span></span><br><span class="line"><span class="function"><span class="params">            DisplayCutout.ParcelableWrapper outDisplayCutout, InputChannel outInputChannel,</span></span></span><br><span class="line"><span class="function"><span class="params">            InsetsState outInsetsState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] appOp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> res = mPolicy.checkAddPermission(attrs, appOp);</span><br><span class="line">        <span class="keyword">if</span> (res != WindowManagerGlobal.ADD_OKAY) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> reportNewConfig = <span class="keyword">false</span>;</span><br><span class="line">        WindowState parentWindow = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">long</span> origId;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> callingUid = Binder.getCallingUid();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> type = attrs.type;</span><br><span class="line">......</span><br></pre></td></tr></table></figure><h3 id="relayoutWindow"><a href="#relayoutWindow" class="headerlink" title="relayoutWindow"></a>relayoutWindow</h3><p><img src="relayoutwindow.png" alt="relayoutWindow处理流程"></p><p>Surface outSurface：输出参数，用于承载该窗口的 Surface，ViewRootImpl 获得此 Surface 便可以调用<code>Draw</code>在上面进行<strong>绘制窗口所承载的所有View</strong>。</p><p>关于 relayoutWindow 的处理内容粗略分为下列：</p><ul><li>根据传入参数更新 WindowState 对象的对应属性，这些属性都会在布局的时刻用到。</li><li>根据传入的可见性参数处理窗口 Surface 的创建或销毁</li><li>处理一些由窗口更新带来的一些变化，如 Focus 变化，输入法窗口/壁纸窗口移动，屏幕构型 Configuration 改变等</li><li>执行 performLayoutAndPlaceSurfaceLocked 函数进行布局</li></ul><h2 id="View概述"><a href="#View概述" class="headerlink" title="View概述"></a>View概述</h2><p><code>View</code>就是一块可以用来进行绘画，可以处理输入事件进行交互的矩形区域，而<code>ViewGroup</code>就是一种可以容纳View的矩形容器。</p><p>从设计模式的角度看，ViewGroup 和 View 是组合模式的典型应用。View 是基本的控件元素，ViewParent 接口定义了添加、删除 View 的接口 addView、removeView，ViewGroup 实现了 ViewParent 的接口，因此可以作为 View 的容器管理 View，同时 ViewGroup 又继承自 View，可以被其他的 ViewGroup 管理。这样 ViewGroup 和 View 就可以组成上面的树状结构了。</p><p><img src="viewgroup.png" alt="View和ViewGroup"></p><p>应用程序启动的过程中，会加载一个或者多个 Activity。每个 Activity 对应一个 PhoneWindow。当Activity在onCreate方法中调用 setContentView 的时候，PhoneWindow 会根据布局文件，创建 View 树，同时，根据应用的一些参数设置，得到集合了窗口显示特性的 View 树的根节点 mDecor 。WindowManagerGlobal 会通过数组记录一个应用程序对应的所有 View 树的根节点 mDecor，布局参数，以及对应的 ViewRootImpl。同时，将 mDecor 和布局参数传递给 ViewRootImpl。ViewRootImpl中实现对 View 树的整体控制，包括与 WMS 的通信，View 的描绘处理，输入事件的分发处理等。</p><p><strong>View 的结构图如下：</strong></p><p><img src="view_tree.png" alt="View关系图"></p><h3 id="基本元素"><a href="#基本元素" class="headerlink" title="基本元素"></a>基本元素</h3><ul><li>View ：最基本的UI组件，表示屏幕上的一个矩形区域</li><li>Window ：1〉 表示顶层窗口，管理界面的显示和事件的响应；2 〉每个Activity均会创建一个PhoneWindow对象，是Activity和整个View系统交互的接口。该Window在Activity的attach方法中通过调用<code>PolicyManager.makeNewWindow</code>创建；</li><li>DecorView ：是Window中view的RootView</li><li>WindowManager ：1〉 主要用来管理窗口的一些状态、属性、view 增加、删除、更新、窗口顺序、消息收集和处理等 2〉interface，继承自ViewManager。所在应用进程的窗口管理器；3〉实现类 WindowManagerImpl</li><li>ViewRootImpl：1 〉界面控制和消息响应；2 〉通过IWindowSession接口与全局窗口管理器WMS进行交互</li><li>ActivityThread：1〉 应用程序的主线程，其中会创建关联当前 Activity 与 Window；2〉创建 WindowManager 实现类实例，把当前 DecoView 加入到 WindowManager</li></ul><h3 id="View处理简单流程"><a href="#View处理简单流程" class="headerlink" title="View处理简单流程"></a>View处理简单流程</h3><h4 id="VSYNC"><a href="#VSYNC" class="headerlink" title="VSYNC"></a>VSYNC</h4><p>VSYNC 信号，即 vertical synchronization，可以理解为垂直同步，或者帧同步。是 Android4.1 为了解决 UI 不流畅问题而引入的处理。当需要同步信号的时候，通过 Choreographer 注册回调，等到 VSYNC信号到来的时候，执行相应的回调。这样，一方面可以避免频繁更新导致的画面不流程；另一方面，因为 SYNC 信号的频率大概是 60 次/秒，即可以保证帧率 60，显示效果非常平滑。</p><p><img src="vsync.png" alt="VSYNC"></p><p>由上图可见，View 的描绘工作，是在 performTraversals 中完成的。主要分为三步：</p><ol><li>performMeasure，负责计算View的尺寸；</li><li>performLayout，负责计算 View 在界面上的位置；</li><li>performDraw，根据前面两步的计算结果，完成实际的描绘工作。</li></ol><h3 id="performTraversals触发描绘处理"><a href="#performTraversals触发描绘处理" class="headerlink" title="performTraversals触发描绘处理"></a>performTraversals触发描绘处理</h3><p>View 的描绘是通过 performTraversals 发起的，所以任何调到 performTraversals 的地方，都会触发描绘处理。</p><ol><li>ViewRootImpl 中初次添加 View:自上而下发起遍历。</li><li>应用主动调用 requestLayout:自下而上通过 mParent 调用父节点的 requestLayout，直至 ViewRootImpl。</li><li>应用主动调用 invalidate:自下而上通过 mParent 调用父节点的 invalidateChild，直至 ViewRootImpl。</li><li>其他情况：如应用程序的 Visibility 发生变化的时候，LayoutParams 发生变化的时候等，都会触发遍历操作。</li></ol><h3 id="performMeasure（测量）"><a href="#performMeasure（测量）" class="headerlink" title="performMeasure（测量）"></a>performMeasure（测量）</h3><p><img src="performmeasure.png" alt="测量流程"></p><figure class="highlight java"><figcaption><span>frameworks/base/core/java/android/view/ViewRootImpl.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performMeasure</span><span class="params">(<span class="keyword">int</span> childWidthMeasureSpec, <span class="keyword">int</span> childHeightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mView == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class="string">"measure"</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>frameworks/base/core/java/android/view/View.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">measure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">boolean</span> optical = isLayoutModeOptical(<span class="keyword">this</span>);</span><br><span class="line">       <span class="keyword">if</span> (optical != isLayoutModeOptical(mParent)) &#123;</span><br><span class="line">           Insets insets = getOpticalInsets();</span><br><span class="line">           <span class="keyword">int</span> oWidth  = insets.left + insets.right;</span><br><span class="line">           <span class="keyword">int</span> oHeight = insets.top  + insets.bottom;</span><br><span class="line">           widthMeasureSpec  = MeasureSpec.adjust(widthMeasureSpec,  optical ? -oWidth  : oWidth);</span><br><span class="line">           heightMeasureSpec = MeasureSpec.adjust(heightMeasureSpec, optical ? -oHeight : oHeight);</span><br><span class="line">       &#125;</span><br><span class="line">       ......</span><br><span class="line">        <span class="keyword">if</span> (forceLayout || needsLayout) &#123;</span><br><span class="line">           <span class="comment">// first clears the measured dimension flag</span></span><br><span class="line">           mPrivateFlags &amp;= ~PFLAG_MEASURED_DIMENSION_SET;</span><br><span class="line"></span><br><span class="line">           resolveRtlPropertiesIfNeeded();</span><br><span class="line"></span><br><span class="line">           <span class="keyword">int</span> cacheIndex = forceLayout ? -<span class="number">1</span> : mMeasureCache.indexOfKey(key);</span><br><span class="line">           <span class="keyword">if</span> (cacheIndex &lt; <span class="number">0</span> || sIgnoreMeasureCache) &#123;</span><br><span class="line">               <span class="comment">// measure ourselves, this should set the measured dimension flag back</span></span><br><span class="line">               onMeasure(widthMeasureSpec, heightMeasureSpec);   <span class="comment">//调用onMeasure函数</span></span><br><span class="line">               mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">long</span> value = mMeasureCache.valueAt(cacheIndex);</span><br><span class="line">               <span class="comment">// Casting a long to int drops the high 32 bits, no mask needed</span></span><br><span class="line">               setMeasuredDimensionRaw((<span class="keyword">int</span>) (value &gt;&gt; <span class="number">32</span>), (<span class="keyword">int</span>) value);</span><br><span class="line">               mPrivateFlags3 |= PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// flag not set, setMeasuredDimension() was not invoked, we raise</span></span><br><span class="line">           <span class="comment">// an exception to warn the developer</span></span><br><span class="line">           <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_MEASURED_DIMENSION_SET) != PFLAG_MEASURED_DIMENSION_SET) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"View with id "</span> + getId() + <span class="string">": "</span></span><br><span class="line">                       + getClass().getName() + <span class="string">"#onMeasure() did not set the"</span></span><br><span class="line">                       + <span class="string">" measured dimension by calling"</span></span><br><span class="line">                       + <span class="string">" setMeasuredDimension()"</span>);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           mPrivateFlags |= PFLAG_LAYOUT_REQUIRED;</span><br><span class="line">       &#125;</span><br><span class="line">       ......</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">      setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),</span><br><span class="line">              getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="performLayout（布局）"><a href="#performLayout（布局）" class="headerlink" title="performLayout（布局）"></a>performLayout（布局）</h3><p><img src="performlayout.png" alt="布局流程"></p><h3 id="performDraw（硬件渲染）"><a href="#performDraw（硬件渲染）" class="headerlink" title="performDraw（硬件渲染）"></a>performDraw（硬件渲染）</h3><blockquote><p>performDraw调用draw，完成绘制工作。实际绘制操作可以分为硬件渲染和软件渲染两种情况。</p></blockquote><h4 id="Step1-ViewRootImpl-setView"><a href="#Step1-ViewRootImpl-setView" class="headerlink" title="Step1. ViewRootImpl.setView"></a>Step1. <code>ViewRootImpl.setView</code></h4><p>当mSurfaceHolder为空，也就是说应用不会要求自己接管对窗口的渲染的情况下，才会开始硬件渲染环境的准备。</p><p>Step2. ViewRootImpl.enableHardwareAcceleration</p><figure class="highlight java"><figcaption><span>frameworks/base/core/java/android/view/ViewRootImpl.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setView</span><span class="params">(View view, WindowManager.LayoutParams attrs, View panelParentView)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        ......</span><br><span class="line"><span class="comment">// If the application owns the surface, don't enable hardware acceleration</span></span><br><span class="line">              <span class="keyword">if</span> (mSurfaceHolder == <span class="keyword">null</span>) &#123;</span><br><span class="line">                  <span class="comment">// While this is supposed to enable only, it can effectively disable</span></span><br><span class="line">                  <span class="comment">// the acceleration too.</span></span><br><span class="line">                  enableHardwareAcceleration(attrs);</span><br><span class="line">                  <span class="keyword">final</span> <span class="keyword">boolean</span> useMTRenderer = MT_RENDERER_AVAILABLE</span><br><span class="line">                          &amp;&amp; mAttachInfo.mThreadedRenderer != <span class="keyword">null</span>;</span><br><span class="line">                  <span class="keyword">if</span> (mUseMTRenderer != useMTRenderer) &#123;</span><br><span class="line">                      <span class="comment">// Shouldn't be resizing, as it's done only in window setup,</span></span><br><span class="line">                      <span class="comment">// but end just in case.</span></span><br><span class="line">                      endDragResizing();</span><br><span class="line">                      mUseMTRenderer = useMTRenderer;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br></pre></td></tr></table></figure><ol><li>常驻内存的进程，禁止使用硬件加速，因为非常耗费内存。</li><li>系统进程一般都要禁用硬件加速，但是以下两种情况除外：</li></ol><p>(1) 应用启动之前的<code>Starting Window</code>，会通过设置以下flag，<strong>标示启用硬件加速</strong>，但是不缓存：</p><p><code>WindowManager.LayoutParams.PRIVATE_FLAG_FAKE_HARDWARE_ACCELERATED</code></p><p>(2) 锁屏界面，虽然是在系统进程中，但是通过设置以下 flag，可以启用硬件加速：</p><p><code>WindowManager.LayoutParams.PRIVATE_FLAG_FORCE_HARDWARE_ACCELERATED</code></p><p>其他情况，根据 Activity 窗口是否请求硬件加速渲染决定是否开启硬件加速。通过判断flags位</p><p><code>WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED</code>被置为1，同时硬件支持硬件加速，就可以继续后面的初始化工作了。</p><h4 id="Step3-ThreaedRenderer-create"><a href="#Step3-ThreaedRenderer-create" class="headerlink" title="Step3: ThreaedRenderer.create"></a>Step3: ThreaedRenderer.create</h4><p>设备支持 Open GL ES2.0，就创建对象：ThreadedRender。</p><ol><li>通过 nCreateRootRenderNode 在 Native 层创建一个 Render Node。</li><li>通过 adopt 方法，将 Native 层的 Render Node 封装成 Java 层的 Render Node。</li><li>通过 nCreateProxy 在 Native 层创建一个 Render Proxy 对象。该proxy对象以后负责从Main Thread向RenderThread发送命令。</li></ol><p>RenderProxy 有三个重要的成员变量：</p><ol><li>mRenderThread：进程单例，指向 RenderThread 对象，通过它可以向 RenderThread 线程发送命令。</li><li>mContext：画布上下文。RenderThread 通过它完成渲染工作。</li><li>mDrawFrameTask：指向一个 DrawFrameTask 对象，Main thread 通过它向 Render Thread 线程发送渲染下一帧的命令。</li></ol><h4 id="Step4：ViewRootImpl-performTraversals"><a href="#Step4：ViewRootImpl-performTraversals" class="headerlink" title="Step4：ViewRootImpl.performTraversals"></a>Step4：ViewRootImpl.performTraversals</h4><p>当得到了有效的surface，就通过ThreadedRender的initialize方法，将该surface与RenderThread绑定。</p><h4 id="硬件渲染流程图"><a href="#硬件渲染流程图" class="headerlink" title="硬件渲染流程图"></a>硬件渲染流程图</h4><p><img src="hardware_render.png" alt="硬件渲染流程"></p><p><strong>ThreadedRender.draw主要执行三个操作：</strong></p><ol><li>调用成员函数 updateRootDisplayList 构建或者更新应用程序窗口的 Root Render Node 的 DisplayList。<strong>RenderNode.start 和 RenderNode.end 直接的处理，与软件渲染的流程一样，只是硬件渲染的时候，只把渲染命令存储到 DisplayList 中，并不真正开始执行渲染操作。</strong></li><li>调用成员函数 registerAnimationRenderNode 注册应用程序窗口动画相关的 Render Node 到 native 层。这些RenderNode是用于描述当前窗口设置的动画。</li><li>调用成员函数 nSyncAndDrawFrame，通知Render Thread绘制下一帧。其具体实现在 navtive 层。通DrawFrameTask 向 RenderThread 的 task Queue 抛出一个消息，等待 RenderThread 在合适的时候唤醒。</li></ol><hr><h3 id="软件渲染"><a href="#软件渲染" class="headerlink" title="软件渲染"></a>软件渲染</h3><p>在 ViewRootImpld 的 draw()如果不进行硬件渲染，会进行软件渲染<code>drawSoftware()</code></p><h4 id="Step1-ViewRootImpl-Draw"><a href="#Step1-ViewRootImpl-Draw" class="headerlink" title="Step1. ViewRootImpl.Draw"></a>Step1. ViewRootImpl.Draw</h4><ol><li>计算窗口是否处于滚动状态。</li><li>计算 dirty 区域，也就是需要重绘的区域。</li><li>Dirty 区域不为空，或者动画进行中，继续判断是否选择了硬件加速，如果没有使用硬件加速，则通过 drawSoftware（）发起软件渲染。</li><li>如果动画执行过程中，发起下一次轮询。</li></ol><figure class="highlight java"><figcaption><span>frameworks/base/core/java/android/view/ViewRootImpl.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">draw</span><span class="params">(<span class="keyword">boolean</span> fullRedrawNeeded)</span> </span>&#123;</span><br><span class="line">     Surface surface = mSurface;</span><br><span class="line">     ......</span><br><span class="line">             <span class="keyword">if</span> (!drawSoftware(surface, mAttachInfo, xOffset, yOffset,</span><br><span class="line">                     scalingRequired, dirty, surfaceInsets)) &#123;</span><br><span class="line">                 <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             ......</span><br></pre></td></tr></table></figure><h4 id="Step2-ViewRootImlp-drawSoftware"><a href="#Step2-ViewRootImlp-drawSoftware" class="headerlink" title="Step2. ViewRootImlp.drawSoftware"></a>Step2. ViewRootImlp.drawSoftware</h4><p>通过 lockCanvas()获取画布。</p><h4 id="Step3-Framelayout-draw-Canvas"><a href="#Step3-Framelayout-draw-Canvas" class="headerlink" title="Step3. Framelayout.draw(Canvas)"></a>Step3. Framelayout.draw(Canvas)</h4><p>ViewRootImpl 中，通过 mView.draw(canvas)，调用 DecorView 的 draw 方法；DecorView 通过 super.draw(canvas)，调用父类 Framlayout 的 Draw 方法。</p><p>在 FrameLayout 中，通过 super.draw(canvas)方法，调用 View.draw 方法，触发实际的描绘处理。</p><h4 id="Step4-View-draw"><a href="#Step4-View-draw" class="headerlink" title="Step4. View.draw"></a>Step4. View.draw</h4><ol><li>描绘背景。如果 PFLAG_DIRTY_OPAQUE 被设置，并且 mAttachInfo.mIgnoreDirtyState=flase，说明有不透明子view遮挡了当前的 view，不需要绘制背景。</li><li>保存当前画布的堆栈状态，并且创建额外的图层描绘当前视图滑动时的边框渐变效果。FADING_EDGE_VERTICAL 和FADING_EDGE_HORIZONTAL 都没有被设置的时候，不需要执行这步操作。</li><li>通过 onDraw 调用子类描绘处理，完成当前视图的描绘。</li><li>通过 dispatchDraw 调用子视图的描绘处理。</li><li>绘制边框的渐变效果（与步骤 2 对应），并且恢复图层。此步骤不是必需的。</li><li>如果需要显示滚动条，通过 onDrawScrollBars 调用描绘滚动条。</li></ol><h4 id="Step5-ViewGroup-dispatchDraw"><a href="#Step5-ViewGroup-dispatchDraw" class="headerlink" title="Step5. ViewGroup.dispatchDraw"></a>Step5. ViewGroup.dispatchDraw</h4><ol><li><code>FLAG_RUN_ANIMATION</code>被设置，并且允许显示子视图的动画，则通过 bindLayoutAnimation 设置动画。设置完成后，通过LayoutAnimationController 的对象来启动动画，并且调用 mAnimationListener 的 onAnimationStart()来通知动画监听，当前视图开始显示动画了。</li><li>如果子视图可见或者有动画需要显示，就通过方法 drawChild 实现子视图的绘制。</li><li>如果动画结束，通过notifyAnimationListener发送消息，通知动画监听者，动画已经结束。</li></ol><h4 id="Step6-ViewGroup-drawChild"><a href="#Step6-ViewGroup-drawChild" class="headerlink" title="Step6. ViewGroup.drawChild"></a>Step6. ViewGroup.drawChild</h4><p>调用子 view 的 draw(Canvas, ViewGroup,long)方法，实现子视图的绘制。</p><h4 id="Step7-View-draw-Canvas-ViewGroup-long"><a href="#Step7-View-draw-Canvas-ViewGroup-long" class="headerlink" title="Step7. View.draw(Canvas, ViewGroup, long)"></a>Step7. View.draw(Canvas, ViewGroup, long)</h4><ol><li>通过方法<code>drawAnimation</code>实现动画的绘制。</li><li>通过flag检查子视图是否支持缓冲方式绘制。即将子视图缓冲到一个Bitmap中，后续可以通过getDrawingCache获得该bitmap。</li><li>以非缓冲的方式绘制：检查 SKIP_DRAW 标记是否被置位，如果为 1，则跳过当前视图的绘制，调用 ViewGroup 的dispatchDraw，重复前面过程，继续该视图的子视图的绘制；否则，通过调用 View.draw(Canvas)，重复 step4 的过程，完成当前视图的绘制以后，再发起子视图的绘制。</li><li>以缓冲的方式绘制：通过 canvas.drawBitmap()将上次缓冲的 Bitmap 对象 cache 绘制到画布上。</li></ol><h4 id="Step8-ViewRootImpl-drawSoftware"><a href="#Step8-ViewRootImpl-drawSoftware" class="headerlink" title="Step8. ViewRootImpl.drawSoftware"></a>Step8. ViewRootImpl.drawSoftware</h4><p>循环上面的过程，直到所有子视图都被绘制到画布上，返回 drawSoftware 方法。</p><p>通过 surface.unlockCanvasAndPost()方法，请求 SurfaceFlinger 服务渲染这块画布到图形缓冲区。</p><h4 id="软件渲染流程图"><a href="#软件渲染流程图" class="headerlink" title="软件渲染流程图"></a>软件渲染流程图</h4><p><img src="software_render.png" alt="软件渲染流程图"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Window 可以看做是Surface的一个包装，本质上，Window的本体就是一片Surface。将操作对象Surface，对象关联属性集以及操作方法等组合在一起便是 Window。Surface 其实是一块画布，应用可以随心所欲地通过 Canvas 或者 OpenGL 在其上作画，然后通过 SurfaceFlinger 将多块 Surface 的内容按照特定的顺序(ZOrder)进行混合并输出到 FrameBuffer，从而将 Android 漂亮的脸蛋显示给用户。既然每个窗口都有一块 Surface 供自己涂鸦，所以必然需要一个角色对所有窗口的 Surface 进行协调管理。于是,WMS 应运而生。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;代码： &lt;a href=&quot;http://aosp.opersys.com/xref/android-10.0.0_r2/xref/frameworks/base/core/java/android/view/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://aosp.opersys.com/xref/android-10.0.0_r2/xref/frameworks/base/core/java/android/view/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="android" scheme="http://wizzie.top/categories/android/"/>
    
    
      <category term="graphics" scheme="http://wizzie.top/tags/graphics/"/>
    
  </entry>
  
  <entry>
    <title>C++ 运算符重载、友元、返回对象</title>
    <link href="http://wizzie.top/2019/09/16/2019/190916_cpp_useclass/"/>
    <id>http://wizzie.top/2019/09/16/2019/190916_cpp_useclass/</id>
    <published>2019-09-16T14:59:00.000Z</published>
    <updated>2020-03-08T10:14:08.790Z</updated>
    
    <content type="html"><![CDATA[<h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><p>运算符重载将重载的概念扩展到运算符上，允许赋予C++运算符多种含义。</p><p>例如<code>*</code> 用于地址，将获得存储在这个地址中的值；而用于两个数字之间，得到的是乘积。</p><a id="more"></a><p>要重载运算符，可以使用被称为运算符函数的特殊函数形式，运算符函数的格式如下：<br><code>operator(argument-list)</code></p><p>例如<code>operator+()</code>重载<code>+</code>运算符，<code>operator*()</code>重载*运算符。op必须是有效的运算符，不能虚构新的符号。比如不存在<code>operator@()</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Time Time::<span class="keyword">operator</span>+(<span class="keyword">const</span> Time &amp;t) <span class="keyword">const</span> &#123;</span><br><span class="line">    Time sum;</span><br><span class="line">    sum.minutes = minutes + t.minutes;</span><br><span class="line">    sum.hours = hours + t.hours + sum.minutes / <span class="number">60</span>;</span><br><span class="line">    sum.minutes %= <span class="number">60</span>;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重载限制"><a href="#重载限制" class="headerlink" title="重载限制"></a>重载限制</h3><ol><li>重载后的运算符必须至少有一个操作数是用户定义的类型。防止用户为标准类型重载运算符。即不能用减法运算符重载求和，会影响性能。</li><li>使用运算符不能违反运算符原来的句法规则。例如不能将求模（余数）运算符重载成使用一个操作数：</li></ol><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">- int x;</span></span><br><span class="line"><span class="deletion">- % x;  //Error</span></span><br></pre></td></tr></table></figure><p>同时不能修改运算符的优先级。</p><ol start="3"><li>不能创建新运算符，例如不能定义<code>operator**()</code>函数来表示求幂。</li><li><strong>不能重载以下运算符：</strong></li></ol><table><thead><tr><th align="center">运算符</th><th align="center">释义</th></tr></thead><tbody><tr><td align="center">sizeof</td><td align="center">sizeof求长度运算符</td></tr><tr><td align="center">.</td><td align="center">成员运算符</td></tr><tr><td align="center">.*</td><td align="center">成员指针运算符</td></tr><tr><td align="center">::</td><td align="center">作用域解析运算符</td></tr><tr><td align="center">?</td><td align="center">条件运算符</td></tr><tr><td align="center">typeid</td><td align="center">一个RTTI运算符</td></tr><tr><td align="center">const_cast</td><td align="center">强制类型转换运算符</td></tr><tr><td align="center">dynamic_cast</td><td align="center">强制类型转换运算符</td></tr><tr><td align="center">reinterpret_cast</td><td align="center">强制类型转换运算符</td></tr><tr><td align="center">static_cast</td><td align="center">强制类型转换运算符</td></tr></tbody></table><hr><h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><blockquote><p>C++控制对类对象私有部分的访问，通常公有类提供唯一的访问途径，但是有时候限制太严格，以致于不适合特定的编程情形。因而C++提供另一种形式的访问权限：<strong>友元</strong> ， 有三种：</p></blockquote><ol><li>友元函数</li><li>友元类</li><li>友元成员函数（通过让函数成为类的友元，可以赋予该函数与类的成员函数相同的访问权限。）</li></ol><p>在为类重载二元运算符时常常需要友元。</p><h3 id="创建友元"><a href="#创建友元" class="headerlink" title="创建友元"></a>创建友元</h3><p>将原型放在类声明中，并在原型声明前加上关键字<code>friend</code>。</p><p><code>friend Time operator* (double m, const Time &amp;t);//goes in class declaration</code></p><p>表明两点：</p><ol><li>虽然是在类声明中声明，但不是成员函数，因此不能使用成员运算符调用（.或者-&gt;），不能使用<code>Time::</code>限定符</li><li>虽然不是成员函数，但是和成员函数的访问权限相同</li></ol><blockquote><p>在函数实现中不要使用关键字friend</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Time <span class="keyword">operator</span>*(<span class="keyword">double</span> m, <span class="keyword">const</span> Time &amp;t) &#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="返回对象相关"><a href="#返回对象相关" class="headerlink" title="返回对象相关"></a>返回对象相关</h2><p>当成员函数或独立的函数返回对象时，有几种返回方式可供选择，<code>可以返回指向对象的引用、指向对象的const引用或const对象</code>。</p><h3 id="返回指向const对象的引用"><a href="#返回指向const对象的引用" class="headerlink" title="返回指向const对象的引用"></a>返回指向const对象的引用</h3><p>使用const引用的常见原因是极高效率，但是对何时可以采用这种方式存在限制。如果函数返回（通过调用对象的方法或者将对象作为参数）传递给他的对象，可以通过返回引用来提高效率。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Vector <span class="title">force1</span><span class="params">(<span class="number">50</span>, <span class="number">60</span>)</span></span>;</span><br><span class="line"><span class="function">Vector <span class="title">force2</span><span class="params">(<span class="number">10</span>, <span class="number">70</span>)</span></span>;</span><br><span class="line">Vector <span class="built_in">max</span>;</span><br><span class="line"><span class="built_in">max</span> = Max(force1, force2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//version 1  </span></span><br><span class="line"><span class="comment">//返回对象将调用复制构造函数</span></span><br><span class="line"><span class="function">Vector <span class="title">Max</span><span class="params">(<span class="keyword">const</span> Vector &amp; v1, <span class="keyword">const</span> Vector &amp; v2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (v1.magval() &gt; v2.magval())</span><br><span class="line">        <span class="keyword">return</span> v1;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> v2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//version 2 </span></span><br><span class="line"><span class="comment">//返回引用不会调用构造函数，因而效率更高；</span></span><br><span class="line"><span class="comment">//其次引用指向的对象在调用函数时存在（此处的force1和force2在调用函数中定义，满足条件）；</span></span><br><span class="line"><span class="comment">//v1和v2都被声明为const引用，因此返回类型必须是const，这样才匹配</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> Vector &amp; <span class="title">Max</span><span class="params">(<span class="keyword">const</span> Vector &amp; v1, <span class="keyword">const</span> Vector &amp; v2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (v1.magval() &gt; v2.magval())</span><br><span class="line">        <span class="keyword">return</span> v1;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="返回指向非const对象的引用"><a href="#返回指向非const对象的引用" class="headerlink" title="返回指向非const对象的引用"></a>返回指向非const对象的引用</h3><p>两种常见的返回非const对象的情形：</p><ol><li>重载赋值运算符（旨在提高效率）</li><li>重载与const一起使用的<code>&lt;&lt;</code>运算符（必须这么做）</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//operator=()的返回值用于连续赋值</span></span><br><span class="line"><span class="function"><span class="keyword">String</span> <span class="title">s1</span><span class="params">(<span class="string">"Good stuff"</span>)</span></span>;</span><br><span class="line"><span class="keyword">String</span> s2,s3;</span><br><span class="line">s3 = s2 = s1; <span class="comment">//s2.operator=()的返回值被赋值给s3，通过使用引用可以避免该函数调用String的复制构造函数来创建一个新的String对象</span></span><br></pre></td></tr></table></figure><p>在这个例子中，返回类型不是const，因为方法operator=()返回一个指向s2的引用，可以对其进行修改。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">String</span> <span class="title">s1</span><span class="params">(<span class="string">"Good"</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s1 &lt;&lt; <span class="string">"is coming"</span>;</span><br></pre></td></tr></table></figure><p>在这个例子中，返回类型必须是ostream&amp; ，而不能仅是ostream，否则将调用ostream类的复制构造函数，而ostream没有共有的复制构造函数。</p><h3 id="返回对象"><a href="#返回对象" class="headerlink" title="返回对象"></a>返回对象</h3><p>如果返回的对象是被调用函数中的局部变量，则不应使用引用方式返回它。因为在被调用函数执行完毕，局部对象将调用其析构函数。</p><hr><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><h3 id="指针和对象使用"><a href="#指针和对象使用" class="headerlink" title="指针和对象使用"></a>指针和对象使用</h3><ol><li>使用常规表示法来声明指向已有的对象，<code>String * glamour;</code></li><li>可以将指针初始化为指向已有的对象，<code>String * first = &amp;sayings[0];</code></li><li>可以使用new来初始化指针，这将会创建一个新的对象，<code>String * favorite = new String(sayings[choice]);</code></li><li>对类使用new将调用相应的构造函数来初始化新建的对象</li><li>可以使用<code>-&gt;</code>运算符通过指针访问类的方法，<code>shortest-&gt;length()</code></li><li>可以对对象的指针应用解除引用运算符<code>*</code>来获得对象，’if (sayings[i] &lt; *first&gt;)’</li></ol><h3 id="重载-lt-lt-运算符"><a href="#重载-lt-lt-运算符" class="headerlink" title="重载&lt;&lt;运算符"></a>重载&lt;&lt;运算符</h3><p>要重新定义&lt;&lt;运算符，以便将他和cout一起用来显示对象的内容，请定义下面的友元运算符函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//c_name是类名，如果该类提供了能够返回所需内容的公有方法，则可在运算符函数中使用这些方法，这样编不用将他们设置为友元函数</span></span><br><span class="line">ostream &amp; <span class="keyword">operator</span>&lt;&lt; (ostream &amp;os, <span class="keyword">const</span> c_name &amp; obj) &#123;</span><br><span class="line">    os &lt;&lt; ...; <span class="comment">//display object contents</span></span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="转换函数"><a href="#转换函数" class="headerlink" title="转换函数"></a>转换函数</h3><p>要将单个值转换为类类型，需要创建原型如下所示的类构造函数：<code>c_name(type_name value)</code></p><p>其中c_name是类名，type_name是要转换的类型的名称。</p><p>要将类转换为其他类型，需要创建类如下所示的类成员函数:<code>operator type_name();</code></p><p>虽然该函数没有声明返回类型，但应返回所需类型的值。使用转换函数时，可以在声明构造函数中使用关键字<code>explicit</code>，放置它被用于隐式转换。</p><h3 id="其构造函数使用new的类"><a href="#其构造函数使用new的类" class="headerlink" title="其构造函数使用new的类"></a>其构造函数使用new的类</h3><ul><li>对于指向的内存是由new分配的所有类成员，都应在类的析构函数中对其使用delete，该运算符将释放分配的内存</li><li>如果析构函数通过对指针类成员使用delete来释放内存，则每个构造函数都应当使用new来初始化指针，或将其设置为空指针</li><li>构造函数中要么使用new，要么使用new[]，不能混用。对应的析构函数使用delete，和delete[]</li><li>应定义一个分配内存的复制构造函数，这样程序能够将类对象初始化为另一个类对象，通常的函数原型：<code>className(const className &amp;)</code></li><li>应定一个重载赋值运算符的类成员函数，其函数定义如下:</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">c_name &amp; c_name::<span class="keyword">operator</span>=(<span class="keyword">const</span> c_name &amp; cn) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;cn)</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">delete</span> [] c_pointer; <span class="comment">//是c_name的类成员，是指向type_name的指针</span></span><br><span class="line">    <span class="comment">//set size number of type_name unite to be copied</span></span><br><span class="line">    c_pointer = <span class="keyword">new</span> type_name[<span class="built_in">size</span>];</span><br><span class="line">    <span class="comment">//then copy data pointed to by cn.c_pointer to location pointed to by c_pointer</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="Share一个Ubuntu免费使用ultraEdit的方法"><a href="#Share一个Ubuntu免费使用ultraEdit的方法" class="headerlink" title="Share一个Ubuntu免费使用ultraEdit的方法"></a><code>Share</code>一个Ubuntu免费使用ultraEdit的方法</h2><p>在bin目录下建立一个脚本，并且在打开软件前执行：</p><figure class="highlight shell"><figcaption><span>uexClearCache.sh </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rm -rfd ~/.idm/uex  </span><br><span class="line">rm -rf ~/.idm/*.spl  </span><br><span class="line">rm -rf /tmp/*.spl</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;运算符重载&quot;&gt;&lt;a href=&quot;#运算符重载&quot; class=&quot;headerlink&quot; title=&quot;运算符重载&quot;&gt;&lt;/a&gt;运算符重载&lt;/h2&gt;&lt;p&gt;运算符重载将重载的概念扩展到运算符上，允许赋予C++运算符多种含义。&lt;/p&gt;
&lt;p&gt;例如&lt;code&gt;*&lt;/code&gt; 用于地址，将获得存储在这个地址中的值；而用于两个数字之间，得到的是乘积。&lt;/p&gt;
    
    </summary>
    
    
      <category term="cpp" scheme="http://wizzie.top/categories/cpp/"/>
    
    
      <category term="cpp" scheme="http://wizzie.top/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>Android zygote和SystemServer进程</title>
    <link href="http://wizzie.top/2019/09/10/2019/190910_android_zygote_systemserver/"/>
    <id>http://wizzie.top/2019/09/10/2019/190910_android_zygote_systemserver/</id>
    <published>2019-09-10T14:52:00.000Z</published>
    <updated>2020-03-08T10:14:08.790Z</updated>
    
    <content type="html"><![CDATA[<p>zygote和system_server在Android中的Java层很重要。</p><h2 id="zygote分析"><a href="#zygote分析" class="headerlink" title="zygote分析"></a>zygote分析</h2><blockquote><p>zygote由init进程根据init.rc的配置项创建的。最初叫<code>app_process</code>，但是在运行过程中，通过Linux的pctrl系统调用将其换成了<code>zygote</code>。通过<code>adb shell ps -ef|grep zygote</code>查看到该进程。</p></blockquote><a id="more"></a><p>Android-10.0.0_r2 AOSP源码中，查看其入口函数：</p><figure class="highlight c++"><figcaption><span>frameworks/base/cmds/app_process/app_main.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* <span class="keyword">const</span> argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!LOG_NDEBUG) &#123;</span><br><span class="line">      String8 argv_String;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; argc; ++i) &#123;</span><br><span class="line">        argv_String.append(<span class="string">"\""</span>);</span><br><span class="line">        argv_String.append(argv[i]);</span><br><span class="line">        argv_String.append(<span class="string">"\" "</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      ALOGV(<span class="string">"app_process main with argv: %s"</span>, argv_String.<span class="built_in">string</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">AppRuntime <span class="title">runtime</span><span class="params">(argv[<span class="number">0</span>], computeArgBlockSize(argc, argv))</span></span>;</span><br><span class="line">    <span class="comment">// Process command line arguments</span></span><br><span class="line">    <span class="comment">// ignore argv[0]</span></span><br><span class="line">    argc--;</span><br><span class="line">    argv++;</span><br><span class="line">......</span><br><span class="line">    <span class="keyword">if</span> (zygote) &#123;</span><br><span class="line">        runtime.start(<span class="string">"com.android.internal.os.ZygoteInit"</span>, args, zygote);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (className) &#123;</span><br><span class="line">        runtime.start(<span class="string">"com.android.internal.os.RuntimeInit"</span>, args, zygote);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error: no class name or --zygote supplied.\n"</span>);</span><br><span class="line">        app_usage();</span><br><span class="line">        LOG_ALWAYS_FATAL(<span class="string">"app_process: no class name or --zygote supplied."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重要的功能由AppRuntime的start函数完成。而AppRuntime类就在app_main.cpp中，从AndroidRuntime派生而来。</p><figure class="highlight c++"><figcaption><span>frameworks/base/core/jni/AndroidRuntime.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AndroidRuntime::start</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* className, <span class="keyword">const</span> Vector&lt;String8&gt;&amp; options, <span class="keyword">bool</span> zygote)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ALOGD(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt; START %s uid %d &lt;&lt;&lt;&lt;&lt;&lt;\n"</span>,</span><br><span class="line">            className != <span class="literal">NULL</span> ? className : <span class="string">"(unknown)"</span>, getuid());</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">const</span> String8 <span class="title">startSystemServer</span><span class="params">(<span class="string">"start-system-server"</span>)</span></span>;</span><br><span class="line">......</span><br><span class="line">    <span class="comment">/* start the virtual machine */</span></span><br><span class="line">    JniInvocation jni_invocation;</span><br><span class="line">    jni_invocation.Init(<span class="literal">NULL</span>);</span><br><span class="line">    JNIEnv* env;</span><br><span class="line">    <span class="keyword">if</span> (startVm(&amp;mJavaVM, &amp;env, zygote) != <span class="number">0</span>) &#123;    <span class="comment">//创建虚拟机</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    onVmCreated(env);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Register android functions.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (startReg(env) &lt; <span class="number">0</span>) &#123;    <span class="comment">//注册JNI函数</span></span><br><span class="line">        ALOGE(<span class="string">"Unable to register all android natives\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">.....</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Start VM.  This thread becomes the main thread of the VM, and will</span></span><br><span class="line"><span class="comment">     * not return until the VM exits.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">char</span>* slashClassName = toSlashClassName(className != <span class="literal">NULL</span> ? className : <span class="string">""</span>);</span><br><span class="line">    jclass startClass = env-&gt;FindClass(slashClassName);</span><br><span class="line">    <span class="keyword">if</span> (startClass == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"JavaVM unable to locate class '%s'\n"</span>, slashClassName);</span><br><span class="line">        <span class="comment">/* keep going */</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        jmethodID startMeth = env-&gt;GetStaticMethodID(startClass, <span class="string">"main"</span>,</span><br><span class="line">            <span class="string">"([Ljava/lang/String;)V"</span>);</span><br><span class="line">        <span class="keyword">if</span> (startMeth == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            ALOGE(<span class="string">"JavaVM unable to find main() in '%s'\n"</span>, className);</span><br><span class="line">            <span class="comment">/* keep going */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            env-&gt;CallStaticVoidMethod(startClass, startMeth, strArray);   <span class="comment">//通过JNI调用Java中ZygoteInit的main函数，进入Java世界</span></span><br><span class="line"></span><br><span class="line">......</span><br></pre></td></tr></table></figure><h3 id="创建虚拟机startVM"><a href="#创建虚拟机startVM" class="headerlink" title="创建虚拟机startVM"></a>创建虚拟机startVM</h3><blockquote><p>该函数调用JNI的Dalvik虚拟机创建函数，在sdtartVM中确定创建虚拟机的一些参数</p></blockquote><h3 id="注册JNI函数-startReg"><a href="#注册JNI函数-startReg" class="headerlink" title="注册JNI函数 startReg"></a>注册JNI函数 startReg</h3><blockquote><p>给虚拟机注册一些JNI函数，采用native方式实现。</p></blockquote><h3 id="java入口-CallStaticVoidMethod"><a href="#java入口-CallStaticVoidMethod" class="headerlink" title="java入口 CallStaticVoidMethod"></a>java入口 CallStaticVoidMethod</h3><blockquote><p>CallStaticVoidMethod最终调用<code>frameworks/base/core/java/com/android/internal/os/ZygoteInit.java</code>的main函数。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    @UnsupportedAppUsage</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span> argv[])</span> </span>&#123;</span><br><span class="line">        ZygoteServer zygoteServer = null;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Mark zygote start. This ensures that thread creation will throw</span></span><br><span class="line">        <span class="comment">// an error.</span></span><br><span class="line">        ZygoteHooks.startZygoteNoThreadCreation();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Zygote goes into its own process group.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Os.setpgid(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ErrnoException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Failed to setpgid(0,0)"</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Runnable caller;</span><br><span class="line">......</span><br><span class="line">  <span class="keyword">if</span> (startSystemServer) &#123;    <span class="comment">//启动system_server</span></span><br><span class="line">                Runnable r = forkSystemServer(abiList, zygoteSocketName, zygoteServer);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// &#123;@code r == null&#125; in the parent (zygote) process, and &#123;@code r != null&#125; in the</span></span><br><span class="line">                <span class="comment">// child (system_server) process.</span></span><br><span class="line">                <span class="keyword">if</span> (r != null) &#123;</span><br><span class="line">                    r.<span class="built_in">run</span>();</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p><code>forkSystemServer</code>会创建java世界中系统service所驻留的进程system_server，该进程是framework的核心。</p><hr><h2 id="SystemServer"><a href="#SystemServer" class="headerlink" title="SystemServer"></a>SystemServer</h2><p>SystemServer的进程名叫做<code>system_server</code>，由zygote进程中创建。</p><p><code>forkSystemServer</code>函数中调用<code>handleSystemServerProcess()来处理自己的事务</code>。</p><p>调用到systemserver的main函数。</p><figure class="highlight c++"><figcaption><span>frameworks/base/services/java/com/android/server/SystemServer.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The main entry point from zygote.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">String</span>[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> SystemServer().<span class="built_in">run</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SystemServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Check for factory test mode.</span></span><br><span class="line">    mFactoryTestMode = FactoryTest.getMode();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Record process start information.</span></span><br><span class="line">    <span class="comment">// Note SYSPROP_START_COUNT will increment by *2* on a FDE device when it fully boots;</span></span><br><span class="line">    <span class="comment">// one for the password screen, second for the actual boot.</span></span><br><span class="line">    mStartCount = SystemProperties.getInt(SYSPROP_START_COUNT, <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">    mRuntimeStartElapsedTime = SystemClock.elapsedRealtime();</span><br><span class="line">    mRuntimeStartUptime = SystemClock.uptimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remember if it's runtime restart(when sys.boot_completed is already set) or reboot</span></span><br><span class="line">    <span class="comment">// We don't use "mStartCount &gt; 1" here because it'll be wrong on a FDE device.</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> mRuntimeRestart will *not* be set to true if the proccess crashes before</span></span><br><span class="line">    <span class="comment">// sys.boot_completed is set. Fix it.</span></span><br><span class="line">    mRuntimeRestart = <span class="string">"1"</span>.equals(SystemProperties.<span class="built_in">get</span>(<span class="string">"sys.boot_completed"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随后会创建一些系统服务，并将调用线程加入到Binder通信中。并且会创建一个单独的线程，用以启动系统的各项服务，例如电池管理服务BatteryService，电源管理服务PowerManagerService，StartWindowManagerService，ActivityManagerService等等。</p><h2 id="开机耗时长的原因"><a href="#开机耗时长的原因" class="headerlink" title="开机耗时长的原因"></a>开机耗时长的原因</h2><ol><li>ZygoteInit的main函数中的preloadClasses加载了上千个类</li><li>开机启动时会对系统所有的APK扫描并收集信息</li><li>SystemServer创建的一系列service，占用不少时间</li></ol><h2 id="虚拟机heapsize的限制"><a href="#虚拟机heapsize的限制" class="headerlink" title="虚拟机heapsize的限制"></a>虚拟机heapsize的限制</h2><p>zygote创建虚拟机的时候，系统默认设置的java虚拟机堆栈值（可修改）对于使用较大内存的程序远远不够。zygote通过fork创建子进程，因而本身设置的信息会被子进程全部继承，例如设置堆栈对32MB，则子进程也会使用32MB。</p><h2 id="watchdog看门狗"><a href="#watchdog看门狗" class="headerlink" title="watchdog看门狗"></a>watchdog看门狗</h2><p>watchdog作用是每隔一段时间去检查某个参数是否被设置了，如果发现该参数没有被设置，则判断为系统出错，然后强制重启。</p><p>Android对于systemserver的参数是否被设置也增加了一条看门狗。主要检查几个重要的service，如果service出了问题就会杀掉system_server，这回导致zygote也一起杀掉，导致java层重启。</p><p>SystemServer和Watchdog的交互大致分为三个步骤(frameworks/base/services/core/java/com/android/server/Watchdog.java)：</p><ol><li>Watchdog.getInstance().init()初始化</li><li>Watchdog.getInstance().start()，派生于Thread类，start启动线程，导致Watchdog的run在另外一个线程中被执行。该函数实现隔一段时间发送一条信息，那个线程将检查各个service的健康状况，而看门狗等待检查结果，如果第二次没有返回结果，将会杀掉systemserver</li><li>Watchdog.getInstance().addMonitor()，如果要支持看门狗的检查，就需要让service实现monitor接口（比如ActivityManagerService,PowerManagerService,WindowManagerService）</li></ol><p><strong>Example:</strong></p><p>当一个函数占着锁，长时间没有返回（原因是这个函数需要和硬件交互，而硬件没有及时返回），导致系统服务死锁被watchdog检查到。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;zygote和system_server在Android中的Java层很重要。&lt;/p&gt;
&lt;h2 id=&quot;zygote分析&quot;&gt;&lt;a href=&quot;#zygote分析&quot; class=&quot;headerlink&quot; title=&quot;zygote分析&quot;&gt;&lt;/a&gt;zygote分析&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;zygote由init进程根据init.rc的配置项创建的。最初叫&lt;code&gt;app_process&lt;/code&gt;，但是在运行过程中，通过Linux的pctrl系统调用将其换成了&lt;code&gt;zygote&lt;/code&gt;。通过&lt;code&gt;adb shell ps -ef|grep zygote&lt;/code&gt;查看到该进程。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="android" scheme="http://wizzie.top/categories/android/"/>
    
    
      <category term="android" scheme="http://wizzie.top/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>Android init进程</title>
    <link href="http://wizzie.top/2019/09/09/2019/190909_android_init_service/"/>
    <id>http://wizzie.top/2019/09/09/2019/190909_android_init_service/</id>
    <published>2019-09-09T13:52:00.000Z</published>
    <updated>2020-03-08T10:14:08.790Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>init是Linux系统中用户空间的第一个进程。通过<code>adb shell ps -rf</code>查看我的一加手机进程信息。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UID            PID  PPID C STIME TTY          TIME CMD</span><br><span class="line">root             1     0 0 12:43:34 ?     00:00:10 init</span><br></pre></td></tr></table></figure><ul><li>init进程负责创建系统中的几个关键进程，例如zygote</li><li>init提供了一个property service（属性服务）来管理Android系统的众多属性<a id="more"></a><h2 id="init分析"><a href="#init分析" class="headerlink" title="init分析"></a>init分析</h2></li></ul><blockquote><p>使用android-10.0.0_r2 AOSP最新源码（<a href="http://192.99.106.107:8080/xref/android-10.0.0_r2/）" target="_blank" rel="noopener">http://192.99.106.107:8080/xref/android-10.0.0_r2/）</a></p></blockquote><p>init进程的入口函数从/system/core/init/main.cpp的main函数开始：</p><figure class="highlight c++"><figcaption><span>system/core/init/main.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __has_feature(address_sanitizer)</span></span><br><span class="line">    __asan_set_error_report_callback(AsanReportCallback);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(basename(argv[<span class="number">0</span>]), <span class="string">"ueventd"</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> ueventd_main(argc, argv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"subcontext"</span>)) &#123;</span><br><span class="line">            android::base::InitLogging(argv, &amp;android::base::KernelLogger);</span><br><span class="line">            <span class="keyword">const</span> BuiltinFunctionMap function_map;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> SubcontextMain(argc, argv, &amp;function_map);  </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"selinux_setup"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> SetupSelinux(argv);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">"second_stage"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> SecondStageMain(argc, argv); <span class="comment">//此处调用init.cpp的函数入口</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    re</span><br></pre></td></tr></table></figure><p>在Android Q之前，此处一直都是直接调用入口函数：</p><figure class="highlight c++"><figcaption><span>system/core/init/main.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    android::init::main(argc, argv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后会调用到init.cpp中的SecondStageMain函数。init的工作流程精简为以下四点：</p><ul><li>解析配置文件</li><li>执行各个阶段的动作（创建zygote的工作就是此时完成）</li><li>调用Property_init初始化属性相关的资源</li><li>init进入一个无线循环，等待一些事情的发生（init处理来自socket和来自属性服务器的相关事情）</li></ul><h3 id="解析系统配置文件init-rc"><a href="#解析系统配置文件init-rc" class="headerlink" title="解析系统配置文件init.rc"></a>解析系统配置文件init.rc</h3><ul><li>在入口函数调用<code>LoadBootScripts(am, sm);</code></li><li>然后调用<code>parser.ParseConfig(bootscript);</code></li><li>调用system/core/init/parser.cpp的parseConfig函数</li><li>调用<code>Parser::ParseConfigFile</code>函数，读取配置文件并解析</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Parser::ParseConfigFile</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; path)</span> </span>&#123;</span><br><span class="line">    LOG(INFO) &lt;&lt; <span class="string">"Parsing file "</span> &lt;&lt; path &lt;&lt; <span class="string">"..."</span>;</span><br><span class="line">    android::base::Timer t;</span><br><span class="line">    <span class="keyword">auto</span> config_contents = ReadFile(path);   <span class="comment">//读取init.rc配置文件</span></span><br><span class="line">    <span class="keyword">if</span> (!config_contents) &#123;</span><br><span class="line">        LOG(INFO) &lt;&lt; <span class="string">"Unable to read config file '"</span> &lt;&lt; path &lt;&lt; <span class="string">"': "</span> &lt;&lt; config_contents.error();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ParseData(path, &amp;config_contents.value());</span><br><span class="line"></span><br><span class="line">    LOG(VERBOSE) &lt;&lt; <span class="string">"(Parsing "</span> &lt;&lt; path &lt;&lt; <span class="string">" took "</span> &lt;&lt; t &lt;&lt; <span class="string">".)"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="init-rc解析service"><a href="#init-rc解析service" class="headerlink" title="init.rc解析service"></a>init.rc解析service</h3><blockquote><p>查看/system/core/rootdir/init.rc</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">on init   <span class="comment">//on关键字表示一个section，对应的名字时init</span></span><br><span class="line">    sysclktz <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    # Mix device-specific information into the entropy pool</span><br><span class="line">    copy /proc/cmdline /dev/urandom</span><br><span class="line">    copy /system/etc/prop.<span class="keyword">default</span> /dev/urandom</span><br><span class="line"></span><br><span class="line">    symlink /proc/self/fd/<span class="number">0</span> /dev/<span class="built_in">stdin</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"># It is recommended to <span class="built_in">put</span> unnecessary data/ initialization from post-fs-data</span><br><span class="line"># to start-zygote in device's init.rc to unblock zygote start.</span><br><span class="line">on zygote-start &amp;&amp; property:ro.crypto.state=unencrypted</span><br><span class="line">    # A/B update verifier that marks a successful boot.</span><br><span class="line">    exec_start update_verifier_nonencrypted</span><br><span class="line">    start netd</span><br><span class="line">    start zygote</span><br><span class="line">    start zygote_secondary</span><br><span class="line"></span><br><span class="line">on zygote-start &amp;&amp; property:ro.crypto.state=unsupported</span><br><span class="line">    # A/B update verifier that marks a successful boot.</span><br><span class="line">    exec_start update_verifier_nonencrypted</span><br><span class="line">    start netd</span><br><span class="line">    start zygote</span><br><span class="line">    start zygote_secondary</span><br><span class="line"></span><br><span class="line">on zygote-start &amp;&amp; property:ro.crypto.state=encrypted &amp;&amp; property:ro.crypto.type=file</span><br><span class="line">    # A/B update verifier that marks a successful boot.</span><br><span class="line">    exec_start update_verifier_nonencrypted</span><br><span class="line">    start netd</span><br><span class="line">    start zygote</span><br><span class="line">    start zygote_secondary</span><br><span class="line"></span><br><span class="line">on boot    <span class="comment">//新的section，名为boot</span></span><br><span class="line">    # basic network init</span><br><span class="line">    ifup lo   <span class="comment">//一个command</span></span><br><span class="line">    hostname localhost</span><br><span class="line">    domainname localdomain</span><br><span class="line"></span><br><span class="line">    # IPsec SA <span class="keyword">default</span> expiration length</span><br><span class="line">    <span class="built_in">write</span> /proc/sys/net/core/xfrm_acq_expires <span class="number">3600</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>init.rc中：<code>class_start</code>，标识一个COMMAND，对应的处理函数是do_class_start，位于boot section范围内。</p><h3 id="属性服务"><a href="#属性服务" class="headerlink" title="属性服务"></a>属性服务</h3><blockquote><p>注册标可以存储一些类似ket/value的键值对，一般系统或某些应用程序会吧自己的一些属性存储在注册表中，即使重启，还是能够根据之前在注册表中设置的属性，进行相应的初始化工作。Android平台也提供了一个类似的机制，称为属性服务（property service）  </p></blockquote><p>property的初始化在init.cpp的主函数里面：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">property_init();</span><br><span class="line">......</span><br><span class="line">    <span class="comment">// Make the time that init started available for bootstat to log.</span></span><br><span class="line">    property_set(<span class="string">"ro.boottime.init"</span>, getenv(<span class="string">"INIT_STARTED_AT"</span>));</span><br><span class="line">    property_set(<span class="string">"ro.boottime.init.selinux"</span>, getenv(<span class="string">"INIT_SELINUX_TOOK"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set libavb version for Framework-only OTA match in Treble build.</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* avb_version = getenv(<span class="string">"INIT_AVB_VERSION"</span>);</span><br><span class="line">    <span class="keyword">if</span> (avb_version) property_set(<span class="string">"ro.boot.avb_version"</span>, avb_version);</span><br><span class="line">...</span><br><span class="line">    property_load_boot_defaults(load_debug_prop);</span><br><span class="line">    UmountDebugRamdisk();</span><br><span class="line">    fs_mgr_vendor_overlay_mount_all();</span><br><span class="line">    export_oem_lock_status();</span><br><span class="line">    StartPropertyService(&amp;epoll);</span><br><span class="line">    <span class="function">MountHandler <span class="title">mount_handler</span><span class="params">(&amp;epoll)</span></span>;</span><br><span class="line">    set_usb_controller();</span><br><span class="line">......</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;init是Linux系统中用户空间的第一个进程。通过&lt;code&gt;adb shell ps -rf&lt;/code&gt;查看我的一加手机进程信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;UID            PID  PPID C STIME TTY          TIME CMD&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;root             1     0 0 12:43:34 ?     00:00:10 init&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;ul&gt;
&lt;li&gt;init进程负责创建系统中的几个关键进程，例如zygote&lt;/li&gt;
&lt;li&gt;init提供了一个property service（属性服务）来管理Android系统的众多属性
    
    </summary>
    
    
      <category term="android" scheme="http://wizzie.top/categories/android/"/>
    
    
      <category term="android" scheme="http://wizzie.top/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>C++对象和类</title>
    <link href="http://wizzie.top/2019/09/04/2019/190904_cpp_class_object/"/>
    <id>http://wizzie.top/2019/09/04/2019/190904_cpp_class_object/</id>
    <published>2019-09-04T14:52:00.000Z</published>
    <updated>2020-03-08T10:14:08.790Z</updated>
    
    <content type="html"><![CDATA[<h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p>指定基本类型完成了三项工作：</p><ol><li>决定数据对象需要的内存数量</li><li>决定如何解释内存中的位（long和float所占位数相同，但是将他们转换成数值的方法不同）</li><li>决定可使用数据对象执行的操作和方法<a id="more"></a><h2 id="类class"><a href="#类class" class="headerlink" title="类class"></a>类class</h2></li></ol><p>类规范由两部分组成：</p><ol><li>类声明：以数据成员的方式描述数据部分，以成员函数（方法）的方式描述公有接口</li><li>类方法定义：描述如何实现类成员函数</li></ol><p>即类声明提供类的蓝图，方法定义则提供了细节。</p><p>类声明举例：</p><figure class="highlight c++"><figcaption><span>stock00.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> STOCKOO_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STOCKOO_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stock</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span>:  <span class="comment">//只能通过公共成员（或友元函数）访问的类成员，例如要修改shares，只能通过Stock的成员函数</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> company;</span><br><span class="line">        <span class="keyword">long</span> shares;</span><br><span class="line">        <span class="keyword">double</span> share_val;</span><br><span class="line">        <span class="keyword">double</span> total_val;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">set_tot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            total_val = shares * share_val;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="keyword">String</span> &amp;co, <span class="keyword">long</span> n)</span></span>;  <span class="comment">//函数原型</span></span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现类成员函数"><a href="#实现类成员函数" class="headerlink" title="实现类成员函数"></a>实现类成员函数</h3><blockquote><p>为由类声明中的函数原型表示的成员函数提供代码。成员函数定义和常规函数相似，有函数头和函数体、返回类型和参数，但是有两个特征：</p></blockquote><ol><li>定义成员函数时，使用作用域解析运算符<code>::</code>来标识函数所属的类</li></ol><p><code>void Stock::update(double price) {...}</code></p><p>此处的update即是Stock的成员函数，这就意味着可以将另一个类的成员函数也命名为update。</p><ol start="2"><li>类方法可以访问类的private组件</li></ol><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><blockquote><p>函数声明对象时，将自动调用构造函数。构造函数的参数表示的不是类成员，而是赋给类成员的值。因此，参数名不能和类成员相同，否则会导致混乱。</p></blockquote><p><strong>使用构造函数：</strong></p><p>显示调用构造函数：<br><code>Stock food = Stock(&quot;World cabbage&quot;, 250, 1.25);</code></p><p>隐式调用构造函数：<br><code>Stock garment(&quot;Furry&quot;, 50, 2.6);</code></p><p>创建类对象：<br><code>Stock *pstock = new Stock(&quot;ABC&quot;, 18, 19.0);</code></p><p><strong>Notes:</strong></p><p>如果没有提供任何构造函数，则自动提供默认构造函数。<br>比如：<code>Sotck::stock() {...}</code></p><p>如果定义了构造函数，就必须提供默认构造函数，否则会报错。定义的方式有两种：</p><ol><li>给已有构造函数的所有参数提供默认值，<code>Stock(const string&amp;co = &quot;Error&quot;, int n =0;)</code></li><li>通过函数重载来定义另一个没有参数的构造函数，<code>Stock()</code></li></ol><p>而只能拥有一个默认构造函数，所以不要同时使用这两个方式。而用户定义的默认构造函数通常给所有成员提供了隐式初始值。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Stock::Stock() &#123;</span><br><span class="line">  company = <span class="string">"no name"</span>;</span><br><span class="line">  share = <span class="number">0</span>;</span><br><span class="line">  share_val = <span class="number">0.0</span>;</span><br><span class="line">  total_val = <span class="number">0.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>隐式的调用默认构造函数时，不用使用圆括号。<code>Stock stock1;</code></p><h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><blockquote><p>如果构造函数使用new发根配内存，则析构函数将使用delete释放内存。而析构函数的名称是在函数名前加上<code>~</code>，例如<code>~Stock()</code>。Stock的析构函数不承担任何重要的工作，因此直接编写不执行任何操作的函数：</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stock::~Stock() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编译器决定调用析构函数的时机"><a href="#编译器决定调用析构函数的时机" class="headerlink" title="编译器决定调用析构函数的时机"></a>编译器决定调用析构函数的时机</h3><ul><li>如果创建的是静态存储对象，则其析构函数就爱你挂在程序结束时自动调用</li><li>如果创建的是自动存储类对象，则其析构函数将在程序执行完代码块时（该对象是在其中定义的）自动被调用</li><li>如果对象通过new创建的，则将驻留在栈内存或者自由存储区中，当使用delete来释放内存时，其析构函数将自动被调用</li><li>程序可以创建临时对象来完成特定的操作，此时程序将在结束对该对象使用时自动调用其析构函数</li></ul><h2 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h2><blockquote><p>this指针指向用来调用成员函数的对象（this被称为隐藏参数传递给方法）每个成员函数（包含构造函数和析构函数）都有一个this指针。this指针指向调用对象。如果方法想要引用整个调用对象，则可以使用表达式<code>*this</code>。在函数的括号后面使用const限定符将this限定为const，这样将不能使用this来修改对象的值。<br>然而要返回的不是this，因为this是对象的地址，*this是指向的值。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> Stock &amp; <span class="title">Stock::topval</span><span class="params">(<span class="keyword">const</span> Stock &amp; s)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (s.total_val &gt; total_val)</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对象数组"><a href="#对象数组" class="headerlink" title="对象数组"></a>对象数组</h2><p>创建同一个类的多个对象，创建对象数组比独立对象变量更合适。</p><p><code>Stock mystuff[4];</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mystuff[<span class="number">0</span>].update();</span><br><span class="line">mystuff[<span class="number">3</span>].show();</span><br><span class="line"><span class="keyword">const</span> Stock * tops = mystuff[<span class="number">2</span>].topval(mystuff[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用构造函数初始化数组元素，此时必须为没够元素调用构造函数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> STKS = <span class="number">4</span>;</span><br><span class="line">Stock stocks[STKS] = &#123;</span><br><span class="line">  Stock(<span class="string">"A"</span>, <span class="number">12.5</span>, <span class="number">20</span>),</span><br><span class="line">  Stock(<span class="string">"B"</span>, <span class="number">11.5</span>, <span class="number">530</span>),</span><br><span class="line">  Stock(<span class="string">"C"</span>, <span class="number">13.5</span>, <span class="number">120</span>),</span><br><span class="line">  Stock(<span class="string">"D"</span>, <span class="number">14.5</span>, <span class="number">30</span>),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="类作用域"><a href="#类作用域" class="headerlink" title="类作用域"></a>类作用域</h2><blockquote><p>在类中定义的名称（如类数据称源和类成员函数名）的作用域都为整个类。在类声明或成员函数定义中，可以使用未修饰的成员名称（未限定的名称）。构造函数名称被调用时，才能被识别，因为他的名称和类名相同。在其他情况下，使用类成员名时，必须根据上下文使用直接成员运算符（.），间接成员运算符（-&gt;）或者作用域解析运算符（::）</p></blockquote><h3 id="作用域于为类的常量"><a href="#作用域于为类的常量" class="headerlink" title="作用域于为类的常量"></a>作用域于为类的常量</h3><p>声明类只是描述了对象的形式，并没有创建对象。因此，在创建对象前，没有用于存储值的空间（C++11提供了成员初始化，但不适用于数组声明）。因此以下的方式初始化不正确：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Bck &#123;</span><br><span class="line">  private:</span><br><span class="line"><span class="deletion">- const int Months = 12; //fail</span></span><br><span class="line"><span class="deletion">- double costs[Months];</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以使用以下方式,在类中声明一个枚举，枚举的作用域是整个类。</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Bck &#123;</span><br><span class="line">  private:</span><br><span class="line"><span class="addition">+ enum &#123;Months= 12&#125;;</span></span><br><span class="line"><span class="addition">+ double costs[Months];</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以在类中定义常量的方式，使用关键字static。这将常量和其他静态变量存储在一起，而不是存储在对象中。因此只有一个Months常量，被所有的Bck类对象共享。</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Bck &#123;</span><br><span class="line">  private:</span><br><span class="line"><span class="addition">+ static const int Months= 12;</span></span><br><span class="line"><span class="addition">+ double costs[Months];</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="C-11作用域内枚举"><a href="#C-11作用域内枚举" class="headerlink" title="C++11作用域内枚举"></a>C++11作用域内枚举</h2><p>传统的枚举容易出现冲突，例如在一个类中定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> egg &#123;Small. Large, Medium&#125;;</span><br><span class="line"><span class="keyword">enum</span> t_shirt &#123;Small. Large, Medium&#125;;</span><br></pre></td></tr></table></figure><p>C++11提供一种新枚举，其枚举量的作用域是类，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">egg</span> &#123;</span>Small. Large, Medium&#125;;</span><br><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">t_shirt</span> &#123;</span>Small. Large, Medium&#125;;</span><br><span class="line"><span class="comment">//或者使用struct关键字代替class</span></span><br><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">struct</span> <span class="title">egg</span> &#123;</span>Small. Large, Medium&#125;;</span><br><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">struct</span> <span class="title">t_shirt</span> &#123;</span>Small. Large, Medium&#125;;</span><br><span class="line"></span><br><span class="line">egg choic = egg::Large;</span><br><span class="line">t_shirt Floyd = t_shirt::Large;  <span class="comment">//此时将不再发生冲突</span></span><br></pre></td></tr></table></figure><h2 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h2><blockquote><p>C++使用栈来管理自动变量，当新的自动变量被生成后，他们被添加到栈顶；消亡时，从栈中删除他们。  </p></blockquote><h3 id="栈的特征"><a href="#栈的特征" class="headerlink" title="栈的特征"></a>栈的特征</h3><p>栈存储了多个数据项（该特征使得栈成为一个容器，一种通用的抽象），其次，栈由可对他执行的操作来描述。</p><ul><li>可创建空栈</li><li>可将数据项添加到栈顶（压入）</li><li>可从栈顶删除数据项（弹出）</li><li>可查看栈是否填满</li><li>可查看栈是否为空</li></ul><p>如果将上述描述转换为一个类声明，其中公有成员函数提供了栈操作的接口，而私有数据成员负责存储栈数据。私有部分必须表明数据存储的方式，例如可以使用常规数组、动态分配数组或者更高级的数据结构。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol><li>通常将类声明分成两部分，类声明（包含函数原型表示的方法）应该放在头文件中。定义成员函数的源代码放在方法文件中。</li><li>使用OOP方法的第一步是根据他和程序之间的接口描述数据，从而指定如何使用数据。然后设计一个类来实现该接口。一般来说，私有数据成员存储信息，公有成员函数（又称作方法）提供访问数据的唯一途径。类将数据和方法组合成一个单元，其私有性实现数据隐藏。</li><li>类是用户定义的类型，而对象是类的实例。也可以说对象是这种类型的变量，例如由new按类描述分配的内存。</li><li>如果希望成员函数对多个对象进行操作，可以将额外的对象作为参数传递给它。如果方法需要显示的引用调用他的对象，则可以使用this指针。由于this指针被设置为调用对象的地址，因此*this是该对象的别名。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;类型&quot;&gt;&lt;a href=&quot;#类型&quot; class=&quot;headerlink&quot; title=&quot;类型&quot;&gt;&lt;/a&gt;类型&lt;/h2&gt;&lt;p&gt;指定基本类型完成了三项工作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;决定数据对象需要的内存数量&lt;/li&gt;
&lt;li&gt;决定如何解释内存中的位（long和float所占位数相同，但是将他们转换成数值的方法不同）&lt;/li&gt;
&lt;li&gt;决定可使用数据对象执行的操作和方法
    
    </summary>
    
    
      <category term="cpp" scheme="http://wizzie.top/categories/cpp/"/>
    
    
      <category term="cpp" scheme="http://wizzie.top/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>C++头文件、作用域、内存模型和名称空间</title>
    <link href="http://wizzie.top/2019/09/01/2019/190901_cpp_namespace/"/>
    <id>http://wizzie.top/2019/09/01/2019/190901_cpp_namespace/</id>
    <published>2019-09-01T13:52:00.000Z</published>
    <updated>2020-03-08T10:14:08.790Z</updated>
    
    <content type="html"><![CDATA[<h2 id="单独编译"><a href="#单独编译" class="headerlink" title="单独编译"></a>单独编译</h2><p>C++提供<code>#include</code>语法，因而可以将程序划分，大致可以分成三部分：  </p><ol><li>头文件<code>a.h</code>：包含结构声明和使用这些结构的函数原型</li><li>源代码文件<code>a.cpp</code>：包含与结构相关的函数的代码</li><li>源代码文件<code>b.cpp</code>：包含调用与结构相关的函数的代码<a id="more"></a><h3 id="头文件内容和引用"><a href="#头文件内容和引用" class="headerlink" title="头文件内容和引用"></a>头文件内容和引用</h3></li></ol><blockquote><p>头文件常包含的内容：</p></blockquote><ul><li>函数原型</li><li>使用<code>#define</code>或者<code>const</code>定义的符号常量</li><li>结构声明struct</li><li>类声明class</li><li>模板声明template</li><li>内联函数inline</li></ul><blockquote><p>头文件引用时，使用<code>#include &quot;coordin.h&quot;</code>，而不是<code>#include &lt;coordin.h&gt;</code><br>因为尖括号的文件名，C++编译器将在存储标准头文件的主机系统的文件系统中查找；而双引号的头文件，则编译器将首先查找当前的工作目录或源代码目录（或其他目录，取决于编译器）</p></blockquote><h3 id="头文件管理"><a href="#头文件管理" class="headerlink" title="头文件管理"></a>头文件管理</h3><p>在同一个文件中只能将同一个头文件包含一次。有时候会存在包含了另一个头文件的头文件。因而有一种方法基于预处理器编译指令<code>#ifndef即if not defined</code>可以忽略第一次包含之外的所有内容，但是这种方法不能防止编译器将文件包含两次。。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//仅当以前没有使用预处理器编译指令#define定义名称COORDIN_H_时，才处理#inndef和#endif之间的语句</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> COORDIN_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COORDIN_H_  <span class="comment">//完成该名称的定义</span></span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><hr><h2 id="作用域scope"><a href="#作用域scope" class="headerlink" title="作用域scope"></a>作用域<code>scope</code></h2><blockquote><p>作用域描述名称在文件的多大范围可见。<br>C++变量的作用域有多种。</p></blockquote><ul><li>局部变量只在定义他的代码块中可用。</li><li>作用域为全局（也叫文件作用域）的变量在定义位置到文件结尾之间都可用。</li><li>自动变量的作用域为局部</li><li>静态变量的作用域是全局还是局部取决于它如何被定义</li><li>在函数原型作用域中使用的名称只包含参数列表的括号内可用</li><li>在类中声明的成员的作用域为整个类</li><li>在名称空间中声明的变量的作用域是整个名称空间</li><li>C++函数的作用域可以是整个类或者命名空间，但不能是局部的，不能只对自己可见，这样会导致不能被其他函数调用</li></ul><p>不同的C++存储方式是通过存储持续性（数据内存存储方式）、作用域和链接性来描述的。</p><h2 id="数据内存的存储方式（存储持续性）"><a href="#数据内存的存储方式（存储持续性）" class="headerlink" title="数据内存的存储方式（存储持续性）"></a>数据内存的存储方式（存储持续性）</h2><blockquote><p>C++使用三种方案存储数据，见文章《C++内存分配方式和模板类vector,array》<br>C++11新增了<code>线程存储持续性</code></p></blockquote><h3 id="线程存储持续性"><a href="#线程存储持续性" class="headerlink" title="线程存储持续性"></a>线程存储持续性</h3><p>在多核处理器很常见，这些CPU可以同时处理多个执行任务（可以使用SDK的systrace工具抓取一份trace查看）。这让程序能够将计算放在可并行处理的不同线程中。如果变量是使用关键字<code>thread_local</code>声明的，则其生命周期和所属的线程一样长。</p><h3 id="自动存储持续性"><a href="#自动存储持续性" class="headerlink" title="自动存储持续性"></a>自动存储持续性</h3><blockquote><p>默认情况下，在函数中声明的函数参数和变量的存储持续性是自动，作用域是局部，没有链接性。当函数结束时，这些变量将小时（执行到代码块时，将为变量分配内存，但是其作用域的起点是其声明位置）</p></blockquote><p>如果在代码块中定义了变量，则该变量的存在时间和作用域将被限制在该代码块内。</p><p>通常存储在栈stack中，先进后出。之所以被称为栈，是由于新数据被象征性的放在原有数据的上面（相邻的内存单元），当程序使用完后，将其从栈中删除（栈的默认长度取决于实现，编译器通常提供改变栈长度的选项）。程序使用两个指针跟踪栈，一个指向栈底（开始位置），一个指向栈顶（下一个可用内存单元）。当函数被调用时，其自动变量被加入栈中，栈顶指针指向变量后的下一个可用内存单元。函数结束时，栈顶指针被重置为函数被调用前的值，从而释放新变量使用的内存。</p><p>有些自动变量存储在<strong>寄存器</strong>中，关键字<code>register</code>最初由C语言引入，C++11之前，它建议编译器使用CPU寄存器存储自动变量。这旨在提高访问变量的速度。<br><code>register int count_fast;</code></p><p>在C++11中，失去了这种提示作用，关键字<code>register</code>只是显式的指出变量是自动的。鉴于它只能用于原本就是自动的变量，使用他的唯一原因是指出这个变量的名称可能与外部变量相同，避免使用了该关键字的现有代码非法。</p><h3 id="静态持续变量"><a href="#静态持续变量" class="headerlink" title="静态持续变量"></a>静态持续变量</h3><p>C++未静态存储持续性变量提供三种链接性：</p><ol><li>外部链接性（可在其他文件中访问）</li><li>内部链接性（只能在当前文件中访问）</li><li>无链接性（只能在当前函数或者代码块中访问）</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">int</span> global = <span class="number">1000</span>;   <span class="comment">//外部链接，作用域是整个文件</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> one_file = <span class="number">50</span>; <span class="comment">//内部链接，作用域是整个文件</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>; <span class="comment">//无链接</span></span><br><span class="line">  <span class="keyword">int</span> ma = <span class="number">0</span>;   <span class="comment">//自动变量，两者区别在于静态无链接变量在函数没有被执行时，也会在内存中</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">存储描述</th><th align="center">持续性</th><th align="center">作用域</th><th align="center">链接性</th><th align="center">声明方法</th></tr></thead><tbody><tr><td align="center">自动</td><td align="center">自动</td><td align="center">代码块</td><td align="center">无</td><td align="center">代码块中</td></tr><tr><td align="center">寄存器</td><td align="center">自动</td><td align="center">代码块</td><td align="center">无</td><td align="center">代码块中，使用关键字<code>register</code></td></tr><tr><td align="center">静态，无链接性</td><td align="center">静态</td><td align="center">代码块</td><td align="center">无</td><td align="center">使用关键字’static’</td></tr><tr><td align="center">静态，外部链接性</td><td align="center">静态</td><td align="center">文件</td><td align="center">外部</td><td align="center">不再任何函数内</td></tr><tr><td align="center">静态，内部链接性</td><td align="center">静态</td><td align="center">文件</td><td align="center">内部</td><td align="center">不再任何函数内，使用关键字<code>static</code></td></tr></tbody></table><p>所有静态持续变量的初始化特征：<strong>未被出的初始化的静态变量的所在位都被设置为0，这种变量被称为零初始化的</strong></p><p>零初始化和常量表达式初始化被统称为静态初始化，这意味着在编译器处理文件（翻译单元）时初始化变量。动态初始化意味着变量将在编译后初始化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x;   <span class="comment">//零初始化</span></span><br><span class="line"><span class="keyword">int</span> y = <span class="number">5</span>; <span class="comment">//y先被零初始化，然后编译器计算常量表达式，初始化成5</span></span><br></pre></td></tr></table></figure><hr><h4 id="静态持续性、外部链接性"><a href="#静态持续性、外部链接性" class="headerlink" title="静态持续性、外部链接性"></a>静态持续性、外部链接性</h4><p>链接性为外部的变量通常简称为外部变量，存储持续性是静态，作用域是整个文件。在函数外部定义，因此对所有函数都是外部的。例如可以在main()前面或者头文件中定义他们。可以在文件中位于外部变量定义后面的任何函数中使用它，因此也被称为<code>全局变量</code>（相对于局部的自动变量）</p><p>C++有“单定义规则”，每个变量只能有一次定义。因而C++提供两种变量声明，一种是<code>定义声明</code>，分配存储空间；另一种是<code>引用声明</code>，不给变量分配存储空间，引用已有的变量。</p><p>引用声明使用关键字extern，则不进行初始化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> up;  <span class="comment">//零初始化</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> blem;;  <span class="comment">//引用声明，不进行初始化（此处可以引用其他文件已经声明的外部变量）</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> gr = <span class="string">'z'</span>;  <span class="comment">//已经初始化了，所以导致分配存储空间</span></span><br></pre></td></tr></table></figure><h4 id="静态持续性、内部链接性"><a href="#静态持续性、内部链接性" class="headerlink" title="静态持续性、内部链接性"></a>静态持续性、内部链接性</h4><p>不同于外部变量，将static限定符用于作用域为整个文件的变量时，该变量的链接性是内部的。<strong>两者区别是</strong> 内部链接的变量只能在所属的文件中使用，外部变量具有外部链接性，可以在其他文件中使用。</p><h4 id="静态持续性、无链接性"><a href="#静态持续性、无链接性" class="headerlink" title="静态持续性、无链接性"></a>静态持续性、无链接性</h4><p>将static限定符用于在代码块中定义的变量，导致局部变量的存储持续性是静态的。这意味着虽然只能在该代码块使用，但是在该代码块不处于活动状态时仍然存在。<code>因此在两次调用该函数时，静态局部变量的值将保持不变。此外如果初始化了静态局部变量，则程序只在启动时进行一次初始化，再次调用时不会初始化，即值保持上次的值</code></p><hr><h2 id="限定符和说明符"><a href="#限定符和说明符" class="headerlink" title="限定符和说明符"></a>限定符和说明符</h2><h3 id="存储说明符"><a href="#存储说明符" class="headerlink" title="存储说明符"></a>存储说明符</h3><ul><li>auto(在C++11不再是说明符)</li><li>register</li><li>static</li><li>extern</li><li>thread_local</li><li>mutable</li></ul><ol><li>同一个声明中不能使用多个说明符（除了thread_local可以和static或者extern结合使用）</li><li>C++11之前auto指出变量是自动变量，但是在C++11中，auto用于自动类型推断</li><li>register用于在声明中指示寄存器存储，在C++11中只是显式的指出变量是自动的</li><li>static被用在作用域是整个文件的声明中时，表示内部链接性；被用于局部声明中，表示局部变量的存储持续性是静态的</li><li>extern表明是引用声明，即声明引用在其他地方定义的变量</li><li>thread_local指出变量的持续性和所属线程的持续性相同。thread_local变量之于线程，犹如常规静态变量之于整个程序。</li><li>mutable的含义根据const来解释（<code>查看下一小节</code>）</li></ol><h3 id="cv-限定符-const和volatile"><a href="#cv-限定符-const和volatile" class="headerlink" title="cv-限定符(const和volatile)"></a>cv-限定符(const和volatile)</h3><ul><li>const</li><li>volatile</li></ul><ol><li>const表示内存被初始化后，程序不能再对其进行修改</li><li>volatile表明即使程序代码没有对内存单元进行修改，其值也可能发生变化。作用是为了改善编译器的优化能力。例如，如果编译器发现程序在几条语句中两次使用了某个变量的值，则编译器可能不是让程序查找这个值两次，而是将这个值缓存到既存区中。（这种优化假设变量的值在两次使用之间不发生变化）将变量声明为volatile，则编译器不会进行这种优化；否则将进行这种优化。</li><li>可以使用<code>mutable</code>指出，即使结构（或者类）变量为const，其某个成员也可以被修改。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span> name[<span class="number">30</span>];</span><br><span class="line">  <span class="keyword">mutable</span> <span class="keyword">int</span> accesses;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> data veep = &#123;<span class="string">"peter"</span>, <span class="number">0</span>, ...&#125;;</span><br><span class="line">+ <span class="built_in">strcpy</span>(veep.name, <span class="string">"nancy"</span>);  <span class="comment">//not allowed,因为const</span></span><br><span class="line">- veep.accesses++;  <span class="comment">//allow</span></span><br></pre></td></tr></table></figure><p>veep的const限定符禁止程序修改veep的成员，但access成员的mutable说明符可以使的access不受这种限制。</p><hr><h2 id="名称空间"><a href="#名称空间" class="headerlink" title="名称空间"></a>名称空间</h2><ol><li>声明区域是可以在其中进行声明的区域。例如函数外面声明全局变量，其声明区域为所在的文件；<br>函数中声明变量，声明区域为所在代码块；</li><li>潜在作用域：变量的潜在作用域从声明点开始，到其声明区域的结尾。因此潜在作用域比声明作用域小，这是由于变量必须定义后才能使用。</li><li>关键字<code>namespace</code>通过定义一种新的声明区域来创建命名的空间，如此不会和另一个名称空间发生同名冲突。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Javk &#123;</span><br><span class="line">  <span class="keyword">double</span> pail;</span><br><span class="line">  <span class="keyword">int</span> pal;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Jil &#123;</span><br><span class="line">  <span class="keyword">double</span> pail;</span><br><span class="line">  <span class="keyword">int</span> pal;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="作用域解析运算符-双冒号"><a href="#作用域解析运算符-双冒号" class="headerlink" title="作用域解析运算符::双冒号"></a>作用域解析运算符<code>::双冒号</code></h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Jil::pal = <span class="number">3</span>;   <span class="comment">//限定的名称</span></span><br><span class="line"><span class="keyword">int</span> pal = <span class="number">10</span>;   <span class="comment">//未限定的名称</span></span><br><span class="line">Javk::pail = <span class="number">23.4</span>;</span><br></pre></td></tr></table></figure><h3 id="using声明恶化using编译指令"><a href="#using声明恶化using编译指令" class="headerlink" title="using声明恶化using编译指令"></a>using声明恶化using编译指令</h3><blockquote><p>using声明使得特定的标识符可用，using编译指令使得整个命名空间可用。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Jil &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">using</span> Jil::pail;  <span class="comment">//using声明</span></span><br><span class="line">  <span class="keyword">double</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>using编译指令由名称空间和关键字<code>using namespace</code>组成。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Jil;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br></pre></td></tr></table></figure><h3 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h3><ul><li>不要在头文件使用using编译指令，如果非要使用，应将其放在所有的预处理编译指令<code>#include</code>后面</li><li>导入名称时，首选使用作用域解析运算符或者using声明的方法</li><li>对于using声明，首选将其作用域设置为局部而不是全局</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;单独编译&quot;&gt;&lt;a href=&quot;#单独编译&quot; class=&quot;headerlink&quot; title=&quot;单独编译&quot;&gt;&lt;/a&gt;单独编译&lt;/h2&gt;&lt;p&gt;C++提供&lt;code&gt;#include&lt;/code&gt;语法，因而可以将程序划分，大致可以分成三部分：  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;头文件&lt;code&gt;a.h&lt;/code&gt;：包含结构声明和使用这些结构的函数原型&lt;/li&gt;
&lt;li&gt;源代码文件&lt;code&gt;a.cpp&lt;/code&gt;：包含与结构相关的函数的代码&lt;/li&gt;
&lt;li&gt;源代码文件&lt;code&gt;b.cpp&lt;/code&gt;：包含调用与结构相关的函数的代码
    
    </summary>
    
    
      <category term="cpp" scheme="http://wizzie.top/categories/cpp/"/>
    
    
      <category term="cpp" scheme="http://wizzie.top/tags/cpp/"/>
    
  </entry>
  
</feed>
