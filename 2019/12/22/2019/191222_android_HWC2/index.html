<!DOCTYPE html>
<html>
<head>
    

    

    



    <meta charset="utf-8">
    
    
    
    <link rel="canonical" href="true/2019/12/22/2019/191222_android_HWC2/">
    
    
    <title>Android SurfaceFlinger和HWC2概述 | sunwengang blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="graphics">
    <meta name="description" content="转载夕月风大佬博客： https:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;824a9ddf68b9参考Android Q AOSP源码添加修改部分内容参考源码： http:&#x2F;&#x2F;aosp.opersys.com&#x2F;xref&#x2F;android-10.0.0_r14&#x2F;">
<meta property="og:type" content="article">
<meta property="og:title" content="Android SurfaceFlinger和HWC2概述">
<meta property="og:url" content="http://wizzie.top/2019/12/22/2019/191222_android_HWC2/index.html">
<meta property="og:site_name" content="sunwengang blog">
<meta property="og:description" content="转载夕月风大佬博客： https:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;824a9ddf68b9参考Android Q AOSP源码添加修改部分内容参考源码： http:&#x2F;&#x2F;aosp.opersys.com&#x2F;xref&#x2F;android-10.0.0_r14&#x2F;">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://wizzie.top/2019/12/22/2019/191222_android_HWC2/Layer_Struct.png">
<meta property="article:published_time" content="2019-12-22T15:32:00.000Z">
<meta property="article:modified_time" content="2020-03-08T10:22:18.357Z">
<meta property="article:author" content="sunwengang">
<meta property="article:tag" content="graphics">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://wizzie.top/2019/12/22/2019/191222_android_HWC2/Layer_Struct.png">
    
        <link rel="alternate" type="application/atom+xml" title="sunwengang blog" href="/atom.xml">
    
    <link rel="shortcut icon" href="/img/favicon.ico">
    <link rel="stylesheet" href="/css/style.css?v=1.7.2">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">sunwengang</h5>
          <a href="mailto:1332963488@qq.com" title="1332963488@qq.com" class="mail">1332963488@qq.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                Home
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                Archives
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                Tags
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                Categories
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://www.cnblogs.com/1996swg" target="_blank" >
                <i class="icon icon-lg icon-book"></i>
                cnblog
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/AloneAlive" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/html/nav.html" target="_blank" >
                <i class="icon icon-lg icon-external-link-square"></i>
                nav
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/others"  >
                <i class="icon icon-lg icon-address-book"></i>
                friends
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">Android SurfaceFlinger和HWC2概述</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="Search">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">Android SurfaceFlinger和HWC2概述</h1>
        <h5 class="subtitle">
            
                <time datetime="2019-12-22T15:32:00.000Z" itemprop="datePublished" class="page-time">
  2019-12-22
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/android/">android</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#SurfaceFlinger概述"><span class="post-toc-number">1.</span> <span class="post-toc-text">SurfaceFlinger概述</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#SurfaceFlinger类定义"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">SurfaceFlinger类定义</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#ISurfaceComposer接口实现"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">ISurfaceComposer接口实现</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#ComposerCallback接口实现"><span class="post-toc-number">1.3.</span> <span class="post-toc-text">ComposerCallback接口实现</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#mCurrentState和mDrawingState"><span class="post-toc-number">1.4.</span> <span class="post-toc-text">mCurrentState和mDrawingState</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#硬件合成HWC2概述"><span class="post-toc-number">2.</span> <span class="post-toc-text">硬件合成HWC2概述</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#HWC常规准则"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">HWC常规准则</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#HWC2框架"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">HWC2框架</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#HWC2数据结构"><span class="post-toc-number">2.3.</span> <span class="post-toc-text">HWC2数据结构</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#图层Layer"><span class="post-toc-number">2.4.</span> <span class="post-toc-text">图层Layer</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Layer按照类型划分"><span class="post-toc-number">2.4.1.</span> <span class="post-toc-text">Layer按照类型划分</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Layer按照数据划分"><span class="post-toc-number">2.4.2.</span> <span class="post-toc-text">Layer按照数据划分</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Layer属性"><span class="post-toc-number">2.5.</span> <span class="post-toc-text">Layer属性*</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#位置属性"><span class="post-toc-number">2.5.1.</span> <span class="post-toc-text">位置属性</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#内容属性"><span class="post-toc-number">2.5.2.</span> <span class="post-toc-text">内容属性</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#合成属性（确认用哪种合成方式）"><span class="post-toc-number">2.5.3.</span> <span class="post-toc-text">合成属性（确认用哪种合成方式）</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#优化属性"><span class="post-toc-number">2.5.4.</span> <span class="post-toc-text">优化属性</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#小结"><span class="post-toc-number">3.</span> <span class="post-toc-text">小结</span></a></li></ol>
        </nav>
    </aside>


<article id="post-2019/191222_android_HWC2"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">Android SurfaceFlinger和HWC2概述</h1>
        <div class="post-meta">
            <time class="post-time" title="2019-12-22 23:32:00" datetime="2019-12-22T15:32:00.000Z"  itemprop="datePublished">2019-12-22</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/android/">android</a></li></ul>



            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <blockquote>
<p>转载夕月风大佬博客： <a href="https://www.jianshu.com/p/824a9ddf68b9" target="_blank" rel="noopener">https://www.jianshu.com/p/824a9ddf68b9</a><br>参考Android Q AOSP源码添加修改部分内容<br>参考源码： <a href="http://aosp.opersys.com/xref/android-10.0.0_r14/" target="_blank" rel="noopener">http://aosp.opersys.com/xref/android-10.0.0_r14/</a></p>
</blockquote>
<a id="more"></a>

<h2 id="SurfaceFlinger概述"><a href="#SurfaceFlinger概述" class="headerlink" title="SurfaceFlinger概述"></a>SurfaceFlinger概述</h2><p>大多数APP在屏幕通常显示三个部分：</p>
<ul>
<li>屏幕顶部的状态栏</li>
<li>底部或者侧边的导航栏</li>
<li>应用的界面</li>
</ul>
<p>有些应用会显示更多或者更少的层。例如主屏幕会有一个单独的壁纸层；全屏幕的游戏可能会隐藏状态栏目。这些可以通过<code>Dump Surfacelinger</code>查看BufferLayers部分的信息来获取具体信息（<code>adb shell dumpsys SurfaceFlinger</code>）。从Dump结果看，layer呈树形结构(<code>Tree</code>)分布。</p>
<p>每个层都可以单独更新。状态栏和导航栏由系统进程渲染，而应用层由应用渲染，两者之间不进行协调。</p>
<h3 id="SurfaceFlinger类定义"><a href="#SurfaceFlinger类定义" class="headerlink" title="SurfaceFlinger类定义"></a>SurfaceFlinger类定义</h3><figure class="highlight c++"><figcaption><span>frameworks/native/services/surfaceflinger/SurfaceFlinger.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SurfaceFlinger</span> :</span> <span class="keyword">public</span> BnSurfaceComposer,</span><br><span class="line">                       <span class="keyword">public</span> PriorityDumper,</span><br><span class="line">                       <span class="keyword">private</span> IBinder::DeathRecipient,</span><br><span class="line">                       <span class="keyword">private</span> HWC2::ComposerCallback</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">SurfaceFlingerBE&amp; <span class="title">getBE</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> mBE; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> SurfaceFlingerBE&amp; <span class="title">getBE</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> mBE; &#125;</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure>

<p>继承BnSurfaceComposer，实现ISurfaceComposer接口；实现ComposerCallback；继承辅助类PriorityDumper，主要提供SurfaceFlinger的Dump信息，并且提高提供信息的分离和格式设置。</p>
<h3 id="ISurfaceComposer接口实现"><a href="#ISurfaceComposer接口实现" class="headerlink" title="ISurfaceComposer接口实现"></a>ISurfaceComposer接口实现</h3><p>ISurfaceComposer是提供给上层Client端的接口（Bp端），此处的SurfaceFlinger是Server端（Bn端）。接口内容包括：</p>
<figure class="highlight c++"><figcaption><span>frameworks/native/include/gui/ISurfaceComposer.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ISurfaceComposer</span>:</span> <span class="keyword">public</span> IInterface &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    DECLARE_META_INTERFACE(SurfaceComposer)</span><br><span class="line">    ......</span><br><span class="line">        <span class="comment">/* returns information for each configuration of the given display</span></span><br><span class="line"><span class="comment">     * intended to be used to get information about built-in displays */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">status_t</span> <span class="title">getDisplayConfigs</span><span class="params">(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; <span class="built_in">display</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">            Vector&lt;DisplayInfo&gt;* configs)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure>

<p>接口在SurfaceFlinger中都有对应的方法实现。Client端通过Binder跨进程调到SurfaceFlinger中。获取Display的信息，其实现就是SurfaceFlinger的<code>getDisplayConfig</code>函数。</p>
<h3 id="ComposerCallback接口实现"><a href="#ComposerCallback接口实现" class="headerlink" title="ComposerCallback接口实现"></a>ComposerCallback接口实现</h3><p>ComposerCallback是HWC2的callback接口，包括以下接口：</p>
<figure class="highlight c++"><figcaption><span>frameworks/native/services/surfaceflinger/DisplayHardware/HWC2.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> HWC2 &#123;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Display</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Layer</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Implement this interface to receive hardware composer events.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// These callback functions will generally be called on a hwbinder thread, but</span></span><br><span class="line"><span class="comment">// when first registering the callback the onHotplugReceived() function will</span></span><br><span class="line"><span class="comment">// immediately be called on the thread calling registerCallback().</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// All calls receive a sequenceId, which will be the value that was supplied to</span></span><br><span class="line"><span class="comment">// HWC2::Device::registerCallback(). It's used to help differentiate callbacks</span></span><br><span class="line"><span class="comment">// from different hardware composer instances.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ComposerCallback</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onHotplugReceived</span><span class="params">(<span class="keyword">int32_t</span> sequenceId, <span class="keyword">hwc2_display_t</span> <span class="built_in">display</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   Connection connection)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onRefreshReceived</span><span class="params">(<span class="keyword">int32_t</span> sequenceId,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">hwc2_display_t</span> <span class="built_in">display</span>)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onVsyncReceived</span><span class="params">(<span class="keyword">int32_t</span> sequenceId, <span class="keyword">hwc2_display_t</span> <span class="built_in">display</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">int64_t</span> timestamp)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~ComposerCallback() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line">.....</span><br></pre></td></tr></table></figure>

<p>Callback提供了注册接口<code>registerCallback</code>，在SurfaceFlinger初始化的时候注册：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ALOGI(  <span class="string">"SurfaceFlinger's main thread ready to run. "</span></span><br><span class="line">            <span class="string">"Initializing graphics H/W..."</span>);</span><br><span class="line">....</span><br><span class="line">mCompositionEngine-&gt;getHwComposer().registerCallback(<span class="keyword">this</span>, getBE().mComposerSequenceId);</span><br><span class="line">....</span><br></pre></td></tr></table></figure>

<p>此处<code>registerCallback</code>的<code>this</code>就是SurfaceFlinger对ComposerCallback接口的实现。</p>
<ul>
<li>onHotplugReceived： 热插拔事件的回调，显示屏幕连接或者断开时回调。</li>
<li>onRefreshReceived： 接收底层HWComposer的刷新请求。在<code>repaintEverythingForHWC</code>中，<code>mRepaintEverything</code>为<code>true</code>的时候，将触发一次刷新，重新进行合成显示。重新绘制说明底层配置、参数等有变动，SurfaceFlinger前面给的数据不能用，需要重新根据变动后的配置进行合成，给适合当前配置的显示数据。</li>
</ul>
<figure class="highlight c++"><figcaption><span>frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::onRefreshReceived</span><span class="params">(<span class="keyword">int</span> sequenceId, <span class="keyword">hwc2_display_t</span> <span class="comment">/*hwcDisplayId*/</span>)</span> </span>&#123;</span><br><span class="line">    <span class="function">Mutex::Autolock <span class="title">lock</span><span class="params">(mStateLock)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (sequenceId != getBE().mComposerSequenceId) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    repaintEverythingForHWC();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::repaintEverythingForHWC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mRepaintEverything = <span class="literal">true</span>;</span><br><span class="line">    mEventQueue-&gt;invalidate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>onVsyncReceived： Vsync事件上报，接收底层硬件上报的垂直同步信号。此处可以通过抓取<code>Systrace</code>的方式查看具体的Vsync的信息（底层硬件、SurfaceFlinger、APP三部分的Vsync，一般Android版本升级的时候会进行<code>vsync的tuning</code>）</li>
<li><strong>显示周期Vsync</strong>： 设备显示会按照一定速率更新（一般是一秒60帧，即16.6ms刷新一次）。如果显示内容在刷新期间更新，则会出现撕裂现象，因此必须在周期之间更新（<code>这也是vsync tunning的必要性，保持SurfaceFlinger和draw frame都在vsync周期里面，并且不重叠</code>）在可以安全更新内容时，系统便会接收来自显示设备的信号。</li>
</ul>
<p>刷新率可能会随时间而变化，例如一些设备的刷新范围在58fps至62fps之间，具体视当前条件而定。对于连接了HDMI的电视，刷新率在理论上可以下降到24Hz或者48Hz，以便和视频匹配。由于每个刷新周期只能更新屏幕一次，因此以200fps的刷新率为显示设备提交缓冲区并没有必要性，因为大部分桢不能被看到（人眼合适的是60fps）。SurfaceFlinger不会在应用提交缓冲区时进行操作，而是在显示设备准备好接收新缓冲区的时候才会唤醒。</p>
<p>当Vsync信号到达的时候，SurfaceFlinger会遍历层列表，以寻找新的缓冲区。如果找到会获取该缓冲区，否则会使用以前获取的缓冲区。SurfaceFlinger总是需要可显示的内容，因此会保留一个缓冲区。如果在某个层没有提交缓冲区，则该层会被忽略。</p>
<p>此处会在合成调用到<code>handlePageFlip</code>函数，函数中先调用<code>latchBuffer</code>从BufferQueue取Buffer，然后等待Vsync信号更新到FrameBuffer。</p>
<ul>
<li><strong>合成方式</strong>： 目前SurfaceFlinger支持两种合成方式：一种是Device合成，一种是Client合成。SurfaceFlinger在收集可见层的所有缓冲区之后，便会询问HardwareComposer应该如何进行合成。</li>
<li><ul>
<li>Client合成：之前称之为GLES合成，也可以称之为GPU合成，该合成方式是相对于硬件合成来说的，将各个Layer的内容用GPU渲染到暂存缓冲区中，最后将暂存缓冲区传送到显示硬件Client合成采用RenderEngine进行合成。</li>
</ul>
</li>
<li><ul>
<li>Device合成： 用专门的硬件合成器进行合成HWComposer，所以硬件合成的能力就取决于硬件的实现。其合成方式是将各个Layer的数据全部传给显示硬件，并告知它从不同的缓冲区读取屏幕不同部分的数据。HWComposer是Device合成的抽象。</li>
</ul>
</li>
</ul>
<p>合成方式可以从Dump SurfaceFlinger中查看到Layer的具体合成方式，GPU合成一般可以通过开发者选项中启动，强制GPU合成；而Device合成在Dump信息中一般显示成SDE合成。</p>
<p>GPU合成数据后，作为一个特殊的Layer传给显示硬件。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Display 0 HWC layers:</span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line"> Layer name</span><br><span class="line">           Z |  Comp Type |   Disp Frame (LTRB) |          Source Crop (LTRB)</span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line"> com.android.systemui.ImageWallpaper#0</span><br><span class="line">  rel      0 |     Client |    0    0 1080 2280 |    0.0    0.0 1080.0 2280.0</span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line"> net.oneplus.launcher/net.oneplus.launcher.Launcher#0</span><br><span class="line">  rel      0 |     Client |    0    0 1080 2280 |    0.0    0.0 1080.0 2280.0</span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line"><span class="meta"> StatusBar#</span><span class="bash">0</span></span><br><span class="line">  rel      0 |     Client |    0    0 1080   80 |    0.0    0.0 1080.0   80.0</span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line"><span class="meta"> GestureButtonRegion#</span><span class="bash">0</span></span><br><span class="line">  rel      0 |     Client |    0 2216 1080 2280 |    0.0    0.0 1080.0   64.0</span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line"><span class="meta"> ScreenDecorOverlay#</span><span class="bash">0</span></span><br><span class="line">  rel      0 |     Device |    0    0 1080  106 |    0.0    0.0 1080.0  106.0</span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line"><span class="meta"> ScreenDecorOverlayBottom#</span><span class="bash">0</span></span><br><span class="line">  rel      0 |     Device |    0 2198 1080 2280 |    0.0    0.0 1080.0   82.0</span><br><span class="line">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="line"></span><br><span class="line">|-----|------------|-----------|------|-------------|--------------------------|---------------------|---------------------|----|------------|-----------|----|-----|</span><br><span class="line">| Idx |  Comp Type |   Split   | Pipe |    W x H    |          Format          |  Src Rect (L T R B) |  Dst Rect (L T R B) |  Z |    Flags   | Deci(HxV) | CS | Rng |</span><br><span class="line">|-----|------------|-----------|------|-------------|--------------------------|---------------------|---------------------|----|------------|-----------|----|-----|</span><br><span class="line">|   6 | GPU_TARGET |    Pipe-1 |   94 | 1088 x 2288 |           RGBA_8888_UBWC |    0    0 1080 2280 |    0    0 1080 2280 |  0 | 0x00000002 |   0 x   0 |  0 |   0 |</span><br><span class="line">|   4 |        SDE |    Pipe-1 |  103 | 1088 x  112 |           RGBA_8888_UBWC |    0    0 1080  106 |    0    0 1080  106 |  1 | 0x00000000 |   0 x   0 |  1 |   1 |</span><br><span class="line">|   5 |        SDE |    Pipe-1 |   92 | 1088 x   96 |           RGBA_8888_UBWC |    0    0 1080   82 |    0 2198 1080 2280 |  2 | 0x00000000 |   0 x   0 |  1 |   1 |</span><br><span class="line">|-----|------------|-----------|------|-------------|--------------------------|---------------------|---------------------|----|------------|-----------|----|-----|</span><br></pre></td></tr></table></figure>
<ul>
<li>SurfaceFlingerBE: 从Android P上分离出来，定义上看是将Surfacelinger分离为前后端。</li>
<li>消息队列和主线程： 和应用进程类似，SurfaceFlinger也有一个主线程，主要是进行显示数据的处理，即合成。Surfacelinger是一个服务，将会响应上层的请求，各个进程的请求都在SurfaceFlinger的各个Binder线程中，如果线程很耗时，那么应用端就会被block。主线程将他们分离开来，各干各的。</li>
</ul>
<p><strong>Note：</strong></p>
<ol>
<li>SurfaceFligner有两个状态，Layer也有两个状态，一个是mCurrentState，一个是mDrawingState。</li>
<li>两个EventThread，一个是给SurfaceFlinger本身使用，一个是为了给应用分发事件的。</li>
</ol>
<hr>
<h3 id="mCurrentState和mDrawingState"><a href="#mCurrentState和mDrawingState" class="headerlink" title="mCurrentState和mDrawingState"></a><code>mCurrentState</code>和<code>mDrawingState</code></h3><ol>
<li>这两个成员是Layer类中<code>Layer::State</code>的类型。</li>
</ol>
<figure class="highlight c++"><figcaption><span>Layer.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">State</span> &#123;</span></span><br><span class="line">    Geometry active;  <span class="comment">//计算后的实际尺寸</span></span><br><span class="line">    Geometry requested; <span class="comment">//用户设置的尺寸</span></span><br><span class="line">    <span class="keyword">int32_t</span> z; <span class="comment">//Layer的Z轴值，值越小位置就越靠小</span></span><br><span class="line">    <span class="keyword">uint32_t</span> layerStack;  <span class="comment">//和显示设备的关联值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unit8_t</span> alpha; <span class="comment">//Layer的透明度</span></span><br><span class="line">    <span class="keyword">uint8_t</span> flags;  <span class="comment">//Layer的标志（如果上次绘制后用户改变了Layer）</span></span><br><span class="line">    <span class="keyword">uint8_t</span> reserved[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int32_t</span> sequence; <span class="comment">//序列值，Layer的属性变化一次就会加一（例如setAlpha,setSize,setLayer等）</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// the transparentRegion hint is a bit special, it's latched only</span></span><br><span class="line">    <span class="comment">// when we receive a buffer -- this is because it's "content"</span></span><br><span class="line">    <span class="comment">// dependent.</span></span><br><span class="line">    Region activeTransparentRegion; <span class="comment">//实际的透明区域</span></span><br><span class="line">    Region requestedTransparentRegion;  <span class="comment">//用户中的透明区域</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>Surfacelinger创建Surface的时候，会调用<code>createLayer</code>，然后调用<code>addClientLayer</code>函数，这里会把Layer对象放在<code>mCurrentState</code>的layerSortedByZ对象中。</p>
</li>
<li><p>Surfacelinger合成的时候，调用<code>preComposition</code>函数，会先调用<code>mDrawingState</code>的layerSortedByZ来获取上次绘图的Layer层列表（并不是所有layer都参与屏幕图像的绘制，因此通过State对象记录参与绘制的Layer对象）</p>
</li>
<li><p>Layer对象在绘制图形时，使用的是mDrawingState变量；用户调用接口设置Layer对象属性时，设置的值保存在mCurrentState中。这样就不会因为用户的操作而干扰Layer对象的绘制了。</p>
</li>
<li><p><code>Layer::doTransaction</code>函数会比较这两个成员变量，如果有不同的地方，说明上次绘制后，用户改变了Layer的属性，要把这种变化通过flags返回。</p>
</li>
<li><p><code>layerStack</code>字段是用户指定的一个值，用户可以给DisplayDevice指定一个layerStack值，只有Layer对象和DisplayDevice对象的layerStack相等，这个Layer才能在这个显示设备输出。这样的好处可以让显示设备只显示某个Surface的内容。例如，可以让HDMI显示设备只显示手机上播放的Surface窗口，但是不显示Activity窗口。</p>
</li>
<li><p><code>Layer::doTransaction</code>最后会调用<code>commitTransaction</code>函数，就是将mCurrentState赋值给mDrawingState。</p>
</li>
</ol>
<hr>
<ol start="8">
<li>以上的是在Layer.cpp中的两个成员变量，而在<code>SurfaceFlinger.cpp</code>也有同名的<code>mCurrentState</code>和<code>mDrawingState</code>两个成员变量（定义在SurfaceFlinger.h中），定义不一样，只是名字相同。</li>
</ol>
<figure class="highlight c++"><figcaption><span>SF.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">State</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    explicit State(LayerVector::StateSet set) : stateSet(set), layersSortedByZ(set) &#123;&#125;</span><br><span class="line">    State&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> State&amp; other) &#123;</span><br><span class="line">        <span class="comment">// We explicitly don't copy stateSet so that, e.g., mDrawingState</span></span><br><span class="line">        <span class="comment">// always uses the Drawing StateSet.</span></span><br><span class="line">        layersSortedByZ = other.layersSortedByZ;</span><br><span class="line">        displays = other.displays;</span><br><span class="line">        colorMatrixChanged = other.colorMatrixChanged;</span><br><span class="line">        <span class="keyword">if</span> (colorMatrixChanged) &#123;</span><br><span class="line">            colorMatrix = other.colorMatrix;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> LayerVector::StateSet stateSet = LayerVector::StateSet::Invalid;</span><br><span class="line">    LayerVector layersSortedByZ;  <span class="comment">//保存所有参与绘制的Layer对象</span></span><br><span class="line">    DefaultKeyedVector&lt; wp&lt;IBinder&gt;, DisplayDeviceState&gt; displays; <span class="comment">//保存所有输出设备的DisplayDeviceState对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> colorMatrixChanged = <span class="literal">true</span>;</span><br><span class="line">    mat4 colorMatrix;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traverseInZOrder</span><span class="params">(<span class="keyword">const</span> LayerVector::Visitor&amp; visitor)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traverseInReverseZOrder</span><span class="params">(<span class="keyword">const</span> LayerVector::Visitor&amp; visitor)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="9">
<li>SF.cpp中的<code>handleTransactionLocked</code>函数会根据<code>eTraversalNeeded</code>标志决定是否要检查所有的Layer对象。如果某个Layer对象有这个标志，将会调用他的<code>doTransaction</code>函数。<code>Layer::doTransaction</code>函数返回的flags如果有<code>eVisibleRegion</code>说明这个Layer需要更新，就把<code>mVisibleRegionDirty</code>设置为true。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SurfaceFlinger::handleTransactionLocked</span><span class="params">(<span class="keyword">uint32_t</span> transactionFlags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Notify all layers of available frames</span></span><br><span class="line">    mCurrentState.traverseInZOrder([](Layer* layer) &#123;</span><br><span class="line">        layer-&gt;notifyAvailableFrames();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Traversal of the children</span></span><br><span class="line"><span class="comment">     * (perform the transaction for each of them if needed)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (transactionFlags &amp; eTraversalNeeded) &#123;</span><br><span class="line">        mCurrentState.traverseInZOrder([&amp;](Layer* layer) &#123;</span><br><span class="line">            <span class="keyword">uint32_t</span> trFlags = layer-&gt;getTransactionFlags(eTransactionNeeded);</span><br><span class="line">            <span class="keyword">if</span> (!trFlags) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">uint32_t</span> flags = layer-&gt;doTransaction(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (flags &amp; Layer::eVisibleRegion)</span><br><span class="line">                mVisibleRegionsDirty = <span class="literal">true</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ......<span class="comment">//这部分代码是根据每种显示设备的不同，设置和显示设备关联在一起的Layer（主要看LayerStack是否和DisplayDevice的layerStack相同）的TransformHint（主要指设备的显示方向orientation）</span></span><br><span class="line"></span><br><span class="line">    commitTransaction();</span><br><span class="line"></span><br><span class="line">    updateCursorAsync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Note:</strong> <code>handleTransaction</code>的作用是处理系统在两次刷新期间的各种变化。Surfacelinger模块中不管是SurfaceFlinger类和Layer类</p>
<hr>
<h2 id="硬件合成HWC2概述"><a href="#硬件合成HWC2概述" class="headerlink" title="硬件合成HWC2概述"></a>硬件合成HWC2概述</h2><p>Hardware Composer HAL(HWC)是指硬件完成图像数据组合并显示的能力。</p>
<p>SurfaceFlinger是一个系统服务（系统启动时启动），作用是接收来自多个源的Buffer数据，并进行合成，然后发送到显示设备进行显示。</p>
<p>SurfaceFlinger和HWC的相互配合，实现Android系统的合成和显示（非GPU合成）。</p>
<hr>
<p>Android 7.0包含新版本的HWC（HWC2），Android需要自行配置。</p>
<p>Android 8.0，HWC2正式开启，并且版本升级为2.1。（<code>/frameworks/native/services/surfaceflinger/DisplayHardware/</code>）</p>
<p>HWC2是SurfaceFlinger用来与专门的窗口合成硬件进行通信（Device合成方式）。SurfaceFlinger包含使用3D图形处理器（GPU）执行窗口合成任务的备用途径，但是此路径并不理想（GPU合成方式），因为：</p>
<ol>
<li>通常，GPU没有针对此进行优化，因此能耗可能大于执行合成所需的能耗；</li>
<li>每次SUrfaceFlinger使用GPU合成时，应用都无法使用处理器进行自我渲染，因此应尽可能使用专门的硬件而不是GPU进行合成。</li>
</ol>
<p>GPU（Client合成）和HWC（Client合成）两种方式对比：</p>
<table>
<thead>
<tr>
<th align="center">合成类型</th>
<th align="center">耗电情况</th>
<th align="center">性能情况</th>
<th align="center">Alpha处理</th>
<th align="center">DRM内容处理</th>
<th align="center">其他限制</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Device合成（HWC）</td>
<td align="center">耗电低</td>
<td align="center">性能高</td>
<td align="center">很多Vendor的HWC不支持Alpha的处理和合成</td>
<td align="center">基本都能访问DRM内容</td>
<td align="center">能合成的Surface层数有限，对每种Surface类型处理层数有限</td>
</tr>
<tr>
<td align="center">Client合成（GPU）</td>
<td align="center">耗电高</td>
<td align="center">性能低</td>
<td align="center">能处理每个像素的Alpha及每个Layer的Alpha</td>
<td align="center">早期版本GPU不能访问DRM的内容</td>
<td align="center">目前的处理层数没有限制</td>
</tr>
</tbody></table>
<p><strong>Note:</strong></p>
<ol>
<li>Alpha处理： 图片的透明度（0～255或者0.0f~1.0f），数值越小透明度越高</li>
<li>DRM内容处理：（Digital Rights Management）一种业界使用广泛的数字内容版权保护技术。</li>
</ol>
<h3 id="HWC常规准则"><a href="#HWC常规准则" class="headerlink" title="HWC常规准则"></a>HWC常规准则</h3><p>Hardware Composer抽象层后的物理显示设备硬件可因设备而异。但是一般来说，遵循以下规则：</p>
<ol>
<li>HWC应至少支持4个叠加层（状态栏、系统栏、应用、壁纸/背景）</li>
<li>层可以大于屏幕，因此HWC应能处理大于显示屏的层（例如壁纸）</li>
<li>应该同时支持预乘每个像素Alpha混合和每个平面Alpha混合</li>
<li>HWC应能够处理GPU、Camera、视频解码器（Video Decoder）生成的相同缓冲区，因此支持以下某些属性会很有帮助：</li>
</ol>
<ul>
<li><ul>
<li>RGBA打包顺序</li>
</ul>
</li>
<li><ul>
<li>YUV格式</li>
</ul>
</li>
<li><ul>
<li>Tiling,swizzling和步幅属性</li>
</ul>
</li>
</ul>
<ol start="5">
<li>为了支持受保护的内容（Secure layer），必须提供受保护视频播放的硬件路径</li>
</ol>
<p><strong>Note：</strong></p>
<ol>
<li>RGBA是一种颜色值</li>
<li>YUV是一种颜色编码格式，可以说YUV流媒体是原始流数据，大部分的视频领域都在使用。他与RGB类似，但RGB更多的用于渲染时，而YUV则用在数据传输，因为它占用更少的频宽。当然，实时通讯为了降低带宽都会采用H264/H265编码。从字面意思理解，YUV的含义:Y代表亮度信息（灰度），UV分别代表色彩信息。YUV的常用名称有许多，如YUV422这是大部分镜头出来的数据，还有许多（yuv420,yuv444等）</li>
<li>Tiling简单来说就是将image进行切割，切成<code>M * N</code>小块，最后用的时候再进行拼接，类似铺瓷砖</li>
<li>swizzling是一种拌和技术，这是向量的单元可以被任意的重新排放或重复</li>
</ol>
<p>HWC专注于优化，智能的选择要发送到叠加硬件的Surface，以最大限度减轻GPU的负载。<strong>另一种优化是检测屏幕是否正在更新；如果不是，这将合成委托给OpenGL而不是HWC，以节省电量。但屏幕再次更新时，继续将合成分发给HWC</strong>。</p>
<p>为常见的用例做准备，比如：</p>
<ul>
<li>纵向和横向模式下的全屏游戏</li>
<li>带着字幕和播放控件的全屏视频</li>
<li>主屏幕（状态栏、系统栏目、应用、动态壁纸）</li>
<li>受保护的视频播放</li>
<li>多显示设备支持</li>
</ul>
<h3 id="HWC2框架"><a href="#HWC2框架" class="headerlink" title="HWC2框架"></a>HWC2框架</h3><p>从Android 8.0开始的Treble项目，对Android架构做了调整，让制造商以更低的成本更加轻松快速的将设备更新到Android系统。这就对HAL层有了很大的调整，利用提供给Vendor的接口，将Vendor的实现和Android上层分离开来。</p>
<p>这样的架构也使得HWC架构变得复杂，HWC属于<code>Binderized</code>的HAL类型。<code>Binderized</code>类型的HAL将上层Android和底层HAL分别采用两个不同的进程实现，中间采用Binder进行通信，为了和前面的Binder进行区别，这里采用<code>HWBinder</code>。</p>
<p>可以将HWC分为以下几个部分：</p>
<ul>
<li><p>Binder 1：</p>
</li>
<li><ul>
<li>SurfaceFlinger Service</li>
</ul>
</li>
<li><ul>
<li>HWC2 Client</li>
</ul>
</li>
<li><p>Binder 2：</p>
</li>
<li><ul>
<li>HWC2 Server</li>
</ul>
</li>
<li><ul>
<li>HWC2 Vendor Impl</li>
</ul>
</li>
</ul>
<p><strong>具体解释：</strong></p>
<ol>
<li>Client端：Client就是指SurfaceFlinger。不过SurfaceFlinger采用前后端设计，以后和HWC相关的逻辑应该会放到后端（<code>SurfaceFlingerBE</code>），即<code>/frameworks/native/services/surfaceflinger/</code></li>
<li>HWC Client端： 这一部分属于SurfaceFlinger进程，直接用过Binder通信，和HWC2的HAL Server交互。在SurfaceFlinger中采用<code>namespace HWC2</code>的命名空间，即<code>frameworks/native/services/surfaceflinger/DisplayHardware/HWComposer.cpp</code>。</li>
<li>HWC2 Server端: 这里将建立一个进程实现HWC的<code>Server端</code>。服务端再调用底层Vendor的具体实现。并且，对于底层合成的实现不同，此处会做一些适配（<code>适配HWC1.x</code>），和FrameBuffer的实现。这部分包含三部分：<strong>接口、实现、服务</strong>，以动态库的形式存在：（<code>hardware/interfaces/graphics/composer/2.1/default/</code>）</li>
</ol>
<ul>
<li><ul>
<li><a href="mailto:android.hardware.graphics.composer@2.1.so">android.hardware.graphics.composer@2.1.so</a></li>
</ul>
</li>
<li><ul>
<li><a href="mailto:android.hardware.graphics.composer@2.1-impl.so">android.hardware.graphics.composer@2.1-impl.so</a></li>
</ul>
</li>
<li><ul>
<li><a href="mailto:android.hardware.graphics.composer@2.1-service.so">android.hardware.graphics.composer@2.1-service.so</a></li>
</ul>
</li>
</ul>
<ol start="3">
<li>HWC Vendor实现： 这部分是HWC的具体实现，由硬件厂商完成，（<code>例如高通QCOM</code>），代码一般是<code>hardware/qcom/display/</code>。HWC必须采用<code>Binderized HAL</code>模式，但是不一定要实现HWC2的HAL版本。HWC2的实现需要配置，以Android 8.0为例，包含：</li>
</ol>
<ul>
<li><ul>
<li>添加宏定义<code>TARGET_USERS_HWC2</code></li>
</ul>
</li>
<li><ul>
<li>编译打包HWC2相关的so库</li>
</ul>
</li>
<li><ul>
<li>SELinux相关的权限添加</li>
</ul>
</li>
<li><ul>
<li>配置<code>manifest.xml</code>：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;hal format=<span class="string">"hidl"</span>&gt;</span><br><span class="line">        &lt;name&gt;android.hardware.graphics.composer&lt;/name&gt;</span><br><span class="line">        &lt;transport&gt;hwbinder&lt;/transport&gt;</span><br><span class="line">        &lt;version&gt;<span class="number">2.1</span>&lt;/version&gt;</span><br><span class="line">        &lt;interface&gt;</span><br><span class="line">            &lt;name&gt;IComposer&lt;/name&gt;</span><br><span class="line">            &lt;instance&gt;<span class="keyword">default</span>&lt;/instance&gt;</span><br><span class="line">        &lt;/interface&gt;</span><br><span class="line">&lt;/hal&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h3 id="HWC2数据结构"><a href="#HWC2数据结构" class="headerlink" title="HWC2数据结构"></a>HWC2数据结构</h3><ol>
<li>HWC2的一些常用接口定义在头文件<code>hardware/libhardware/include/hardware/hwcomposer2.h</code>中，一些共用的数据定义是HAL的接口中:</li>
</ol>
<ul>
<li><code>hardware/interfaces/graphics/common/1.0/</code></li>
<li><code>hardware/interfaces/graphics/composer/2.1/</code></li>
</ul>
<h3 id="图层Layer"><a href="#图层Layer" class="headerlink" title="图层Layer"></a>图层Layer</h3><p>每个Layer都有一组属性，用来定义和其他Layer的交互方式。他在每一个模块（层）代码定义的实现不一样，但是Layer的理念是一样的。</p>
<ul>
<li><p><a href="http://aosp.opersys.com/xref/android-10.0.0_r14/xref/frameworks/native/services/surfaceflinger/" target="_blank" rel="noopener">SurfaceFlinger中</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">frameworks&#x2F;native&#x2F;services&#x2F;surfaceflinger</span><br><span class="line">├── Layer.h</span><br><span class="line">├── Layer.cpp</span><br><span class="line">├── ColorLayer.h</span><br><span class="line">├── ColorLayer.cpp</span><br><span class="line">├── BufferLayer.h</span><br><span class="line">└── BufferLayer.cpp</span><br><span class="line">|__ ...</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="">HWC2中</a></p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">frameworks&#x2F;native&#x2F;services&#x2F;surfaceflinger&#x2F;DisplayHardware</span><br><span class="line">├── HWC2.h</span><br><span class="line">└── HWC2.cpp</span><br></pre></td></tr></table></figure>

<ul>
<li>在HAL中实现时，定义为hwc2_layer_t，是在头文件hwcomposer2.h中定义的:<code>typedef uint64_t hwc2_layer_t;</code></li>
<li>HIDL中定义为Layer，这个Layer和<code>hwc2_layer_t</code>是一样的：<code>typedef uint64_t Layer;</code></li>
</ul>
<h4 id="Layer按照类型划分"><a href="#Layer按照类型划分" class="headerlink" title="Layer按照类型划分"></a>Layer按照类型划分</h4><p>大致分为<code>BufferLayer</code>和<code>COlorLayer</code>（在SF中createLayer中），<code>BufferLayer</code>就是有Buffer的Lyaer（Bufferueue，GraphicsBuffer），需要上层应用Producer生长；<code>ColorLayer</code>可以绘制一种制定的颜色和透明度Alpha（取代之前的Dim Layer）。</p>
<h4 id="Layer按照数据划分"><a href="#Layer按照数据划分" class="headerlink" title="Layer按照数据划分"></a>Layer按照数据划分</h4><p>大致分为<code>RGB Layer</code>和<code>YUV Layer</code>，前者是RGB格式，比较常见的就是UI界面的数据；后者的Buffer是YUV类型的，平常播放Video，Camera预览等，都是YUV类型的。</p>
<h3 id="Layer属性"><a href="#Layer属性" class="headerlink" title="Layer属性*"></a>Layer属性*</h3><blockquote>
<p>Layer的属性定义他和其他模块（层）的关系，和显示屏（DeisplayDevice）的关系等。Layer包含的属性类别如下（上述也有部分内容）：</p>
</blockquote>
<h4 id="位置属性"><a href="#位置属性" class="headerlink" title="位置属性"></a>位置属性</h4><blockquote>
<p>定义层在其显示设备上的现实位置，包含层边缘的位置和其相对于其他层的Z-Order等，并且还定义了很多个<strong>区域Region</strong>：</p>
</blockquote>
<figure class="highlight c++"><figcaption><span>frameworks/native/services/surfaceflinger/Layer.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Layer</span> :</span> <span class="keyword">public</span> <span class="keyword">virtual</span> RefBase &#123;</span><br><span class="line">    ... ...</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ... ...</span><br><span class="line">    <span class="comment">// regions below are in window-manager space</span></span><br><span class="line">    Region visibleRegion;</span><br><span class="line">    Region coveredRegion;</span><br><span class="line">    Region visibleNonTransparentRegion;</span><br><span class="line">    Region surfaceDamageRegion;</span><br></pre></td></tr></table></figure>
<p>Region中是很多个Rect的集合，即一个Layer的visibleRegion可能是几个Rect的集合（rect对象用来存储一个矩形框的左上角坐标、宽度和高度。描述矩形的宽度、高度和原点）</p>
<p>SurfaceFlinger中定义的Region都是从上层（WMS）传递过来的。而在HWC中，是用的下面的结构描述：</p>
<figure class="highlight c++"><figcaption><span>hardware/libhardware/include/hardware/hwcomposer_defs.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">hwc_color</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> r;</span><br><span class="line">    <span class="keyword">uint8_t</span> g;</span><br><span class="line">    <span class="keyword">uint8_t</span> b;</span><br><span class="line">    <span class="keyword">uint8_t</span> a;</span><br><span class="line">&#125; <span class="keyword">hwc_color_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">hwc_float_color</span> &#123;</span></span><br><span class="line">    <span class="keyword">float</span> r;</span><br><span class="line">    <span class="keyword">float</span> g;</span><br><span class="line">    <span class="keyword">float</span> b;</span><br><span class="line">    <span class="keyword">float</span> a;</span><br><span class="line">&#125; <span class="keyword">hwc_float_color_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">hwc_frect</span> &#123;</span></span><br><span class="line">    <span class="keyword">float</span> left;</span><br><span class="line">    <span class="keyword">float</span> top;</span><br><span class="line">    <span class="keyword">float</span> right;</span><br><span class="line">    <span class="keyword">float</span> bottom;</span><br><span class="line">&#125; <span class="keyword">hwc_frect_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">hwc_rect</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> left;</span><br><span class="line">    <span class="keyword">int</span> top;</span><br><span class="line">    <span class="keyword">int</span> right;</span><br><span class="line">    <span class="keyword">int</span> bottom;</span><br><span class="line">&#125; <span class="keyword">hwc_rect_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">hwc_region</span> &#123;</span></span><br><span class="line">    <span class="keyword">size_t</span> numRects;</span><br><span class="line">    <span class="keyword">hwc_rect_t</span> <span class="keyword">const</span>* rects;</span><br><span class="line">&#125; <span class="keyword">hwc_region_t</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>Transform，这个在SurfaceFlinger中定义的一个重要的结构，意思是变换矩阵，是一个<code>3*3</code>的矩阵。</li>
</ul>
<p><strong>联系流程：</strong><br><code>Rect &lt;- Region &lt;- Layer &lt;- State &lt;- Geometry &lt;- Transform &lt;- mat33</code></p>
<ul>
<li>Layer的两个状态：mCurrentState和mDrawingState，前者是给SurfaceFlinger的前段准备数据，后者是将数据给到合成。每个状态有两个Geometry的描述<code>request</code>（上层请求的）和<code>active</code>（当前正在使用的）。每个Geometry中有一个Transform矩阵，一个Transform包含一个mat33的整列。</li>
</ul>
<p>Transform中包含两部分，一部分是位置Postion，另一部分是真正的2D的变换矩阵。通过下面两个函数设置：（对应Layer中的setPostion和setMatrix函数，这是上层WMS设置下来的）</p>
<figure class="highlight c++"><figcaption><span>frameworks/native/libs/ui/Transform.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Transform::set</span><span class="params">(<span class="keyword">float</span> tx, <span class="keyword">float</span> ty)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mMatrix[<span class="number">2</span>][<span class="number">0</span>] = tx;</span><br><span class="line">    mMatrix[<span class="number">2</span>][<span class="number">1</span>] = ty;</span><br><span class="line">    mMatrix[<span class="number">2</span>][<span class="number">2</span>] = <span class="number">1.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isZero(tx) &amp;&amp; isZero(ty)) &#123;</span><br><span class="line">        mType &amp;= ~TRANSLATE;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mType |= TRANSLATE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Transform::set</span><span class="params">(<span class="keyword">float</span> a, <span class="keyword">float</span> b, <span class="keyword">float</span> c, <span class="keyword">float</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">mat33&amp; <span class="title">M</span><span class="params">(mMatrix)</span></span>;</span><br><span class="line">    M[<span class="number">0</span>][<span class="number">0</span>] = a;    M[<span class="number">1</span>][<span class="number">0</span>] = b;</span><br><span class="line">    M[<span class="number">0</span>][<span class="number">1</span>] = c;    M[<span class="number">1</span>][<span class="number">1</span>] = d;</span><br><span class="line">    M[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">0</span>;    M[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    mType = UNKNOWN_TYPE;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="内容属性"><a href="#内容属性" class="headerlink" title="内容属性"></a>内容属性</h4><blockquote>
<p>定义显示的内容如何呈现（即Buffer）。Layer的显示，除了之前的几个区域Region描述，还有很多结构进一步描述才能显示，例如裁减（用来扩展内容的一部分以填充层的边界）和转换（用来显示旋转或者翻转的内容）等信息。HWCInfo结构体中包括了一些这样的信息：</p>
</blockquote>
<figure class="highlight c++"><figcaption><span>frameworks/native/services/surfaceflinger/CompositionEngine/include/compositionengine/impl/OutputLayerCompositionState.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">OutputLayerCompositionState</span> &#123;</span></span><br><span class="line">    <span class="comment">// The region of this layer which is visible on this output</span></span><br><span class="line">    Region visibleRegion;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If true, client composition will be used on this output</span></span><br><span class="line">    <span class="keyword">bool</span> forceClientComposition&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If true, when doing client composition, the target may need to be cleared</span></span><br><span class="line">    <span class="keyword">bool</span> clearClientTarget&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The display frame for this layer on this output</span></span><br><span class="line">    Rect displayFrame;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The source crop for this layer on this output</span></span><br><span class="line">    FloatRect sourceCrop;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The buffer transform to use for this layer o on this output.</span></span><br><span class="line">    Hwc2::Transform bufferTransform&#123;<span class="keyword">static_cast</span>&lt;Hwc2::Transform&gt;(<span class="number">0</span>)&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The Z order index of this layer on this output</span></span><br><span class="line">    <span class="keyword">uint32_t</span> z;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * HWC state</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Hwc</span> &#123;</span></span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">Hwc</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;HWC2::Layer&gt; hwcLayer)</span> : <span class="title">hwcLayer</span><span class="params">(hwcLayer)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The HWC Layer backing this layer</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;HWC2::Layer&gt; hwcLayer;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The HWC composition type for this layer</span></span><br><span class="line">        Hwc2::IComposerClient::Composition hwcCompositionType&#123;</span><br><span class="line">                Hwc2::IComposerClient::Composition::INVALID&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The buffer cache for this layer. This is used to lower the</span></span><br><span class="line">        <span class="comment">// cost of sending reused buffers to the HWC.</span></span><br><span class="line">        HwcBufferCache hwcBufferCache;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The HWC state is optional, and is only set up if there is any potential</span></span><br><span class="line">    <span class="comment">// HWC acceleration possible.</span></span><br><span class="line">    <span class="built_in">std</span>::optional&lt;Hwc&gt; hwc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Debugging</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dump</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>&amp; result)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>关系图：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="Layer_Struct.png" alt="Layer显示结构图" title="">
                </div>
                <div class="image-caption">Layer显示结构图</div>
            </figure>

<p>解释：</p>
<ol>
<li>Layer区域和屏幕区域，就是Layer和屏幕本身的大小区域</li>
<li>sourceCrop：剪切区域，sourceCrop是对Layer进行剪切的，值截取部分Layer的内容进行显示；sourceCrop不超过Layer的大小，超过没有意义。</li>
<li>displayFrame：显示区域，displayFrame表示Layer在屏幕上的显示区域，具体说来，是sourceCrop区域在显示屏上的显示区域。displayFrame一般来说，小于屏幕的区域。而displayFrame可能比sourceCrop大，可能小，这都是正常的，只是需要做缩放，这就是合成时需要处理的。</li>
<li>visibleRegion：可见区域，displayFrame 区域不一定都能看到的，如果存在上层Layer，那么displayFrame区域可能部分或全部被盖住，displayFrame没有被盖住的部分就是可见区域visibleRegion。</li>
<li>damageRegion 受损区域，或者称之为更新区域。damageRegion表示Layer内容被破坏的区域，也就是说这部分区域的内容变了，所以这个属性一般是和上一帧相比时才有意义。这算是对合成的一种优化，重新合成时，我们只去合成damageRegion区域，其他的可见区域还是用的上一帧的数据。</li>
<li>visibleNonTransparentRegion：可见非透明区域。透明区域transparentRegion是可见区域visibleRegion的一部分，只是这一部分透明的看到的是底层Layer的内容。在SurfaceFlinger的Layer中定义visibleNonTransparentRegion，表示可见而又不透明的部分。</li>
<li>coveredRegion：被覆盖的区域。表示Layer被TopLayer覆盖的区域，一看图就很好理解。从图中，你可以简单的认为是displayFrame和TopLayer区域重合的部分。</li>
</ol>
<p><strong>注意：</strong> 这里之所以说简单的认为，这是因为HWC空间的区域大小是SurfaceFlinger空间的区域经过缩放，经过Transform旋转，移动等后才得出的，要是混淆了就理解不对了。</p>
<h4 id="合成属性（确认用哪种合成方式）"><a href="#合成属性（确认用哪种合成方式）" class="headerlink" title="合成属性（确认用哪种合成方式）"></a>合成属性（确认用哪种合成方式）</h4><blockquote>
<p>定义层应如何与其他层合成。包括混合模式和用于Alpha合成的全层Alpha值等信息。总的说来，合成分为两个大类：<code>GPU合成</code>和<code>HWC合成</code>。根据具体的情况，分为下列几类：</p>
</blockquote>
<figure class="highlight c++"><figcaption><span>hardware/libhardware/include/hardware/hwcomposer2.h</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">Composition</span> :</span> <span class="keyword">int32_t</span> &#123;</span><br><span class="line">    Invalid = HWC2_COMPOSITION_INVALID,</span><br><span class="line">    <span class="built_in">Client</span> = HWC2_COMPOSITION_CLIENT,</span><br><span class="line">    Device = HWC2_COMPOSITION_DEVICE,</span><br><span class="line">    SolidColor = HWC2_COMPOSITION_SOLID_COLOR,</span><br><span class="line">    Cursor = HWC2_COMPOSITION_CURSOR,</span><br><span class="line">    Sideband = HWC2_COMPOSITION_SIDEBAND,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>释义：</strong></p>
<ol>
<li>Client 相对HWC2硬件合成的概念，主要是处理BufferLayer数据，用GPU处理。</li>
<li>Device HWC2硬件设备，主要处理BufferLayer数据，用HWC处理</li>
<li>SolidColor 固定颜色合成，主要处理ColorLayer数据，用HWC处理或GPU处理。</li>
<li>Cursor 鼠标标识合成，主要处理鼠标等图标，用HWC处理或GPU处理</li>
<li>Sideband Sideband为视频的边频带，一般需要需要硬件合成器作特殊处理，但是也可以用GPU处理。</li>
</ol>
<p>在合成信息HWCInfo中，包含成的类型。通过Layer的setCompositionType方法进行指定：</p>
<figure class="highlight c++"><figcaption><span>frameworks/native/services/surfaceflinger/Layer.cpp</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Layer::setCompositionType</span><span class="params">(<span class="keyword">int32_t</span> hwcId, HWC2::Composition type, <span class="keyword">bool</span> callIntoHwc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getBE().mHwcLayers.count(hwcId) == <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"setCompositionType called without a valid HWC layer"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span>&amp; hwcInfo = getBE().mHwcLayers[hwcId];</span><br><span class="line">    <span class="keyword">auto</span>&amp; hwcLayer = hwcInfo.layer;</span><br><span class="line">    ALOGV(<span class="string">"setCompositionType(%"</span> PRIx64 <span class="string">", %s, %d)"</span>, hwcLayer-&gt;getId(), to_string(type).c_str(),</span><br><span class="line">          <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(callIntoHwc));  <span class="comment">//默认true</span></span><br><span class="line">    <span class="keyword">if</span> (hwcInfo.compositionType != type) &#123;</span><br><span class="line">        ALOGV(<span class="string">"    actually setting"</span>);</span><br><span class="line">        hwcInfo.compositionType = type;</span><br><span class="line">        <span class="keyword">if</span> (callIntoHwc) &#123;</span><br><span class="line">            <span class="keyword">auto</span> error = hwcLayer-&gt;setCompositionType(type);  <span class="comment">//合成方式</span></span><br><span class="line">            ALOGE_IF(error != HWC2::Error::None,</span><br><span class="line">                     <span class="string">"[%s] Failed to set "</span></span><br><span class="line">                     <span class="string">"composition type %s: %s (%d)"</span>,</span><br><span class="line">                     mName.<span class="built_in">string</span>(), to_string(type).c_str(), to_string(error).c_str(),</span><br><span class="line">                     <span class="keyword">static_cast</span>&lt;<span class="keyword">int32_t</span>&gt;(error));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>确定合成类型分成三步：</p>
<ol>
<li>SurfaceFlinger制定合成类型，此时<code>callIntoHwc=true</code>，将类型制定给HWC</li>
<li>HWC根据实际情况看SurfaceFlinger制定的合成类型是否可以执行，如果不满足，作出修改</li>
<li>SurfaceFlinger根据HWC的修改情况再作出调整，最终确认合成类型，此时<code>callIntoHwc=false</code></li>
</ol>
<h4 id="优化属性"><a href="#优化属性" class="headerlink" title="优化属性"></a>优化属性</h4><blockquote>
<p>提供一些非必须的参数，以供HWC进行合成的优化。包括层的可见区域以及层的哪个部分自上一帧以来已经更新等信息。也就是前面说到的visibleRegion，damageRegion等。</p>
</blockquote>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><blockquote>
<p>本篇主要是SurfaceFlinger概述，和HWC2的概述，还有Layer的属性和类型，合成方式的内容。<br>另外还有关于HWC的内容，和Display显示设备的信息重新划分单独的一篇学习。</p>
</blockquote>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    Last updated: <time datetime="2020-03-08T10:22:18.357Z" itemprop="dateUpdated">2020-03-08 18:22:18</time>
</span><br>


        
        版权声明:署名-非商用-相同方式共享 4.0 转载请保留原文链接及作者
        
    </div>
    
    <footer>
        <a href="http://wizzie.top">
            <img src="/img/avatar.jpg" alt="sunwengang">
            sunwengang
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            
	<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/graphics/" rel="tag">graphics</a></li></ul>


            


        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2020/01/05/2020/200105_android_lcd_cabc/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">Android LCD背光驱动节电技术LABC/CABC</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2019/11/24/2019/191124_android_binder_example/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">Android Binder实例</h4>
      </a>
    </div>
  
</nav>



    




















</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        奥利给
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/img/wechat.png" alt="打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <input id="rewardToggle" type="checkbox" class="reward-toggle-check"
                data-wechat="/img/wechat.png" data-alipay="/img/alipay.jpg">
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechat">微信</span>
                <span class="reward-toggle-label"></span>
                <span class="reward-toggle-item alipay">支付宝</span>
            </div>
        </label>
        
    </div>
</div>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>This blog is licensed under a <a rel="license noopener" href="https://creativecommons.org/licenses/by/4.0/" target="_blank">Creative Commons Attribution 4.0 International License</a>.</span>
        </p>
    </div>
    <div class="bottom">
        <p><span>sunwengang &copy; 2019 - 2020</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>


    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: false, REWARD: true };


</script>

<script src="/js/main.min.js?v=1.7.2"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="/js/search.min.js?v=1.7.2" async></script>






<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '';
            clearTimeout(titleTime);
        } else {
            document.title = '(つェ⊂)咦!又好了!';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



</body>
</html>
