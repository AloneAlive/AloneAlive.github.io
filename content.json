[{"title":"Android Systrace如何抓取分析问题","date":"2020-02-22T12:32:00.000Z","path":"2020/02/22/2020/200222_android_systrace_study/","text":"UI流畅平滑的systraceSystrace获取：Android\\Sdk\\platform-tools\\systracesystrace.py：python systrace.py --time=10 -o trace.html gfx input view webview wm am sm audio video hal res dalvik bionic power pm ss pdx sched freq idle load binder_driver binder_lock默认Tag with: sched freq idle res ss gfx input view am常用：./systrace -t 3 -b 10240 -o test.html sched freq idle res ss gfx input view am hal power wm需要开的Tag需求tagscpu信息sched/freq/idle测试列表滑动，桌面滑动等流畅性问题gfx/view/input/hwui测试app launch，点击某个应用，点击进入某个界面gfx/view/input/dalvik/disk怀疑有power问题（亮灭屏，电量相关）gfx/view/input/res/am/wm/powertime和buffer size一般我给的是-t 3 -b 8000如果抓5s，-b可以给20480（kb）如果时间再长，-b可以给30720（kb）视频获取动画过程:指手机画面开始动的前一帧到画面停止动(完全显示，最后一帧)的过程，所以动画过程时间，依据动画不同，记录的时间也会不同。在播放高清视频时，影格数就表示画面所更新的次数，需要仔细观察视频画面。其中一影格就是手机更新画面时动一次，一般在fps为60的平台上，通常是一帧画面就会动一次，也就是一影格，而对于fps为30的平台，通常是两帧表示一影格。FPS:表示每秒刷新的帧数，是画面流畅性的一个重要指标,那它是如何计算出来的呢（影格数除以动画时间）FPS:特定的区段时间内,每秒平均更新画面的次数。数值的高低不能代表画面的流畅度流畅度还是会跟画面的内容有关系（例如分辨率）目前常用的FPS计算方法：systrace所录到的queuebuffer个数计算区段时间内的刷新次数高速摄影机在区段时间内的刷新次数从绘图流程的角度来看,这些FPS的意义是类似的：如果只有单一图层更新的情况,表示从APP画图到display显示的频率。常见FPS TestCase：App 界面滑动换页的流畅性browser浏览网页的流畅性包含列表控件(list menu)界面卷动的流畅性Contact list界面卷动的流畅性Launch app 过场动画流畅性Status bar下拉的流畅性systrace查看绘制过程是否有问题（FPS）如图：systrace查看绘制首先查看VSYNC周期是否正常，是否有进行vsync tunning；查看是否queuebuffer成功？ 绘制之前调用dequeuebufffer从BufferQueue获取一个buffer，绘制完成会调用queuebuffer放回BufferQueue。如果正常queuebufffer,则查看SF合成如果queuebufffer不正常，则查看是否是queuebuffer阻塞？如果queuebuffer阻塞，则看GPU若不是，查看HWUI绘制是否成功？如果HWUI没有绘制，则检查UIThread（UI线程）如果UIThread调用了runnable，则查看SS（不清楚具体表示什么？）如果skia耗费太长时间，则查看skia的代码（绘制API）如果是view耗费太长时间，则查看view模块的代码如果UI线程状态正常，则查看第三方APP是否有问题？如果HWUI绘制了，则检查UIThread和RenderThread（绘制线程）UIThread同上如果HWUI耗时过长，检查是否阻塞在GL？（openGL）如果是，则检查GPU如果不是，则检查HWUI模块上层到底层的模块图(Buffer流程)如图：上层APP到底层Driver顺序模块从APP开始 –》 然后到View（触发setView，测量布局绘制等操作） –》 然后到绘制，如果是软件绘制就是skia，如果是硬件绘制就是到HWUI，再到OpenGL –》 接着绘制完成，通过BufferQueue，调用queuebuffer函数 –》 触发SF合成 –》 查看合成方式，如果是GPU合成还是观察OpenGL，然后两种合成方式再调用到HWC模块 –》 然后到底层驱动Display Driver模块 –》 然后到硬件LCD Panel屏幕Note: queubuffer的查看可以分两部分分析：Queue的速度有没有达到预期值？是否时间太长，一直在Queue？时间点是否正确，是否绘制完成？是否下一个时间点开始触发SF模块合成流程？FPS问题关注点如图：systrace截图分析APP在收到SW Vsync之后，开始产生新的frame查看抓取APP的UIThread， 首先是Choreographer#doFrame进行绘制之前的测量、布局，以及reDraw重绘的判断，然后触发HWUI绘制；查看DrawFrame部分，开始调用dequeubuffer获取buffer，以及其他GL Function；绘制完成后调用eglSwapBuffers，然后再调用queuebuffer将Buffer放回bufferqueue；SF在收到下一个SW Vsync之后，从bufferqueue取出buffer，调用onMessageReceived，然后在函数latchBuffer到更新纹理updateTextImage（纹理数据可以通过GAPID工具抓取trace查看），再到acquireBuffer取Buffer；合成完成后，HWC将SF传下来的工作排进内部thread（可以查看Dispatcher_0和DispSync）HWC处理合成之后，传到底层驱动display driver，然后触发驱动driver（可以查看OverlayEngine_0）然后查看当前的DispSync，在当前的sen_sw_sync结束后将frame送到LCDVsync周期是否正常如图：systrace截图分析如果是标准60fps刷新率，查看VSYNC的周期是否是16.6ms，绘制是否在这个周期内完成？绘制queuebuffer和下一帧合成的时间是否正常？底层硬件的FPS是否正常如图：systrace截图分析如果是标准60fps刷新率，查看底层的FPS（HW_VSYNC）是否是16.6ms正常的周期？查看queuebuffer周期是否规律如图：systrace截图分析hasClientComposition对比hasDeviceComposition两种合成方式。硬件绘制和软件绘制如何查看硬件绘制HWUI draw会有Record View#draw()如图：systrace截图分析软件绘制SWUI draw会有drawSoftware lockCanvas如图：systrace截图分析view耗时太久如图：systrace截图分析可以分别查看测量、布局、以及软件/硬件绘制的过程。Draw绘制太长注意：systrace (don’t turn on hwui/gfx tag)如图：systrace截图分析查看Choreographer#doFrame时长。如图：systrace截图分析然后查看draw的耗时（注意是软件绘制SWUI）DrawFrame耗时注意：systrace (don’t turn on hwui/gfx tag)如图：systrace截图分析如果是标准60FPS帧率，则该函数耗时不要超过16.6msOpenGL API绘制是否正常需要以下的函数被systrace抓取到，则需要开启GL trace开关：adb shell setprop debug.egl.trace systraceadb shell stopadb shell start (or make sure your app restart)Run systrace (需要加上tag：view,input,freq,res,hwui/gfx)如图：systrace截图分析查看systrace的进程状态如图：systrace截图分析选中一个函数的区域（使用箭头）查看进程状态如图：systrace截图分析可以选择整个function的process state并确认统计信息,判断是否有runnable/sleep(D/S)过长的现象。如图：systrace截图分析以下是确定是哪个部分异常，进一步详细调查的方式。APP Owner（view模块异常）如果已经确定Measure/Layout 占的时间很多。adb shell setprop debug.view.systraceMeasure trueadb shell setprop debug.view.systraceLayout trueadb shell stopadb shell start (or make sure your app restart)抓取systrace again例如下面的例子， 可以发现ListView layout耗时过长。如图：systrace截图分析APP Owner（HWUI模块异常）到这一步已经没有异常耗时的draw operation, 所以主要是分析APP画图的行为。抓取方式：adb shell setprop debug.hwui.log.systrace 1adb shell dumpsys gfxinfo抓取 systrace again (must turn on view,input,freq,res,hwui/gfx)如图：systrace截图分析App owner (Consult SS)进入此状态大多是因为当下系统资源不足而导致，需要case by case 确认可以解决的方案。如图：systrace截图分析系统配置信息：需要先确定对比机和测试机的系统配置信息CPU cores/freq 可以直接参考systrace (需确认CPU_FREQUENCY event有打开)如图：systrace截图分析App owner (Consult SF合成)需要看trace判断具体问题方向，例如以下几种问题：Buffer是新的，但是内容还是和上一帧相同Mali GPU有种smart partial update机制（局部更新）, 不会整个buffer重刷。可以利用debug property先关闭, 视觉上比较容易看：adb shell setprop debug.gpu.hwcrc_disabled 1adb shell stopadb shell start如图：systrace截图分析检查buffer fence time同步时间如图：systrace截图分析强制GPU合成检查在开发者选项中打开GPU强制合成，如果关掉就正常, 问题方向转回到 HWC/driver。","tags":[{"name":"graphics","slug":"graphics","permalink":"http://wizzie.top/tags/graphics/"}]},{"title":"Android LCD背光驱动节电技术LABC/CABC","date":"2020-01-05T12:32:00.000Z","path":"2020/01/05/2020/200105_android_lcd_cabc/","text":"LCD背光驱动节电技术LABC/CABC手机屏幕大部分是LCD（还有OLED屏幕），而手机的部分电量就是LCD背光消耗的。随着分辨率/尺寸的增大，LCD的背光驱动电路也越来越复杂。而高分辨率、高显示颜色、大尺寸的LCD，需要大的背光系统、大的TFT-LCD 面版、高运算速度的驱动IC，这些都造成了高的功率消耗。主要了解一下背光驱动节电技术CABC的概念和功能。参考博客*OEM和ODMNote:OEM：自主加工，英文全称Original Equipment Manufacturer，即原设备生产商。原始设备生产商(OEM)是指拥有自己的产品或产品理念，但有时会为了开发和/或制造这些产品而购买某些服务的公司。ODM：自主设计，即ORIGINAL DESIGN MANUFACTURER，意为“原始设计制造商”，是指一家公司根据另一家公司的规格来设计和生产一个产品。例如，计算机公司如HP公司可能会就其想推向市场的一款笔记本电脑作出具体规格。它们会具体地列明产品的外观要求，如屏幕的尺寸和技术要求、输入/输出端口、键盘的前倾度、电脑包的外形和颜色、扬声器的位置等。它们还通常会具体列明对产品的主要内部细节如CPU或视频控制器的规格要求。但是，它们并不设计图样，不具体列明电源用的交换晶体管的型号，也不对背光变流器频率加以选择。这些都是ODM的工作。ODM根据计算机公司提出的规格要求来设计和生产笔记本电脑。有时候，ODM也可根据现有样品来生产。ODM方式往往更加注重合作，而在OEM的情形下，购买方对产品的具体规格基本不参与意见。OBM：自主品牌OEM和ODM的区别:OEM和ODM两者最大的区别不单单是名称而已。OEM产品是为品牌厂商度身订造的，生产后也只能使用该品牌名称，绝对不能冠上生产者自己的名称再进行生产。而ODM则要看品牌企业有没有买断该产品的版权。如果没有的话，制造商有权自己组织生产，只要没有企业公司的设计识别即可。在工业社会中，OEM和ODM可谓司空见惯。因为出于制造成本、运输方便性、节省开发时间等方面的考虑，知名品牌企业一般都愿意找其他厂商OEM或ODM。在找别的企业进行OEM或ODM时，知名品牌企业也要承担不少责任。毕竟产品冠的是自己的牌子，如果产品质量不佳的话，少则有顾客找上门投诉，重则可能要上法庭。所以，品牌企业在委托加工期间肯定会进行严格的质量控制。但代工结束后，质量不敢保证。故此，当有的商家告诉你某件产品的生产商是某大品牌的OEM或ODM产品时，绝不要相信其质量就等同于该品牌。你唯一能够相信的，是这家制造商有一定的生产能力。背光节电技术显示屏在移动设备里一直的是耗电大户。目前手机背光节电技术，即对应性背光控制技术（Adaptive Brightness Control- ABC），主要有下面2种：LABC：(LightAdaptive Brightness Control) 环境光侦测适应背光控制。根据环境光的变化来控制背光亮度。需要一个光传感器，感应环境光强。CABC：(ContentAdaptive Brightness Control）显示内容对应背光控制。根据显示内容来调节背光和gamma值，从而降低了背光LED的功耗。其中C是内容的意思，驱动IC新增了一个内容分析器电路。LABCLABC技术需要搭配光传感器实现，主机端处理器读取光感数值，然后处理器对数值进行处理，直接控制PMIC(MT6329)输出PWM控制背光的亮度。在比较暗光线下，降低背光达到省电效果CABCCABC功能需要在LCD驱动IC内新增一个内容分析器(imagecontent analyzer)电路，当手机处理器传送了一张图片数据到驱动IC，内容分析器会计算并统计图片的数据后依据设定与算法自动的将其灰阶亮度提高30%（此时图片变亮），再将背光亮度降低30%（此时图片变暗）。由于我们事先已经将图片经过分析器电路补偿亮度，因此使用者可以得到与原先电路相差无几的显示效果，但减少了30%的背光功耗。简单来说，CABC功能就是根据显示内容来降低背光，然后通过调节gamma(gamma越高灰度越低图像越暗)来补偿显示亮度。CABC就是通过增加内容灰阶标准同时降低背光亮度来达到省功耗的目的。CABC主要有四种状态：Off Mode，CABC功能全部关闭；UI Image Mode，优化显示UI图片时的功耗，尽可能的保证图片质量的同时可省10%的功耗；Still Image Mode，优化显示静态图片时的功耗，该模式下图片质量损耗在可接受的范围内，同时可省30%的功耗；Moving Image Mode，优化显示动态图片时的功耗，该模式下会最大限度的降低功耗，但是会带来图片质量的损耗，可省30%+的功耗。自然对应Off Mode，标准对应UI Mode，照片对应UI Mode，电影对应Still Image Mode。用户可根据实际情况自行选择。三种模式省电级别依次降低: UI mode &lt; Movie mode &lt; Still mode， 也就是说Still mode是最省电的模式。工作流程工作流程如下：使能PMIC(MT6329)CABC功能;设置LCD驱动IC的相关配置(使能CABC和配置gamma参数，需要FAE协助)；CABC模块分析显示内容输出LED_PWM信号给PMIC，PMIC通过一定算法控制driver模块BL_DRV信号的输出波形；预期结果是背光亮度降低，LCD驱动IC降低gamma值以补偿屏幕亮度。CABC模块分析显示内容输出PWM波形，占空比越大，表示需要输出的电流越大。","tags":[{"name":"display","slug":"display","permalink":"http://wizzie.top/tags/display/"}]},{"title":"Android SurfaceFlinger和HWC2概述","date":"2019-12-22T15:32:00.000Z","path":"2019/12/22/2019/191222_android_HWC2/","text":"转载夕月风大佬博客： https://www.jianshu.com/p/824a9ddf68b9参考Android Q AOSP源码添加修改部分内容参考源码： http://aosp.opersys.com/xref/android-10.0.0_r14/SurfaceFlinger概述大多数APP在屏幕通常显示三个部分：屏幕顶部的状态栏底部或者侧边的导航栏应用的界面有些应用会显示更多或者更少的层。例如主屏幕会有一个单独的壁纸层；全屏幕的游戏可能会隐藏状态栏目。这些可以通过Dump Surfacelinger查看BufferLayers部分的信息来获取具体信息（adb shell dumpsys SurfaceFlinger）。从Dump结果看，layer呈树形结构(Tree)分布。每个层都可以单独更新。状态栏和导航栏由系统进程渲染，而应用层由应用渲染，两者之间不进行协调。SurfaceFlinger类定义frameworks/native/services/surfaceflinger/SurfaceFlinger.h123456789class SurfaceFlinger : public BnSurfaceComposer, public PriorityDumper, private IBinder::DeathRecipient, private HWC2::ComposerCallback&#123;public: SurfaceFlingerBE&amp; getBE() &#123; return mBE; &#125; const SurfaceFlingerBE&amp; getBE() const &#123; return mBE; &#125; ......继承BnSurfaceComposer，实现ISurfaceComposer接口；实现ComposerCallback；继承辅助类PriorityDumper，主要提供SurfaceFlinger的Dump信息，并且提高提供信息的分离和格式设置。ISurfaceComposer接口实现ISurfaceComposer是提供给上层Client端的接口（Bp端），此处的SurfaceFlinger是Server端（Bn端）。接口内容包括：frameworks/native/include/gui/ISurfaceComposer.h123456789class ISurfaceComposer: public IInterface &#123;public: DECLARE_META_INTERFACE(SurfaceComposer) ...... /* returns information for each configuration of the given display * intended to be used to get information about built-in displays */ virtual status_t getDisplayConfigs(const sp&lt;IBinder&gt;&amp; display, Vector&lt;DisplayInfo&gt;* configs) = 0; ......接口在SurfaceFlinger中都有对应的方法实现。Client端通过Binder跨进程调到SurfaceFlinger中。获取Display的信息，其实现就是SurfaceFlinger的getDisplayConfig函数。ComposerCallback接口实现ComposerCallback是HWC2的callback接口，包括以下接口：frameworks/native/services/surfaceflinger/DisplayHardware/HWC2.h12345678910111213141516171819202122232425namespace HWC2 &#123;class Display;class Layer;// Implement this interface to receive hardware composer events.//// These callback functions will generally be called on a hwbinder thread, but// when first registering the callback the onHotplugReceived() function will// immediately be called on the thread calling registerCallback().//// All calls receive a sequenceId, which will be the value that was supplied to// HWC2::Device::registerCallback(). It's used to help differentiate callbacks// from different hardware composer instances.class ComposerCallback &#123; public: virtual void onHotplugReceived(int32_t sequenceId, hwc2_display_t display, Connection connection) = 0; virtual void onRefreshReceived(int32_t sequenceId, hwc2_display_t display) = 0; virtual void onVsyncReceived(int32_t sequenceId, hwc2_display_t display, int64_t timestamp) = 0; virtual ~ComposerCallback() = default;&#125;;.....Callback提供了注册接口registerCallback，在SurfaceFlinger初始化的时候注册：123456void SurfaceFlinger::init() &#123; ALOGI( \"SurfaceFlinger's main thread ready to run. \" \"Initializing graphics H/W...\");....mCompositionEngine-&gt;getHwComposer().registerCallback(this, getBE().mComposerSequenceId);....此处registerCallback的this就是SurfaceFlinger对ComposerCallback接口的实现。onHotplugReceived： 热插拔事件的回调，显示屏幕连接或者断开时回调。onRefreshReceived： 接收底层HWComposer的刷新请求。在repaintEverythingForHWC中，mRepaintEverything为true的时候，将触发一次刷新，重新进行合成显示。重新绘制说明底层配置、参数等有变动，SurfaceFlinger前面给的数据不能用，需要重新根据变动后的配置进行合成，给适合当前配置的显示数据。frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp123456789101112void SurfaceFlinger::onRefreshReceived(int sequenceId, hwc2_display_t /*hwcDisplayId*/) &#123; Mutex::Autolock lock(mStateLock); if (sequenceId != getBE().mComposerSequenceId) &#123; return; &#125; repaintEverythingForHWC();&#125;void SurfaceFlinger::repaintEverythingForHWC() &#123; mRepaintEverything = true; mEventQueue-&gt;invalidate();&#125;onVsyncReceived： Vsync事件上报，接收底层硬件上报的垂直同步信号。此处可以通过抓取Systrace的方式查看具体的Vsync的信息（底层硬件、SurfaceFlinger、APP三部分的Vsync，一般Android版本升级的时候会进行vsync的tuning）显示周期Vsync： 设备显示会按照一定速率更新（一般是一秒60帧，即16.6ms刷新一次）。如果显示内容在刷新期间更新，则会出现撕裂现象，因此必须在周期之间更新（这也是vsync tunning的必要性，保持SurfaceFlinger和draw frame都在vsync周期里面，并且不重叠）在可以安全更新内容时，系统便会接收来自显示设备的信号。刷新率可能会随时间而变化，例如一些设备的刷新范围在58fps至62fps之间，具体视当前条件而定。对于连接了HDMI的电视，刷新率在理论上可以下降到24Hz或者48Hz，以便和视频匹配。由于每个刷新周期只能更新屏幕一次，因此以200fps的刷新率为显示设备提交缓冲区并没有必要性，因为大部分桢不能被看到（人眼合适的是60fps）。SurfaceFlinger不会在应用提交缓冲区时进行操作，而是在显示设备准备好接收新缓冲区的时候才会唤醒。当Vsync信号到达的时候，SurfaceFlinger会遍历层列表，以寻找新的缓冲区。如果找到会获取该缓冲区，否则会使用以前获取的缓冲区。SurfaceFlinger总是需要可显示的内容，因此会保留一个缓冲区。如果在某个层没有提交缓冲区，则该层会被忽略。此处会在合成调用到handlePageFlip函数，函数中先调用latchBuffer从BufferQueue取Buffer，然后等待Vsync信号更新到FrameBuffer。合成方式： 目前SurfaceFlinger支持两种合成方式：一种是Device合成，一种是Client合成。SurfaceFlinger在收集可见层的所有缓冲区之后，便会询问HardwareComposer应该如何进行合成。Client合成：之前称之为GLES合成，也可以称之为GPU合成，该合成方式是相对于硬件合成来说的，将各个Layer的内容用GPU渲染到暂存缓冲区中，最后将暂存缓冲区传送到显示硬件Client合成采用RenderEngine进行合成。Device合成： 用专门的硬件合成器进行合成HWComposer，所以硬件合成的能力就取决于硬件的实现。其合成方式是将各个Layer的数据全部传给显示硬件，并告知它从不同的缓冲区读取屏幕不同部分的数据。HWComposer是Device合成的抽象。合成方式可以从Dump SurfaceFlinger中查看到Layer的具体合成方式，GPU合成一般可以通过开发者选项中启动，强制GPU合成；而Device合成在Dump信息中一般显示成SDE合成。GPU合成数据后，作为一个特殊的Layer传给显示硬件。12345678910111213141516171819202122232425262728293031Display 0 HWC layers:------------------------------------------------------------------------------- Layer name Z | Comp Type | Disp Frame (LTRB) | Source Crop (LTRB)------------------------------------------------------------------------------- com.android.systemui.ImageWallpaper#0 rel 0 | Client | 0 0 1080 2280 | 0.0 0.0 1080.0 2280.0- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - net.oneplus.launcher/net.oneplus.launcher.Launcher#0 rel 0 | Client | 0 0 1080 2280 | 0.0 0.0 1080.0 2280.0- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - StatusBar#0 rel 0 | Client | 0 0 1080 80 | 0.0 0.0 1080.0 80.0- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - GestureButtonRegion#0 rel 0 | Client | 0 2216 1080 2280 | 0.0 0.0 1080.0 64.0- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ScreenDecorOverlay#0 rel 0 | Device | 0 0 1080 106 | 0.0 0.0 1080.0 106.0- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ScreenDecorOverlayBottom#0 rel 0 | Device | 0 2198 1080 2280 | 0.0 0.0 1080.0 82.0- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -|-----|------------|-----------|------|-------------|--------------------------|---------------------|---------------------|----|------------|-----------|----|-----|| Idx | Comp Type | Split | Pipe | W x H | Format | Src Rect (L T R B) | Dst Rect (L T R B) | Z | Flags | Deci(HxV) | CS | Rng ||-----|------------|-----------|------|-------------|--------------------------|---------------------|---------------------|----|------------|-----------|----|-----|| 6 | GPU_TARGET | Pipe-1 | 94 | 1088 x 2288 | RGBA_8888_UBWC | 0 0 1080 2280 | 0 0 1080 2280 | 0 | 0x00000002 | 0 x 0 | 0 | 0 || 4 | SDE | Pipe-1 | 103 | 1088 x 112 | RGBA_8888_UBWC | 0 0 1080 106 | 0 0 1080 106 | 1 | 0x00000000 | 0 x 0 | 1 | 1 || 5 | SDE | Pipe-1 | 92 | 1088 x 96 | RGBA_8888_UBWC | 0 0 1080 82 | 0 2198 1080 2280 | 2 | 0x00000000 | 0 x 0 | 1 | 1 ||-----|------------|-----------|------|-------------|--------------------------|---------------------|---------------------|----|------------|-----------|----|-----|SurfaceFlingerBE: 从Android P上分离出来，定义上看是将Surfacelinger分离为前后端。消息队列和主线程： 和应用进程类似，SurfaceFlinger也有一个主线程，主要是进行显示数据的处理，即合成。Surfacelinger是一个服务，将会响应上层的请求，各个进程的请求都在SurfaceFlinger的各个Binder线程中，如果线程很耗时，那么应用端就会被block。主线程将他们分离开来，各干各的。Note：SurfaceFligner有两个状态，Layer也有两个状态，一个是mCurrentState，一个是mDrawingState。两个EventThread，一个是给SurfaceFlinger本身使用，一个是为了给应用分发事件的。mCurrentState和mDrawingState这两个成员是Layer类中Layer::State的类型。Layer.h123456789101112131415161718struct State &#123; Geometry active; //计算后的实际尺寸 Geometry requested; //用户设置的尺寸 int32_t z; //Layer的Z轴值，值越小位置就越靠小 uint32_t layerStack; //和显示设备的关联值 unit8_t alpha; //Layer的透明度 uint8_t flags; //Layer的标志（如果上次绘制后用户改变了Layer） uint8_t reserved[2]; int32_t sequence; //序列值，Layer的属性变化一次就会加一（例如setAlpha,setSize,setLayer等） ... // the transparentRegion hint is a bit special, it's latched only // when we receive a buffer -- this is because it's \"content\" // dependent. Region activeTransparentRegion; //实际的透明区域 Region requestedTransparentRegion; //用户中的透明区域 ...&#125;;Surfacelinger创建Surface的时候，会调用createLayer，然后调用addClientLayer函数，这里会把Layer对象放在mCurrentState的layerSortedByZ对象中。Surfacelinger合成的时候，调用preComposition函数，会先调用mDrawingState的layerSortedByZ来获取上次绘图的Layer层列表（并不是所有layer都参与屏幕图像的绘制，因此通过State对象记录参与绘制的Layer对象）Layer对象在绘制图形时，使用的是mDrawingState变量；用户调用接口设置Layer对象属性时，设置的值保存在mCurrentState中。这样就不会因为用户的操作而干扰Layer对象的绘制了。Layer::doTransaction函数会比较这两个成员变量，如果有不同的地方，说明上次绘制后，用户改变了Layer的属性，要把这种变化通过flags返回。layerStack字段是用户指定的一个值，用户可以给DisplayDevice指定一个layerStack值，只有Layer对象和DisplayDevice对象的layerStack相等，这个Layer才能在这个显示设备输出。这样的好处可以让显示设备只显示某个Surface的内容。例如，可以让HDMI显示设备只显示手机上播放的Surface窗口，但是不显示Activity窗口。Layer::doTransaction最后会调用commitTransaction函数，就是将mCurrentState赋值给mDrawingState。以上的是在Layer.cpp中的两个成员变量，而在SurfaceFlinger.cpp也有同名的mCurrentState和mDrawingState两个成员变量（定义在SurfaceFlinger.h中），定义不一样，只是名字相同。SF.h12345678910111213141516171819202122232425class State &#123;public: explicit State(LayerVector::StateSet set) : stateSet(set), layersSortedByZ(set) &#123;&#125; State&amp; operator=(const State&amp; other) &#123; // We explicitly don't copy stateSet so that, e.g., mDrawingState // always uses the Drawing StateSet. layersSortedByZ = other.layersSortedByZ; displays = other.displays; colorMatrixChanged = other.colorMatrixChanged; if (colorMatrixChanged) &#123; colorMatrix = other.colorMatrix; &#125; return *this; &#125; const LayerVector::StateSet stateSet = LayerVector::StateSet::Invalid; LayerVector layersSortedByZ; //保存所有参与绘制的Layer对象 DefaultKeyedVector&lt; wp&lt;IBinder&gt;, DisplayDeviceState&gt; displays; //保存所有输出设备的DisplayDeviceState对象 bool colorMatrixChanged = true; mat4 colorMatrix; void traverseInZOrder(const LayerVector::Visitor&amp; visitor) const; void traverseInReverseZOrder(const LayerVector::Visitor&amp; visitor) const;&#125;;SF.cpp中的handleTransactionLocked函数会根据eTraversalNeeded标志决定是否要检查所有的Layer对象。如果某个Layer对象有这个标志，将会调用他的doTransaction函数。Layer::doTransaction函数返回的flags如果有eVisibleRegion说明这个Layer需要更新，就把mVisibleRegionDirty设置为true。1234567891011121314151617181920212223242526272829void SurfaceFlinger::handleTransactionLocked(uint32_t transactionFlags)&#123; // Notify all layers of available frames mCurrentState.traverseInZOrder([](Layer* layer) &#123; layer-&gt;notifyAvailableFrames(); &#125;); /* * Traversal of the children * (perform the transaction for each of them if needed) */ if (transactionFlags &amp; eTraversalNeeded) &#123; mCurrentState.traverseInZOrder([&amp;](Layer* layer) &#123; uint32_t trFlags = layer-&gt;getTransactionFlags(eTransactionNeeded); if (!trFlags) return; const uint32_t flags = layer-&gt;doTransaction(0); if (flags &amp; Layer::eVisibleRegion) mVisibleRegionsDirty = true; &#125;); &#125; ......//这部分代码是根据每种显示设备的不同，设置和显示设备关联在一起的Layer（主要看LayerStack是否和DisplayDevice的layerStack相同）的TransformHint（主要指设备的显示方向orientation） commitTransaction(); updateCursorAsync();&#125;Note: handleTransaction的作用是处理系统在两次刷新期间的各种变化。Surfacelinger模块中不管是SurfaceFlinger类和Layer类硬件合成HWC2概述Hardware Composer HAL(HWC)是指硬件完成图像数据组合并显示的能力。SurfaceFlinger是一个系统服务（系统启动时启动），作用是接收来自多个源的Buffer数据，并进行合成，然后发送到显示设备进行显示。SurfaceFlinger和HWC的相互配合，实现Android系统的合成和显示（非GPU合成）。Android 7.0包含新版本的HWC（HWC2），Android需要自行配置。Android 8.0，HWC2正式开启，并且版本升级为2.1。（/frameworks/native/services/surfaceflinger/DisplayHardware/）HWC2是SurfaceFlinger用来与专门的窗口合成硬件进行通信（Device合成方式）。SurfaceFlinger包含使用3D图形处理器（GPU）执行窗口合成任务的备用途径，但是此路径并不理想（GPU合成方式），因为：通常，GPU没有针对此进行优化，因此能耗可能大于执行合成所需的能耗；每次SUrfaceFlinger使用GPU合成时，应用都无法使用处理器进行自我渲染，因此应尽可能使用专门的硬件而不是GPU进行合成。GPU（Client合成）和HWC（Client合成）两种方式对比：合成类型耗电情况性能情况Alpha处理DRM内容处理其他限制Device合成（HWC）耗电低性能高很多Vendor的HWC不支持Alpha的处理和合成基本都能访问DRM内容能合成的Surface层数有限，对每种Surface类型处理层数有限Client合成（GPU）耗电高性能低能处理每个像素的Alpha及每个Layer的Alpha早期版本GPU不能访问DRM的内容目前的处理层数没有限制Note:Alpha处理： 图片的透明度（0～255或者0.0f~1.0f），数值越小透明度越高DRM内容处理：（Digital Rights Management）一种业界使用广泛的数字内容版权保护技术。HWC常规准则Hardware Composer抽象层后的物理显示设备硬件可因设备而异。但是一般来说，遵循以下规则：HWC应至少支持4个叠加层（状态栏、系统栏、应用、壁纸/背景）层可以大于屏幕，因此HWC应能处理大于显示屏的层（例如壁纸）应该同时支持预乘每个像素Alpha混合和每个平面Alpha混合HWC应能够处理GPU、Camera、视频解码器（Video Decoder）生成的相同缓冲区，因此支持以下某些属性会很有帮助：RGBA打包顺序YUV格式Tiling,swizzling和步幅属性为了支持受保护的内容（Secure layer），必须提供受保护视频播放的硬件路径Note：RGBA是一种颜色值YUV是一种颜色编码格式，可以说YUV流媒体是原始流数据，大部分的视频领域都在使用。他与RGB类似，但RGB更多的用于渲染时，而YUV则用在数据传输，因为它占用更少的频宽。当然，实时通讯为了降低带宽都会采用H264/H265编码。从字面意思理解，YUV的含义:Y代表亮度信息（灰度），UV分别代表色彩信息。YUV的常用名称有许多，如YUV422这是大部分镜头出来的数据，还有许多（yuv420,yuv444等）Tiling简单来说就是将image进行切割，切成M * N小块，最后用的时候再进行拼接，类似铺瓷砖swizzling是一种拌和技术，这是向量的单元可以被任意的重新排放或重复HWC专注于优化，智能的选择要发送到叠加硬件的Surface，以最大限度减轻GPU的负载。另一种优化是检测屏幕是否正在更新；如果不是，这将合成委托给OpenGL而不是HWC，以节省电量。但屏幕再次更新时，继续将合成分发给HWC。为常见的用例做准备，比如：纵向和横向模式下的全屏游戏带着字幕和播放控件的全屏视频主屏幕（状态栏、系统栏目、应用、动态壁纸）受保护的视频播放多显示设备支持HWC2框架从Android 8.0开始的Treble项目，对Android架构做了调整，让制造商以更低的成本更加轻松快速的将设备更新到Android系统。这就对HAL层有了很大的调整，利用提供给Vendor的接口，将Vendor的实现和Android上层分离开来。这样的架构也使得HWC架构变得复杂，HWC属于Binderized的HAL类型。Binderized类型的HAL将上层Android和底层HAL分别采用两个不同的进程实现，中间采用Binder进行通信，为了和前面的Binder进行区别，这里采用HWBinder。可以将HWC分为以下几个部分：Binder 1：SurfaceFlinger ServiceHWC2 ClientBinder 2：HWC2 ServerHWC2 Vendor Impl具体解释：Client端：Client就是指SurfaceFlinger。不过SurfaceFlinger采用前后端设计，以后和HWC相关的逻辑应该会放到后端（SurfaceFlingerBE），即/frameworks/native/services/surfaceflinger/HWC Client端： 这一部分属于SurfaceFlinger进程，直接用过Binder通信，和HWC2的HAL Server交互。在SurfaceFlinger中采用namespace HWC2的命名空间，即frameworks/native/services/surfaceflinger/DisplayHardware/HWComposer.cpp。HWC2 Server端: 这里将建立一个进程实现HWC的Server端。服务端再调用底层Vendor的具体实现。并且，对于底层合成的实现不同，此处会做一些适配（适配HWC1.x），和FrameBuffer的实现。这部分包含三部分：接口、实现、服务，以动态库的形式存在：（hardware/interfaces/graphics/composer/2.1/default/）android.hardware.graphics.composer@2.1.soandroid.hardware.graphics.composer@2.1-impl.soandroid.hardware.graphics.composer@2.1-service.soHWC Vendor实现： 这部分是HWC的具体实现，由硬件厂商完成，（例如高通QCOM），代码一般是hardware/qcom/display/。HWC必须采用Binderized HAL模式，但是不一定要实现HWC2的HAL版本。HWC2的实现需要配置，以Android 8.0为例，包含：添加宏定义TARGET_USERS_HWC2编译打包HWC2相关的so库SELinux相关的权限添加配置manifest.xml：123456789&lt;hal format=\"hidl\"&gt; &lt;name&gt;android.hardware.graphics.composer&lt;/name&gt; &lt;transport&gt;hwbinder&lt;/transport&gt; &lt;version&gt;2.1&lt;/version&gt; &lt;interface&gt; &lt;name&gt;IComposer&lt;/name&gt; &lt;instance&gt;default&lt;/instance&gt; &lt;/interface&gt;&lt;/hal&gt;HWC2数据结构HWC2的一些常用接口定义在头文件hardware/libhardware/include/hardware/hwcomposer2.h中，一些共用的数据定义是HAL的接口中:hardware/interfaces/graphics/common/1.0/hardware/interfaces/graphics/composer/2.1/图层Layer每个Layer都有一组属性，用来定义和其他Layer的交互方式。他在每一个模块（层）代码定义的实现不一样，但是Layer的理念是一样的。SurfaceFlinger中12345678frameworks&#x2F;native&#x2F;services&#x2F;surfaceflinger├── Layer.h├── Layer.cpp├── ColorLayer.h├── ColorLayer.cpp├── BufferLayer.h└── BufferLayer.cpp|__ ...HWC2中123frameworks&#x2F;native&#x2F;services&#x2F;surfaceflinger&#x2F;DisplayHardware├── HWC2.h└── HWC2.cpp在HAL中实现时，定义为hwc2_layer_t，是在头文件hwcomposer2.h中定义的:typedef uint64_t hwc2_layer_t;HIDL中定义为Layer，这个Layer和hwc2_layer_t是一样的：typedef uint64_t Layer;Layer按照类型划分大致分为BufferLayer和COlorLayer（在SF中createLayer中），BufferLayer就是有Buffer的Lyaer（Bufferueue，GraphicsBuffer），需要上层应用Producer生长；ColorLayer可以绘制一种制定的颜色和透明度Alpha（取代之前的Dim Layer）。Layer按照数据划分大致分为RGB Layer和YUV Layer，前者是RGB格式，比较常见的就是UI界面的数据；后者的Buffer是YUV类型的，平常播放Video，Camera预览等，都是YUV类型的。Layer属性*Layer的属性定义他和其他模块（层）的关系，和显示屏（DeisplayDevice）的关系等。Layer包含的属性类别如下（上述也有部分内容）：位置属性定义层在其显示设备上的现实位置，包含层边缘的位置和其相对于其他层的Z-Order等，并且还定义了很多个区域Region：frameworks/native/services/surfaceflinger/Layer.h123456789class Layer : public virtual RefBase &#123; ... ...public: ... ... // regions below are in window-manager space Region visibleRegion; Region coveredRegion; Region visibleNonTransparentRegion; Region surfaceDamageRegion;Region中是很多个Rect的集合，即一个Layer的visibleRegion可能是几个Rect的集合（rect对象用来存储一个矩形框的左上角坐标、宽度和高度。描述矩形的宽度、高度和原点）SurfaceFlinger中定义的Region都是从上层（WMS）传递过来的。而在HWC中，是用的下面的结构描述：hardware/libhardware/include/hardware/hwcomposer_defs.h123456789101112131415161718192021222324252627282930313233typedef struct hwc_color &#123; uint8_t r; uint8_t g; uint8_t b; uint8_t a;&#125; hwc_color_t;typedef struct hwc_float_color &#123; float r; float g; float b; float a;&#125; hwc_float_color_t;typedef struct hwc_frect &#123; float left; float top; float right; float bottom;&#125; hwc_frect_t;typedef struct hwc_rect &#123; int left; int top; int right; int bottom;&#125; hwc_rect_t;typedef struct hwc_region &#123; size_t numRects; hwc_rect_t const* rects;&#125; hwc_region_t;Transform，这个在SurfaceFlinger中定义的一个重要的结构，意思是变换矩阵，是一个3*3的矩阵。联系流程：Rect &lt;- Region &lt;- Layer &lt;- State &lt;- Geometry &lt;- Transform &lt;- mat33Layer的两个状态：mCurrentState和mDrawingState，前者是给SurfaceFlinger的前段准备数据，后者是将数据给到合成。每个状态有两个Geometry的描述request（上层请求的）和active（当前正在使用的）。每个Geometry中有一个Transform矩阵，一个Transform包含一个mat33的整列。Transform中包含两部分，一部分是位置Postion，另一部分是真正的2D的变换矩阵。通过下面两个函数设置：（对应Layer中的setPostion和setMatrix函数，这是上层WMS设置下来的）frameworks/native/libs/ui/Transform.cpp12345678910111213141516171819202122void Transform::set(float tx, float ty)&#123; mMatrix[2][0] = tx; mMatrix[2][1] = ty; mMatrix[2][2] = 1.0f; if (isZero(tx) &amp;&amp; isZero(ty)) &#123; mType &amp;= ~TRANSLATE; &#125; else &#123; mType |= TRANSLATE; &#125;&#125;void Transform::set(float a, float b, float c, float d)&#123; mat33&amp; M(mMatrix); M[0][0] = a; M[1][0] = b; M[0][1] = c; M[1][1] = d; M[0][2] = 0; M[1][2] = 0; mType = UNKNOWN_TYPE;&#125;......内容属性定义显示的内容如何呈现（即Buffer）。Layer的显示，除了之前的几个区域Region描述，还有很多结构进一步描述才能显示，例如裁减（用来扩展内容的一部分以填充层的边界）和转换（用来显示旋转或者翻转的内容）等信息。HWCInfo结构体中包括了一些这样的信息：frameworks/native/services/surfaceflinger/CompositionEngine/include/compositionengine/impl/OutputLayerCompositionState.h123456789101112131415161718192021222324252627282930313233343536373839404142434445464748struct OutputLayerCompositionState &#123; // The region of this layer which is visible on this output Region visibleRegion; // If true, client composition will be used on this output bool forceClientComposition&#123;false&#125;; // If true, when doing client composition, the target may need to be cleared bool clearClientTarget&#123;false&#125;; // The display frame for this layer on this output Rect displayFrame; // The source crop for this layer on this output FloatRect sourceCrop; // The buffer transform to use for this layer o on this output. Hwc2::Transform bufferTransform&#123;static_cast&lt;Hwc2::Transform&gt;(0)&#125;; // The Z order index of this layer on this output uint32_t z; /* * HWC state */ struct Hwc &#123; explicit Hwc(std::shared_ptr&lt;HWC2::Layer&gt; hwcLayer) : hwcLayer(hwcLayer) &#123;&#125; // The HWC Layer backing this layer std::shared_ptr&lt;HWC2::Layer&gt; hwcLayer; // The HWC composition type for this layer Hwc2::IComposerClient::Composition hwcCompositionType&#123; Hwc2::IComposerClient::Composition::INVALID&#125;; // The buffer cache for this layer. This is used to lower the // cost of sending reused buffers to the HWC. HwcBufferCache hwcBufferCache; &#125;; // The HWC state is optional, and is only set up if there is any potential // HWC acceleration possible. std::optional&lt;Hwc&gt; hwc; // Debugging void dump(std::string&amp; result) const;&#125;;关系图：Layer显示结构图解释：Layer区域和屏幕区域，就是Layer和屏幕本身的大小区域sourceCrop：剪切区域，sourceCrop是对Layer进行剪切的，值截取部分Layer的内容进行显示；sourceCrop不超过Layer的大小，超过没有意义。displayFrame：显示区域，displayFrame表示Layer在屏幕上的显示区域，具体说来，是sourceCrop区域在显示屏上的显示区域。displayFrame一般来说，小于屏幕的区域。而displayFrame可能比sourceCrop大，可能小，这都是正常的，只是需要做缩放，这就是合成时需要处理的。visibleRegion：可见区域，displayFrame 区域不一定都能看到的，如果存在上层Layer，那么displayFrame区域可能部分或全部被盖住，displayFrame没有被盖住的部分就是可见区域visibleRegion。damageRegion 受损区域，或者称之为更新区域。damageRegion表示Layer内容被破坏的区域，也就是说这部分区域的内容变了，所以这个属性一般是和上一帧相比时才有意义。这算是对合成的一种优化，重新合成时，我们只去合成damageRegion区域，其他的可见区域还是用的上一帧的数据。visibleNonTransparentRegion：可见非透明区域。透明区域transparentRegion是可见区域visibleRegion的一部分，只是这一部分透明的看到的是底层Layer的内容。在SurfaceFlinger的Layer中定义visibleNonTransparentRegion，表示可见而又不透明的部分。coveredRegion：被覆盖的区域。表示Layer被TopLayer覆盖的区域，一看图就很好理解。从图中，你可以简单的认为是displayFrame和TopLayer区域重合的部分。注意： 这里之所以说简单的认为，这是因为HWC空间的区域大小是SurfaceFlinger空间的区域经过缩放，经过Transform旋转，移动等后才得出的，要是混淆了就理解不对了。合成属性（确认用哪种合成方式）定义层应如何与其他层合成。包括混合模式和用于Alpha合成的全层Alpha值等信息。总的说来，合成分为两个大类：GPU合成和HWC合成。根据具体的情况，分为下列几类：hardware/libhardware/include/hardware/hwcomposer2.h12345678enum class Composition : int32_t &#123; Invalid = HWC2_COMPOSITION_INVALID, Client = HWC2_COMPOSITION_CLIENT, Device = HWC2_COMPOSITION_DEVICE, SolidColor = HWC2_COMPOSITION_SOLID_COLOR, Cursor = HWC2_COMPOSITION_CURSOR, Sideband = HWC2_COMPOSITION_SIDEBAND,&#125;;释义：Client 相对HWC2硬件合成的概念，主要是处理BufferLayer数据，用GPU处理。Device HWC2硬件设备，主要处理BufferLayer数据，用HWC处理SolidColor 固定颜色合成，主要处理ColorLayer数据，用HWC处理或GPU处理。Cursor 鼠标标识合成，主要处理鼠标等图标，用HWC处理或GPU处理Sideband Sideband为视频的边频带，一般需要需要硬件合成器作特殊处理，但是也可以用GPU处理。在合成信息HWCInfo中，包含成的类型。通过Layer的setCompositionType方法进行指定：frameworks/native/services/surfaceflinger/Layer.cpp12345678910111213141516171819202122void Layer::setCompositionType(int32_t hwcId, HWC2::Composition type, bool callIntoHwc) &#123; if (getBE().mHwcLayers.count(hwcId) == 0) &#123; ALOGE(\"setCompositionType called without a valid HWC layer\"); return; &#125; auto&amp; hwcInfo = getBE().mHwcLayers[hwcId]; auto&amp; hwcLayer = hwcInfo.layer; ALOGV(\"setCompositionType(%\" PRIx64 \", %s, %d)\", hwcLayer-&gt;getId(), to_string(type).c_str(), static_cast&lt;int&gt;(callIntoHwc)); //默认true if (hwcInfo.compositionType != type) &#123; ALOGV(\" actually setting\"); hwcInfo.compositionType = type; if (callIntoHwc) &#123; auto error = hwcLayer-&gt;setCompositionType(type); //合成方式 ALOGE_IF(error != HWC2::Error::None, \"[%s] Failed to set \" \"composition type %s: %s (%d)\", mName.string(), to_string(type).c_str(), to_string(error).c_str(), static_cast&lt;int32_t&gt;(error)); &#125; &#125;&#125;确定合成类型分成三步：SurfaceFlinger制定合成类型，此时callIntoHwc=true，将类型制定给HWCHWC根据实际情况看SurfaceFlinger制定的合成类型是否可以执行，如果不满足，作出修改SurfaceFlinger根据HWC的修改情况再作出调整，最终确认合成类型，此时callIntoHwc=false优化属性提供一些非必须的参数，以供HWC进行合成的优化。包括层的可见区域以及层的哪个部分自上一帧以来已经更新等信息。也就是前面说到的visibleRegion，damageRegion等。小结本篇主要是SurfaceFlinger概述，和HWC2的概述，还有Layer的属性和类型，合成方式的内容。另外还有关于HWC的内容，和Display显示设备的信息重新划分单独的一篇学习。","tags":[{"name":"graphics","slug":"graphics","permalink":"http://wizzie.top/tags/graphics/"}]},{"title":"Android Binder实例","date":"2019-11-24T07:59:40.000Z","path":"2019/11/24/2019/191124_android_binder_example/","text":"Binder通信是Android用的比较多的一种通信机制，它是一种client-server的通信结构。Binder通信具有以下特点：用驱动程序来推进进程间的通信；可以通过共享内存的方式来提供性能；可以为进程请求分配每个进程的线程池；针对系统中的对象引入了引用计数和跨进程的对象引用映射；可以方便的进行进程同步调用。以下简单的Binder实例参考一位大佬。文件目录12345678910111213141516cmds&#x2F;helloWorld&#x2F;Android.mk | 29 +++++++++++++++++++++++cmds&#x2F;helloWorld&#x2F;BnHelloWorldService.h | 16 +++++++++++++cmds&#x2F;helloWorld&#x2F;BpHelloWorldService.h | 12 ++++++++++cmds&#x2F;helloWorld&#x2F;HelloWorldService.h | 17 +++++++++++++cmds&#x2F;helloWorld&#x2F;IHelloWorldService.h | 21 +++++++++++++++++cmds&#x2F;helloWorld&#x2F;main_helloworldclient.cpp | 36 ++++++++++++++++++++++++++++cmds&#x2F;helloWorld&#x2F;main_helloworldservice.cpp | 22 +++++++++++++++++libs&#x2F;helloWorld&#x2F;Android.bp | 38 ++++++++++++++++++++++++++++++libs&#x2F;helloWorld&#x2F;BnHelloWorldService.cpp | 24 +++++++++++++++++++libs&#x2F;helloWorld&#x2F;BnHelloWorldService.h | 16 +++++++++++++libs&#x2F;helloWorld&#x2F;BpHelloWorldService.cpp | 25 ++++++++++++++++++++libs&#x2F;helloWorld&#x2F;BpHelloWorldService.h | 12 ++++++++++libs&#x2F;helloWorld&#x2F;HelloWorldService.cpp | 33 ++++++++++++++++++++++++++libs&#x2F;helloWorld&#x2F;HelloWorldService.h | 17 +++++++++++++libs&#x2F;helloWorld&#x2F;IHelloWorldService.cpp | 8 +++++++libs&#x2F;helloWorld&#x2F;IHelloWorldService.h | 21 +++++++++++++++++cmds/helloWorld/Android.mk1234567891011121314151617181920212223242526272829# Copyright 2019 The Android Open Source Project#LOCAL_PATH:= $(call my-dir)include $(CLEAR_VARS)LOCAL_SRC_FILES := main_helloworldservice.cppLOCAL_SHARED_LIBRARIES :=\\ libutils \\ libbinder \\ libhelloworldbase := $(LOCAL_PATH)/../../libs/helloWorldLOCAL_MODULE := helloworldserviceinclude $(BUILD_EXECUTABLE)include $(CLEAR_VARS)LOCAL_SRC_FILES := main_helloworldclient.cppLOCAL_SHARED_LIBRARIES :=\\ libutils \\ libbinder \\ libhelloworldbase := $(LOCAL_PATH)/../../libs/helloWorldLOCAL_MODULE := helloworldclient //编译结果so文件include $(BUILD_EXECUTABLE)cmds/helloWorld/BpHelloWorldService.h客户端Service头文件，声明BpHelloWorldService函数1234567891011#include &lt;binder/Parcel.h&gt;#include &lt;IHelloWorldService.h&gt;namespace android&#123;class BpHelloWorldService: public BpInterface&lt;IHelloWorldService&gt;&#123;public: BpHelloWorldService (const sp&lt;IBinder&gt;&amp; impl); virtual status_t helloWorld(const char *str);&#125;;&#125;;cmds/helloWorld/BnHelloWorldService.hBn服务端Service头文件，声明onTranscat接口1234567891011121314#ifndef ANDROID_BNHELLOWORLD_H#define ANDROID_BNHELLOWORLD_H#include &lt;binder/Parcel.h&gt;#include &lt;IHelloWorldService.h&gt;namespace android &#123;class BnHelloWorldService : public BnInterface&lt;IHelloWorldService&gt;&#123; public: virtual status_t onTransact ( uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags = 0 );&#125;;&#125;;#endifcmds/helloWorld/HelloWorldService.hBn服务端实现类的头文件，声明helloworld和onTransact函数，和私有类构造函数和析构函数和另一个库的文件同名，继承Bn服务端接口12345678910111213141516#include &lt;BnHelloWorldService.h&gt;#include &lt;utils/Log.h&gt;namespace android &#123;class HelloWorldService : public BnHelloWorldService&#123;public: static void instantiate(); virtual status_t helloWorld(const char *str); virtual status_t onTransact( uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags);private: HelloWorldService(); virtual ~HelloWorldService();&#125;;&#125;;cmds/helloWorld/IHelloWorldService.hBp和Bn端的中间接口头文件1234567891011121314151617181920#ifndef ANDROID_HELLOWORLD_H#define ANDROID_HELLOWORLD_H#include &lt;binder/IInterface.h&gt;namespace android &#123;enum &#123; HW_HELLOWORLD = IBinder::FIRST_CALL_TRANSACTION,&#125;;class IHelloWorldService: public IInterface &#123; public: DECLARE_META_INTERFACE(HelloWorldService); virtual status_t helloWorld(const char *str) = 0;&#125;;&#125;;#endifcmds/helloWorld/main_helloworldclient.cpp12345678910111213141516171819202122232425262728293031323334353637#define LOG_TAG \"main_helloworldclient\"#include &lt;binder/IPCThreadState.h&gt;#include &lt;binder/ProcessState.h&gt;#include &lt;binder/IServiceManager.h&gt;#include &lt;utils/Log.h&gt;#include &lt;utils/RefBase.h&gt;#include &lt;IHelloWorldService.h&gt;using namespace android;#define unused(x) x=xint main(int argc, char *argv[])&#123;//ALOGI(\"HelloWorldService client is now starting\");unused(argc);unused(argv);sp&lt;IServiceManager&gt; sm = defaultServiceManager();sp&lt;IBinder&gt; b;sp&lt;IHelloWorldService&gt; sHelloWorldService;do &#123; b = sm-&gt;getService(String16(\"android.apps.IHelloWorldService\")); if (b!=0) break; //ALOGI(\"helloworldservice is not working, waiting ...\"); usleep(500000);&#125; while(true);sHelloWorldService = interface_cast&lt;IHelloWorldService&gt;(b);sHelloWorldService -&gt; helloWorld(\"hello, world\");return(0);&#125;cmds/helloWorld/main_helloworldservice.cpp123456789101112131415161718192021#include &lt;binder/IPCThreadState.h&gt;#include &lt;binder/ProcessState.h&gt;#include &lt;binder/IServiceManager.h&gt;#include &lt;utils/Log.h&gt;#include &lt;IHelloWorldService.h&gt;#include &lt;HelloWorldService.h&gt;using namespace android;#define unused(x) x=xint main(int argc, char *argv[])&#123; unused(argc); unused(argv); HelloWorldService::instantiate(); ProcessState::self()-&gt;startThreadPool(); //ALOGI(\"HelloWorldService is starting now\"); //ALOGI(\"HelloWorldService is starting now tempChar = %s\", tempChar); IPCThreadState::self()-&gt;joinThreadPool(); return 0;&#125;libs/helloWorld/Android.bp1234567891011121314151617181920212223242526272829303132333435363738// Copyright (C) 2010 The Android Open Source Project//// Licensed under the Apache License, Version 2.0 (the \"License\");// you may not use this file except in compliance with the License.// You may obtain a copy of the License at//// http://www.apache.org/licenses/LICENSE-2.0//// Unless required by applicable law or agreed to in writing, software// distributed under the License is distributed on an \"AS IS\" BASIS,// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.// See the License for the specific language governing permissions and// limitations under the License.cc_library_shared &#123; name: \"libhelloworld\", srcs: [ \"BnHelloWorldService.cpp\", \"BpHelloWorldService.cpp\", \"HelloWorldService.cpp\", \"IHelloWorldService.cpp\", ], shared_libs: [ \"libcutils\", \"liblog\", \"libutils\", \"libbinder\", ], include_dirs: [\"frameworks/base/cmds\"], //上面创建的库 cflags: [ \"-Wall\", \"-Wextra\", \"-Werror\", ],&#125;libs/helloWorld/BnHelloWorldService.h123456789101112131415#ifndef ANDROID_BNHELLOWORLD_H#define ANDROID_BNHELLOWORLD_H#include &lt;binder/Parcel.h&gt;#include &lt;IHelloWorldService.h&gt;namespace android &#123;class BnHelloWorldService : public BnInterface&lt;IHelloWorldService&gt;&#123; public: virtual status_t onTransact ( uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags = 0 );&#125;;&#125;;#endiflibs/helloWorld/BnHelloWorldService.cpp123456789101112131415161718192021222324#include &lt;BnHelloWorldService.h&gt;#include &lt;binder/Parcel.h&gt;namespace android &#123;status_t BnHelloWorldService::onTransact(uint32_t code, const Parcel &amp;data, Parcel *reply, uint32_t flags)&#123; switch(code) &#123; case HW_HELLOWORLD: &#123; CHECK_INTERFACE(IHelloWorldService, data, reply); //检查接口 const char *str; str = data.readCString(); //读取数据 reply-&gt; writeInt32(helloWorld(str)); //写入数据 return NO_ERROR; &#125; break; default: return BBinder::onTransact(code, data, reply, flags); //服务端接口接收数据 &#125;&#125;&#125;libs/helloWorld/BpHelloWorldService.h123456789101112#include &lt;binder/Parcel.h&gt;#include &lt;IHelloWorldService.h&gt;namespace android&#123;class BpHelloWorldService: public BpInterface&lt;IHelloWorldService&gt;&#123;public: BpHelloWorldService (const sp&lt;IBinder&gt;&amp; impl); virtual status_t helloWorld(const char *str);&#125;;&#125;;libs/helloWorld/BpHelloWorldService.cpp12345678910111213141516171819202122232425#include &lt;binder/Parcel.h&gt;#include &lt;BpHelloWorldService.h&gt;#include &lt;utils/Log.h&gt;namespace android&#123;status_t BpHelloWorldService::helloWorld(const char *str) &#123; Parcel data, reply; data.writeInterfaceToken( IHelloWorldService::getInterfaceDescriptor()); data.writeCString(str); //写入数据 status_t status = remote()-&gt;transact(HW_HELLOWORLD, data, &amp;reply); //远程传输数据 if (status != NO_ERROR) &#123; ALOGI(\"print helloworld error : %s\", strerror(-status)); &#125; else &#123; status = reply.readInt32(); //读取数据 &#125; return status;&#125;BpHelloWorldService::BpHelloWorldService (const sp&lt;IBinder&gt;&amp; impl) : BpInterface&lt;IHelloWorldService&gt;(impl)&#123;&#125;&#125;;libs/helloWorld/HelloWorldService.h1234567891011121314151617#include &lt;BnHelloWorldService.h&gt;#include &lt;utils/Log.h&gt;namespace android &#123;//继承Bn服务端class HelloWorldService : public BnHelloWorldService&#123;public: static void instantiate(); virtual status_t helloWorld(const char *str); virtual status_t onTransact( uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags);private: HelloWorldService(); virtual ~HelloWorldService();&#125;;&#125;;libs/helloWorld/HelloWorldService.cpp123456789101112131415161718192021222324252627282930313233#include &lt;binder/IServiceManager.h&gt;#include &lt;binder/IPCThreadState.h&gt;#include &lt;BnHelloWorldService.h&gt;#include &lt;HelloWorldService.h&gt;#include &lt;utils/Log.h&gt;namespace android &#123;void HelloWorldService::instantiate() &#123; defaultServiceManager()-&gt;addService( String16(\"android.apps.IHelloWorldService\"), new HelloWorldService());&#125;status_t HelloWorldService::helloWorld(const char* str) &#123; ALOGI(\"%s\\n\", str); printf(\"%s\\n\", str); return NO_ERROR;&#125;HelloWorldService::HelloWorldService()&#123; ALOGI(\"HelloWorldService is created\");&#125;HelloWorldService::~HelloWorldService()&#123; ALOGI(\"HelloWorldService is destroyed\");&#125;status_t HelloWorldService::onTransact( uint32_t code, const Parcel&amp; data, Parcel* reply, uint32_t flags)&#123; return BnHelloWorldService::onTransact(code, data, reply, flags);&#125;&#125;;libs/helloWorld/IHelloWorldService.h1234567891011121314151617181920#ifndef ANDROID_HELLOWORLD_H#define ANDROID_HELLOWORLD_H#include &lt;binder/IInterface.h&gt;namespace android &#123;enum &#123; HW_HELLOWORLD = IBinder::FIRST_CALL_TRANSACTION,&#125;;class IHelloWorldService: public IInterface &#123; public: DECLARE_META_INTERFACE(HelloWorldService); virtual status_t helloWorld(const char *str) = 0;&#125;;&#125;;#endiflibs/helloWorld/IHelloWorldService.cpp12345678#include &lt;IHelloWorldService.h&gt;#include &lt;BpHelloWorldService.h&gt;namespace android &#123;IMPLEMENT_META_INTERFACE(HelloWorldService, \"android.apps.IHelloWorldService\");&#125;;","tags":[{"name":"graphics","slug":"graphics","permalink":"http://wizzie.top/tags/graphics/"}]},{"title":"Android Graphics 调试技巧（十一月份更新）","date":"2019-11-23T15:52:00.000Z","path":"2019/11/23/2019/191121_android_debug2/","text":"更新adb更新命令： sudo apt-get install android-tools-adb查看当前adb指令的目录: which adb查看版本：adb versionadb shell相关ps（正在运行的进程）12345678USER 进程当前用户PID 进程IDPPID 父进程IDVSZ 进程的虚拟内存大小，以KB为单位RSS 实际占用的内存大小，以KB为单位WCHAN 进程正在睡眠的内核函数名称；该函数的名称是从&#x2F;root&#x2F;system.map文件中获得的。PC 计算机中提供要从[存储器]中取出的下一个指令地址的[寄存器]NAME 进程状态及名称top（CPU使用率）top命令提供了实时的对系统处理器的状态监视。它将显示系统中CPU最“敏感”的任务列表。该命令可以按CPU使用，内存使用和执行时间对任务进行排序。VIRT：这个内存使用就是一个应用占有的地址空间，只是要应用程序要求的，就全算在这里，而不管它真的用了没有。写程序怕出错，又不在乎占用的时候，多开点内存也是很正常的;RES：resident memory usage。常驻内存。这个值就是该应用程序真的使用的内存，但还有两个小问题，一是有些东西可能放在交换盘上了（SWAP），二是有些内存可能是共享的;SHR：shared memory。共享内存。就是说这一块内存空间有可能也被其他应用程序使用着;DATA：数据占用的内存。这一块是真正的该程序要求的数据空间，是真正在运行中要使用的。vmstat（显示系统信息的）vmstat是一个显示系统信息的命令。例如，它显示主存储器的可用容量和CPU的操作状态。如果按原样执行vmstat命令，则会显示有关当前进程，内存，交换，设备，中断和CPU的信息。此外，如果附加“ - d”或“ - p”选项，将显示分区和磁盘上的读/写状态等。指定“-f”选项时，从系统启动到命令执行将显示创建进程的次数。如果在vmstat之后指定以秒为单位的时间间隔，则每隔指定时间显示一次系统状态。此外，当您指定次数时，会显示指定的信息次数。对于容量，可以使用“-S”选项指定单位。指定“-SM”时，容量单位以M字节显示。例如：以10秒为间隔显示内存和CPU信息三次： vmstat 10 3meminfo（内存系统信息）cat /proc/meminfofree（显示内存使用情况）可以知道当前的内存使用情况。12345-b 以字节显示容量（默认）-k 显示容量，以千字节为单位-m 显示容量，以MB为单位-h 显示容量单位，包含Ｇ、Ｍ-t 还显示物理内存和交换内存的总和strace（跟踪进程执行时的系统调用和所接收的信号）strace常用来跟踪进程执行时的系统调用和所接收的信号。在Linux世界，进程不能直接访问硬件设备，当进程需要访问硬件设备(比如读取磁盘文件，接收网络数据等等)时，必须由用户态模式切换至内核态模式，通 过系统调用访问硬件设备。strace可以跟踪到一个进程产生的系统调用,包括参数，返回值，执行消耗的时间。通用的完整用法：strace -o output.txt -T -tt -e trace=all -p 12345上面的含义是跟踪28979进程的所有系统调用（-e trace=all），并统计系统调用的花费时间，以及开始时间（并以可视化的时分秒格式显示），最后将记录结果存在output.txt文件里面。time（linux命令，ADB通用）测量从调用指定命令到结束所花费的时间，用户CPU时间和系统CPU时间。在指定命令的输出结果之后，将测量结果输出到标准错误输出。命令代码实际使用CPU的时间是用户CPU时间。因此，如果将不存在的命令作为time命令的参数，则用户CPU时间变为0。睡眠时间不计算在内。例如：显示ls命令的执行时间： time ls -a123real 0m0.006suser 0m0.006ssys 0m0.000ssize显示一个目标文件或者链接库文件中的目标文件的各个段的大小(可执行文件段的大小,默认为a.out)例如（linux下）： size libui.sotext表示正文段大小，data表示包含静态变量和已经初始化（可执行文件包含了初始化的值）的全局变量的数据段大小，bss由可执行文件中不含其初始化值的全局变量组成。file（辨识文件类型）file确定并显示文件类型，例如可执行文件或文本或其他数据。例如：file libui.so或者 adb shell file ……1234-b 以简单模式显示-i 使文件成为mime类型字符串-z 还要检查压缩文件-v 显示版本fastboot相关重启进入Recovery界面： adb reboot recovery重启进入bootloader界面： adb reboot bootloader进入Recovery模式查看设备： adb devicesadb rootadb shell进入fastboot： adb reboot fastbootfastboot devices查看当前使用分区： fastboot getvar current-slot接着擦除分区和用户数据，然后flash烧录如果不能识别或者没权限，优先检查lsusb添加序列号到/etc/udev/rules.d/如果出现错误:no permissions fastboot用fastboot命令查看设备提示无权限，如下：12fastboot -l devicesno permissions fastboot usb:1.2-1因为权限问题，是fastboot没有权限， 解决步骤：将fastboot的所有者属性改成root,用which fastboot命令找到fastboot所在的目录，然后进入此目录用命令chown改其属性:sudo chown root:root fastboot将其权限更改一下：sudo chmod +s fastboot还存在一种可能性，就是adb版本过低。部分参数fastboot [options]Notes-w清空用户数据分区和缓存分区.相当于recovery中的”wipe data/factoryreset”-s &lt;串口号&gt;指定要操作的设备的串口号-p &lt;产品名&gt;指定要操作的设备的产品名.比如hero,bravo,dream…-c &lt;命令行&gt;用命令行替换系统的启动命令行解析so文件addr2lineaddr2line [address] -e test.so -f或者readelf -a [.so/.bin]根据解析结果查询函数C++在linux系统编译后会变成类似_ZNK...的修饰名。使用c++filt获取函数的原始名称：c++filt [_ZNK...函数修饰名]跳过开机向导adb shell settings put global device_provisioned 1（默认是0）Android 10 AOSP源码打开模拟Vsync（Systrace可查看）源码： Android 10的AOSP方法： 修改surfaceflinger/Scheduler/DispSync.cpp的static const bool kEnableZeroPhaseTracer = false;为True另外在查看ZeroPhaseTracer还需要打开mTraceDetailedInfo，即const bool mTraceDetailedInfo = true;对比文件和文件夹区别（可用于git解决冲突）meld 文件/文件夹比较文件: vimdiff a.txt b.txtrepoAndroid代码包含几百个git库，下载和管理都需要一个方便的工具，Google开发了repo用来管理多个git库，通过manifest.xml文件将一个个的git库管理起来,形成一个系统。GerritGerrit是Google开发的一个代码审核工具。它是一个Web工具,它靠git来存放代码,靠repo这个接口来提交和下载修改。 提交到Gerrit时,每个Git库的修改都会变成一次提交,每个提交可以有一个或多个人来review和verify。当你的修改被批准之后,Gerrit会把修改真正提交到指定的分支中。Gerrit上代码提交的三种状态：Open、Merged、AbandonedOpen: 状态的代码需要经过Review,Verify,Submit操作后才会真正入库,即成为Merged状态Merged: 状态的代码已经入库,不能再Abandoned,只能RevertOpen: 状态的代码由于各种原因不能入库的可以放弃,即Abandoned状态。Abandoned 状态的代码不能再入库,如有需要,可以“Restore”。Jenkins一个持续集成工具,一个运行任务的平台。能实施编译、监控集成中存在的错误，提供详细的日志文件和提醒功能。能用图表形象地展示项目构建的趋势和稳定性。repo链接指定版本的manifest.xmlrepo init -m manifest_TEST.xml然后可以在目录查看结果，再同步代码。ssh生成publickey（指定邮箱）ssh-keygen -t rsa -C ****@mail.comGit相关命令git用户设置git config --global user.name ***git config --global user.email ****@mail.com查看config： git config -l生成补丁git format-patch -1 [最近的提交CommitID]生成指定某个commit提交的补丁git format-patch abc123d^..abc123d获取补丁申请生成在本地，但是没有加入暂存区： git apply [PatchA]直接申请生成提交： git am [PatchB]git add用法git add .:提交所有修改的文件,包括新增文件,不包括删除文件git add -u:提交所有修改文件,包括删除文件,不包括新增文件git add -A:提交包括新增和删除文件的所有文件从暂存区域移除等其他命令CommandNotesgit rm从暂存区域移除,并连带从工作目录中删除指定的文件git rm -f如果删除之前修改过并且已经放到暂存区域的话,则必须要用强制删除选项-fgit reset HEAD…取消对文件的修改,把之前版本的文件复制过来重写此文件。git checkout –…取消已经暂存的文件git clean删除未暂存的文件git diff查看尚未暂存的文件更新了哪些部分(和暂存区中)git diff –cached看已经暂存起来的文件和上次提交时的快照之间的差异git log –graph显示图形表示的分支合并历史git log –since=2.weeks列出所有最近两周内的提交git log –p以patch形式显示提交git log -p -2常用 -p 选项展开显示每次提交的内容差异，用 -2 则仅显示最近的两次更新git log –stat仅显示简要的增改行数统计。GDB命令CommandNotesbt查看各级函数调用及参数bt full详细堆栈信息bt PID查看PID信息frame选择栈帧info locals查看当前栈帧局部变量的值info registers可以看函数入参thread n切换到线程ninfo threads查看线程disassemble反汇编（默认范围是选择帧的pc附近的函数）info frame选择堆栈帧info args显示函数参数和局部变量的内容info reg（或者i r）查看地址disas反汇编查看函数（包含地址信息）i proc m （info proc mappings 的简写）核查零是不是有效地址Bt跟踪堆栈的信息: bt [-a|-g|-r|-t|-T|-l|-e|-E|-f|-F|-o|-O] [-R ref] [-I ip] [-S sp] [pid | task]1234Bt 无参数则显示当前任务的堆栈信息Bt –a 以任务为单位，显示每个任务的堆栈信息Bt –t 显示当前任务的堆栈中所有的文本标识符Bt –f 显示当前任务的所有堆栈数据，通过用来检查每个函数的参数传递mod命令用来加载调试符号，有时一些结构或者函数的符号信息不在调试版本内核里面，需要用gcc -g选项编译自己的模块，然后用mod命令加载里面的调试信息。这样sym和whatis命令就能正确解释我们自己模块里面自定义的结构等信息。ffmpeg 转换jpg和png格式ffmpeg -i test.png test1.jpg远程服务器使用ssh链接并且映射在用户根目录的.bashrc添加：链接：alias sshTest=&#39;function _ssh() { echo &quot;提示信息&quot;; ssh -p 端口 服务器用户名@IP; unset -f ssh; }; _ssh&#39;映射：alias sshreferenceTest=&#39;echo &quot;提示信息&quot;;sshfs -p 端口 -o cache=yes,reconnect 服务器用户名@IP:/home/服务器映射目录 /home/user/本地映射目录&#39;执行source .bashrc生效如果服务器映射报错bad mount point/mnt/‘: Transport endpoint is not connected`解决方法：sudo umount --all（或者指定目录）重新mount，即sudo mount --alllinux下修改图片尺寸（jpg、png…）sudo apt-get install imagemagickconvert example.png -resize 200×100 example.png //按照原有比例缩放convert example.png -resize 200×100! example.png查看网络地址情况route -n文件压缩、解压zip文件：zip -r a.zip /dir直接unzip解压tar.bz：Linux下压缩比率较tgz大，即压缩后占用更小的空间，使得压缩包看起来更小。但同时在压缩，解压的过程却是非常耗费CPU时间。打包压缩格式，举例：tar -jcvf file.tar.bz2 dir #dir目录解压，举例：tar -jxvf file.tar.bz2tar -jxvf file.tar.bz2 -C /templs 命令CommandNotesls -a列出文件下所有的文件，包括以“.“开头的隐藏文件（Linux下文件隐藏文件是以.开头的，如果存在..代表存在着父目录）。ls -l列出文件的详细信息，如创建者，创建时间，文件的读写权限列表等等。ls -F在每一个文件的末尾加上一个字符说明该文件的类型。”@”表示符号链接、”ls -s在每个文件的后面打印出文件的大小。 size(大小)ls -t按时间进行文件的排序 Time(时间)ls -A列出除了”.”和”..”以外的文件。ls -R将目录下所有的子目录的文件都列出来，相当于我们编程中的“递归”实现ls -L列出文件的链接名。Link（链接）ls -S以文件的大小进行排序ls -h显示文件大小firefox修改中文打开浏览器，在地址栏中输入about:config，然后按下回车。在列表中找到“general.useragent.locale”，然后双击，将内容改为”zh-CH”重启之后就会默认为中文了（注：如果想改回英文就改为: en-US )Ubuntu系统log路径/var/log查看: ls -tlhidl接口生成命令hidl-gen是Android架构HIDL编译工具，可以手动将哈希加到current.txt中，也可以使用以下命令添加：hidl-gen -L hash -r .../interfaces -r android.hidl:...","tags":[{"name":"graphics","slug":"graphics","permalink":"http://wizzie.top/tags/graphics/"}]},{"title":"Android @hide接口注释","date":"2019-11-03T04:32:00.000Z","path":"2019/11/03/2019/191103_android_hideDoc/","text":"@hide和{@hide}类或API是否开放是通过doc的注释｛＠hide｝来控制的比如android.media.Metadata这个类就是android没有公开的类因为在frameworks\\base\\media\\libmedia\\Metadata.java文件中，定义Metadata类之前有/*｛＠hide｝/doc注释，所以Metadata类被定义为了非公开类，即在android应用程序中无法直接访问的类google 给了两个选择：在你添加的API或者变量前面增加javadoc 注释＠hide，但是要注意并不是简单写个＠hide或者 /@hide/就可以了，这些都是错误的javadoc注释格式。标准的javadoc都是这样的 /** / 而且对于 format 变量应该加上 { }，所以我们应该这样写/* {@hide} */想要生成的javadoc里面出现这个方法或者变量，你必须输入:make update-api。但是如果修改的是google没有开放出来的类，比如RIL、PhoneFactory，就不会出现这个问题。访问被@hide的API（android 如何引用@hide（隐藏）的类，方法和常量）直接将@hide标记去掉，将重新编译了的android.jar包换掉不过强烈的建议不要这样做，别人隐藏起来的类或者方法肯定是不安全的，如果你把@hide放出来可能引起一些程序不可预知的错误。利用反射机制使用@hide方法，这种方法在网上看到一篇不错的，简单易懂，要深入的自己再到网上搜修改android.mk文件删除LOCAL_SDK_VERSION := current将LOCAL_SDK_VERSION 注释掉之后提到服务器编译出现了代码混淆错误。这个时候可以在android.mk文件中将LOCAL_PROGUARD_ENABLED := disabled加上。LOCAL_PROGUARD_ENABLED := disabled不使用代码混淆的工具进行代码混淆,如果不设置，默认使用LOCAL_PROGUARD_ENABLED := full.即将该工程代码全部混淆。Android 10的变化在Android 10对非SDK接口进行了限制，因而@hide注释的方法被列入黑名单，外部不能访问。但是可以通过adb shell settings put global hidden_api_policy 1命令打开权限访问。通过adb shell settings delete global hidden_api_policy解除设置。（https://developer.android.google.cn/about/versions/10/non-sdk-q?hl=en）","tags":[{"name":"android","slug":"android","permalink":"http://wizzie.top/tags/android/"}]},{"title":"Android Shell脚本应用","date":"2019-10-23T15:52:00.000Z","path":"2019/10/23/2019/191023_android_shell/","text":"基本结构.sh（系统中文.ch.sh）#!/bin/bash 脚本开头#!/bin/csh 是 C shell 的命令解export功能说明：设置或显示环境变量。语 法：export [-fnp][变量名称]=[变量设置值]补充说明：在 shell 中执行程序时，shell 会提供一组环境变量。export 可新增，修改或删除环境变量，供后续执行的程序使用。export 的效力仅限于该次登陆操作。用户登录到Linux系统后，系统将启动一个用户shell。在这个shell中，可以使用shell命令或声明变量，也可以创建并运行 shell 脚本程序。运行shell脚本程序时，系统将创建一个子shell。此时，系统中将有两个shell，一个是登录时系统启动的 shell，另一个是系统为运行脚本程序创建的shell。当一个脚本程序运行完毕，脚本shell将终止，返回到执行该脚本之前的shell。从这种意义上来说，用户可以有许多shell，每个shell都是由某个 shell（称为父 shell）派生的。在子shell中定义的变量只在该子shell内有效。如果在一个shell脚本程序中定义了一个变量，当该脚本程序运行时，这个定义的变量只是该脚本程序内的一个局部变量，其他的 shell 不能引用它，要使某个变量的值可以在其他 shell 中被改变，可以使用 export 命令对已定义的变量进行输出。export命令将使系统在创建每一个新的shell时，定义这个变量的一个拷贝。这个过程称之为变量输出。用语句给变量赋值，如将/etc下目录的文件名循环出来123for file in `ls /etc`或for file in $(ls /et)使用$符号来取一个变量的值，常见的就是$VAR变量定义：app_name=”test”$、$0、$1、$2..$0就是你写的shell脚本本身的名字，$1是你给你写的shell脚本传的第一个参数，$2是你给你写的shell脚本传的第二个参数。ps -ef |grep surfaceFlinger |awk ‘{print $2}’的含义$2：表示第二个字段print $2：打印第二个字段-e: 显示所有进程。-f:全格式awk &#39;{print $2}&#39; $fileName: 一行一行的读取指定的文件， 以空格作为分隔符，打印每行的第二个字段（即 pid）。ps: 打印的信息：字段含义如下：12UID PID PPID C STIME TTY TIME CMDzzw 14124 13991 0 00:38 pts&#x2F;0 00:00:00 grep --color&#x3D;auto dae两种方式声明函数”function”不可以省略(建议)12function find &#123; ...&#125;不得添加参数12find() &#123; ...&#125;两种声明方式效果等价。注意：（1）函数名和”{“之间必须有空格；（2）不得声明形式参数；（3）必须在调用前声明；（4）无法重载；（5）后来的声明会覆盖之前的声明while 语句while循环用于不断执行一系列命令，也用于从输入文件中读取数据；命令通常为测试条件。其格式为：1234while conditiondo commanddone以下是一个基本的while循环，测试条件是：如果int小于等于5，那么条件返回真。int从0开始，每次循环处理时，int加1运行上述脚本，返回数字1到5，然后终止。1234567#!/bin/bashint=1while(( $int&lt;=5 ))do echo $int let \"int++\"done$android_serial=$(adb shell getprop “re.serialno”)获取设备序列号adb shell input swipe 359 1600 359 340 500input后可以跟很多参数，text相当于输入内容，keyevent相当于手机物理或是屏幕按键，tap相当于touch事件，swipe相当于滑动。input/swipe模拟的是滑动事件，input swipe &lt;x1&gt; &lt;y1&gt; &lt;x2&gt; &lt;y2&gt; [duration(ms)] (Default: touchscreen)，需要将起始的坐标传进去。向左滑动：shell@lentk6735_66t_l1:/ $ input swipe 600 800 300 800向右滑动：shell@lentk6735_66t_l1:/ $ input swipe 300 800 600 800滑动：adb shell input swipe 100 100 200 200 300 //从 100 100 经历 300 毫秒滑动到 200 200长按：adb shell input swipe 100 100 100 100 1000 //在 100 100 位置长按 1000 毫秒if [ $(ps -ef | grep -c &quot;ssh&quot;) -gt 1 ]; then echo &quot;true&quot;; fi（适合中断，写成一行）123456789if conditionthen command1 command2 ... commandNelse commandfi-eq:等于-ne:不等于-le:小于等于-ge:大于等于-lt:小于-gt：大于-a: 双方都成立（and） 逻辑表达式 –a 逻辑表达式-o: 单方成立（or） 逻辑表达式 –o 逻辑表达式sed -i ‘s/^.\\{15\\}//g’ tmp.txtadb shell wm size &gt; tmp.txt //分辨率导出文件sed -i ‘s/^.\\{15\\}//g’ tmp.txt //此处 \\{是转义成 `{wm_size=$(cat tmp.txt)sed -i就是直接对文本文件进行操作sed -i &#39;s/原字符串/新字符串/&#39; /home/1.txtsed -i &#39;s/原字符串/新字符串/g&#39; /home/1.txt正则^: 匹配输入字符串的开始位置。如果设置了RegExp对象的Multiline属性，^也匹配\\n或\\r之后的位置。.: 匹配除“\\n”之外的任何单个字符。要匹配包括“\\n”在内的任何字符，请使用像“(.|\\n)”的模式。\\: 将下一个字符标记为一个特殊字符、或一个原义字符、或一个向后引用、或一个八进制转义符。例如，n匹配字符n。\\n匹配一个换行符。串行\\\\匹配\\而\\(则匹配(。{n}:n是一个非负整数。匹配确定的n次。例如，o{2}不能匹配Bob中的o，但是能匹配food中的两个o。sed-n：只打印模式匹配的行-e：直接在命令行模式上进行 sed 动作编辑，此为默认选项-f：将 sed 的动作写在一个文件内，用–f filename 执行 filename 内的 sed 动作-r：支持扩展表达式（配合正则表达式）-i：直接修改文件内容例如：删除该行的第一个字符：sed -r &#39;s/^.//g&#39; &lt;&lt;&lt; $line删除文件每行的第二个字符: sed -r &#39;s/^(.)(.)/\\2/g&#39; passwd删除文件每行的倒数第二个字符: sed -r &#39;s/(.)(.)$/\\2/g&#39; passwd交换每行的第一个字符和第二个字符:sed -r &#39;s/^(.)(.)/\\2\\1/g&#39; passwd交换每行的第一个单词和最后一个单词:sed -r &#39;s/^([a-Z0-9]+)([^a-Z0-9]+)(.+)([^a-Z0-9]+)([a-Z0-9]+)/\\5\\2\\3\\4\\1/g&#39; passwd多选择语句case1234567891011121314echo '你输入的数字为:'read aNumcase $aNum in 1) echo '你选择了 1' ;; 2) echo '你选择了 2' ;; 3) echo '你选择了 3' ;; 4) echo '你选择了 4' ;; *) echo '你没有输入 1 到 4 之间的数字' ;;esacadb shell pidof ”mediaserver“按名称检查正在运行的进程，可以使用pidof命令：adb shell pidof com.android.phone如果找到此类进程，则返回PID,否则返回空字符串。adb shell am start -nadb shell am start -n com.android.camera... //使用组件名方式启动照相机功能可以使用adb shell activity|grep ACTIVITY 或者dump SF获取Activity名称adb shell input tap x y模拟点击事件（点击屏幕），可以用来进入清除任务。adb shell dumpsys window windows |grep Current |tee tmp.txt实现功能：获得当前活动窗口的信息，包名以及活动窗体。过滤Current信息，获得window的dump信息。|tee的作用：输出到控制台date + %Y%m%d_%H%M%S输出日期输入格式：20181128_174323date + %N | cut -c -3%N: 纳秒cut： 从指定的范围中提取字节（-b）、或字符（-c）、或字段（-f）cut -b -3//-3 表示从第一个字节到第三个字节cut -b 3-//3-表示从第三个字节到行尾cut -b -3,3- //输出整行，不会出现连续两个重叠的cat **systrace.html |grep postComp |wc -l（linux 命令）WC：wc - print newline, word, and byte counts for each file参数及含义：-c: print the byte counts 统计字节数-l: print the newline counts：统计行数-m: print the character counts：将每个文件的字符数及文件名输出到屏幕上，如果当前系统不支持多字节字符其将显示与-c 参数相同的结果-w: print the word counts：统计字数（视频播放时）旋转屏幕adb shell settings put system user_rotation 1 //获取参数是getshell判断数组中是否包含某个元素1234567ary=(1 2 3)a=2if [[ \"$&#123;ary[@]&#125;\" =~ \"$a\" ]] ; then echo \"a in ary\"else echo \"a not in ary\"fi解决播放结束后，判断当前activity然后重新播放adb shell dumpsys activity top | grep &quot;ACTIVITY&quot; //获得当前的 activityadb shell am start -n com.home... //返回桌面 activity包含关系123456testPlay=$(adb shell dumpsys activity top | grep \"ACTIVITY\")testPlaySuccess=\"com...Activity\" if [[ $testPlay =~ $testPlaySuccess ]];then echo \"包含\" else echo \"不包含\" fi查找手机文件adb shell find /storage -name &quot;*.mp4&quot; | grep FileName播放视频adb shell am start -a android.intent.action.VIEW -d &quot;file:///storage/...../Test.mp4&quot; -t &quot;video/&quot;逐行读某个文件1234while read linedo…done &lt; file // `&lt;`是读，`&gt;`是写入，`&gt;&gt;`是写入到某个文件的末尾","tags":[{"name":"shell","slug":"shell","permalink":"http://wizzie.top/tags/shell/"}]},{"title":"Android色彩空间（ColorSpace）","date":"2019-10-21T15:52:00.000Z","path":"2019/10/21/2019/191021_android_basis/","text":"色彩空间Color Space广色域WCGWCG（Wide Color Gamut），是Adobe System开发的一种RGB色彩空间，使用纯光谱原色提供较大的色域。与Adove RGB和sRGB相比，能够存储更大范围的颜色值。相比之下，WCG包含CIELAB色彩空间可见颜色的77.6%，而Adobe RGB色彩空间仅覆盖52.1%，sRGB仅覆盖35.9%。WCG色彩空间Note：CIELAB色彩空间（也称为CIE Lab，抑或Lab色彩空间），是国际照明委员会（CIE）于1976年定义的色彩空间。它将色彩表示为三个值：符号释义L*为从黑色（0）到白色（100）的亮度a*为从绿色（-）到红色（+）的亮度b*为从蓝色（-）到黄色（+）的亮度CIELAB被设计为从这些值中相同数量的数字变化对应于大致相同数量的视觉感知变化。sRGB色彩空间sRG色彩空间是惠普和微软于1996年一起开发的用于显示器、打印机、因特网的一种标准RGB色彩空间。最初的目的是作为生成在因特网以及万维网上浏览的图像的通用色彩空间，最后选择的是使用Gamma校准（伽马）系数为2.2的色彩空间，即CRT显示器在这种情况下的平均线性电压响应。sRGB定义了红色、绿色、蓝色三原色的颜色（又称三基色，用于电视机、投影仪等显示设备，对应RGB），即在其他两种颜色值都为零时该颜色的最大值。在CIE xy（Lab色彩空间）坐标系中坐标如下表。对于任何RGB色彩空间来说，非负的R、G、B都不可能表示超出原色定义的三角形即色域范围，它刚好在人眼的色彩感知范围之内。颜色XY红色0.64000.3300绿色0.30000.6000蓝色0.15000.0600白色（D65）0.31270.3290sRGB定义了原色强度与实际保存的数值之间的非线性变化，曲线类似于CRT显示器的伽马响应。这个非线性变化意味着sRGB非常搞笑的使图像文件中的整数值标识了人眼可以分辨的颜色。但是由于它的色域不够大，尤其是蓝绿颜色色域无法表示SMYK印刷中的所有颜色。所以印刷行业的经常使用的是Adobe RGB色彩空间。sRGB色彩空间Note:伽马校正（伽马非线性变化、伽马编码），是用来正对影片或者影像系统里对于管线的辉度或者三色刺激值所进行非线性的运算或反运算。Adobe RGB色彩空间Adobe RGB色彩空间是一种由Adobe System于1998年开发的色彩空间。开发的目的是为了尽可能在CMYK彩色印刷中利用计算机显示器等设备的RGB颜色模式上囊括的更多的颜色。在Adobe RGB标准中，色彩被指定为（R,G,B）三个组员，其中R，G，B每个的值介于0和1之间。但在显示器显示出来时，白色点(1,1,1)，黑色点（0,0,0），原色点（1,0,0）的准确值会被指定。与sRGB相比，Adobe RGB中的RGB色彩分量和亮度并不是呈线性关系，他的伽马值是563/256结果是2.19921875。并且三原色点坐标只有绿色坐标不同。颜色XY红色0.64000.3300绿色0.21000.7100蓝色0.15000.0600白色（D65）0.31270.3290Adobe RGB色彩空间ProPhoto RGB色彩空间ProPhoto RGB色彩空间（抑或ROMM RGB色彩空间），专为摄影输出所开发设计。该色彩空间的色域十分宽裕，甚至包含CIE Lab色彩空间中90%以上的表面色彩和1980年Poniter所记录的可能出现的表面色彩。该色域的表现范围甚至比WCG色彩空间还要大标准参考白点由CIE标准光源D50的色度决定。颜色XY红色0.73470.2653绿色0.15960.8404蓝色0.03660.0001白色（D50）0.34570.3585ProPhoto RGB色彩空间缺点是该色彩空间包含大约13%的通常不存在色彩。DCI-P3色彩空间DCI-P3（抑或DCI/P3）是美国电影行业推出的一种色彩空间。在CIE 1931xy色彩空间中，覆盖了45.5%的全色于和86.9%的常见色域。在CIE 1976uv色度图覆盖率分别是41.7%和85.5%。DCI-P3将来应该会在电视系统和家庭影院领域有更广泛的应用。颜色XY红色0.68000.3200绿色0.26500.6900蓝色0.15000.0600白色（D65）0.31270.3290DCI-P3色彩空间Display P3色彩空间Display P3使用DCI-P3的原色，但是使用D65白点，这在计算机显示色彩空间中（sRGB,AdobeRGB都使用D65）更为常见。和DCI-P3的纯伽马曲线不同。Display-P3使用sRGB曲线。Android中启用/禁止WCG功能APP获取设备是否支持WCGAPP通过以下两种API来决定设备是否支持WCG：android.content.res.Configuration::isScreenWideColorGamut：如果display和设备能够支持WCG则返回true。android.view.Display::isWideColorGamut()：返回显示display设备是否可用于WCG显示。这个并不意味着设备自己可以渲染WCG内容。","tags":[{"name":"android","slug":"android","permalink":"http://wizzie.top/tags/android/"}]},{"title":"C++ 单例模式","date":"2019-10-20T15:39:00.000Z","path":"2019/10/20/2019/191020_cpp_singletonMode/","text":"懒汉式单例模式缺点是延迟加载，比如配置文件，只有在使用的时候才会加载。12345678910111213class CSingleton &#123;public: static CSingleton GetInstance() &#123; if (m_pInstance == NULL) m_pInstance = new CSingleton(); reutrn m_pInstance; &#125;private: CSingleton() &#123;&#125;; static CSingleton * m_pInstace;&#125;多线程下的懒汉模式使用double-check来保证线程安全。但是如果处理大量数据时，该锁才成为严重的性能瓶颈。12345678910111213141516171819202122class Singleton &#123; private: static Singleton* m_instance; Singleton()&#123;&#125; public: static Singleton* getInstance(); &#125;; Singleton* Singleton::getInstance() &#123; if(NULL == m_instance) &#123; Lock(); //借用其它类来实现，如boost if(NULL == m_instance) &#123; m_instance = new Singleton; &#125; UnLock(); &#125; return m_instance; &#125;饿汉式单例模式一开始就创建实例对象并且加载，每次使用的时候直接返回就好了。饿汉式会出现线程安全问题，在多线程下，或个线程都初始化一个单例，得到的指针并不是指向同一个地方，就不满足单例类的定义，此时就需要进行修改。12345678910class CSingletonB &#123;private: CSingletonB () &#123;&#125;public: static CSingletonB * GetInstance() &#123; static CSingleton instance; return &amp;instance; &#125;&#125;","tags":[{"name":"cpp","slug":"cpp","permalink":"http://wizzie.top/tags/cpp/"}]},{"title":"Java 单例模式","date":"2019-10-20T14:59:00.000Z","path":"2019/10/20/2019/191020_java_singletonMode/","text":"单例：保证一个类仅有一个实例，并提供一个访问它的全局访问点。单例模式是一种常用的软件设计模式之一，其目的是保证整个应用中只存在类的唯一个实例。比如我们在系统启动时，需要加载一些公共的配置信息，对整个应用程序的整个生命周期中都可见且唯一，这时需要设计成单例模式。如：spring容器，session工厂，缓存，数据库连接池等等。保证实例的唯一:防止外部初始化由类本身进行实例化保证实例化一次对外提供获取实例的方法线程安全饿汉式单例模式线程安全，调用效率高，但是不能延时加载直接创建单例对象，使用的时候直接返回即可。缺点是单例在未使用的时候就已经初始化完成，如果程序一直没有使用，单例对象还是会创建，从而造成不必要的资源浪费。123456789public class TestA &#123; private static TestA t1 = new TestA; private TestA() &#123;&#125; public static TestA getInfo() &#123; return t1; &#125;&#125;懒汉式单例模式线程安全，调用效率不高，但是可以延时加载123456789101112131415public class TestB &#123; //类初始化时，不初始化对象（延时加载，真正使用的时候再创建） private static TestB t2; //构造器私有化 private TestB() &#123;&#125; //方法同步，调用效率低 public static synchronized TestB getInfo() &#123; if (testB == null) &#123; TestB = new TestB(); &#125; return testB; &#125;&#125;双重锁判断机制（DCL）即Double CheckLock实现单例模式（由于JVM底层模型原因，偶尔会出现问题，不建议使用）1234567891011121314151617public class TestC &#123; private static TestC t3; private TestC() &#123;&#125; public static TestC getInfo() &#123; if (TestC == null) &#123; synchronized (TestC.class) &#123; if (TestC == null) &#123; TestC = new TestC(); &#125; &#125; &#125; return t3; &#125;&#125;静态内部类实现单例模式线程安全，调用效率高，可以延迟加载12345678910111213public class TestD &#123; private static class GetInfoClass &#123; private static final TestD t4 = new TestD(); &#125; //构造函数 private TestD() &#123;&#125; public static TestA getInfo() &#123; return GetInfoClass.t4; &#125;&#125;枚举类实现单例模式线程安全，调用效率高，不能延时加载，可以天然防止反射和反序列化调用）123456789public class TestE &#123; //枚举元素本身就是单例 INSTANCE; //添加自己需要的操作 public void getInfoOperation() &#123; &#125;&#125;","tags":[{"name":"java","slug":"java","permalink":"http://wizzie.top/tags/java/"}]},{"title":"Android Property","date":"2019-10-16T15:52:00.000Z","path":"2019/10/16/2019/191016_adndroid_property_setTypes/","text":"property的相关生成文件和设置android通过SystemProperties的set和get方法来控制很多东西，一般上层添加一个控制开关可以使用这个方法，在系统里面存在很多个prop文件。它们分别是system/build.prop,system/etc/prop.default,vendor/build.prop,vendor/default.prop。下面分别来说下这几个文件的构成。system/build.prop这个主要是由device\\mediateksample\\product/system.prop,还有在build目录下添加的ADDITIONAL_BUILD_PROPERTIESsystem/etc/prop.default主要是系统添加的PRODUCT_SYSTEM_DEFAULT_PROPERTIESvendor/build.prop（比较重要）主要是系统添加的PRODUCT_PROPERTY_OVERRIDES，添加在device.mk的这个属性会被编译到这里，但是在9.0的系统，加到这里会无效，获取不到值。vendor/default.prop（会被同目录的build.prop相同property覆盖）主要是系统添加的PRODUCT_DEFAULT_PROPERTY_OVERRIDES","tags":[{"name":"android","slug":"android","permalink":"http://wizzie.top/tags/android/"}]},{"title":"Android Graphics 调试技巧（十月份更新）","date":"2019-10-12T15:52:00.000Z","path":"2019/10/12/2019/191012_android_debug1/","text":"readelf命令查看ELF格式的文件信息常见的文件比如动态库(*.so)、静态库（*.a），常用命令：readelf -a libgui.so | grep test_string查看手机内存123456789adb shellcat proc/meminfoMemTotal: 7821184 kBMemFree: 157484 kBMemAvailable: 2765976 kBBuffers: 175624 kBCached: 2264796 kB......adb logcat缓存管理12345678adb root;adb remount清除缓存 adb logcat -c如果不能清除，就指定区域清除 adb logcat -c main&#x2F;system&#x2F;event&#x2F;kernel&#x2F;all(日志缓冲区)查看缓存 adb logcat -g设置最大logcat缓存 adb logcat -G 100Mlinux离线翻译工具sdcv1234567安装：sudo apt-get install sdcv使用：sdcv只能翻译单词apt-get命令列出版本号sudo apt-cache madison openssh-clientLinux安装tar.xz软件包1234在linux下(node.js)：解压后将bin目录的命令全局，建立软链接：sudo ln -s &#x2F;node-v10.16.0-linux-x64&#x2F;bin&#x2F;node &#x2F;usr&#x2F;local&#x2F;bin&#x2F;nodesudo ln -s &#x2F;node-v10.16.0-linux-x64&#x2F;bin&#x2F;npm &#x2F;usr&#x2F;local&#x2F;bin&#x2F;npmJNI的jlong类型打印不使用%lld和%ld，而是先将其转换成long，然后%ld打印。1ALOGD(\"Mylog: JNI destroySurface nativeObject=%ld\", (long)nativeObject);monkey测试指令参数12345678910111213adb shell monkey help查看帮助-p 指定包名-v log详细程度（最高支持-v -v -v）-s 种子（指定后，同一个命令在任意时间地点的执行顺序相同）--throttle 单步延时（每步操作间隔，单位ms），如果不知定系统会尽快的发送事件序列--kill-process-offer-error 出错是杀掉进程--ignore-timeouts 忽略超时错误(程序未响应)，不会应ANR而停止--ignore-security-exceptions 忽略证书或认证异常 --hprof 测试前后会生成app内存快照文件（一般在&#x2F;data&#x2F;misc目录下生成hprof文件，可以使用Android Studio查看）--ignore-crashes 忽略crash，不会因crash而停止--ignore-native-crashes 忽略native代码发生的crash崩溃，不会因此停止--monitor-native-crashes 监视native代码发生的崩溃示例(1) adb shell monkey -p PackageName -v -v -v -s 12 –throttle 500 1000 &gt; monkey.txt随机数种子是12，log详细程度最高，单步延时500ms，总执行1000步，日志输出到monkey.txt(2) adb shell monkey -p PackageName –throttle 200 –ignore-security-exceptions -v 100000000(3) adb shell monkey -p PackageName –throttle 200 –ignore-crashes –ignore-timeouts –ignore-security-exceptions –ignore-native-crashes –monitor-native-crashes -v -v -v 1000000 &gt; monkeylog.txt(4) 不指定包：adb -s DeviceID shell monkey –throttle 200 –ignore-crashes –ignore-timeouts –ignore-security-exceptions –ignore-native-crashes –monitor-native-crashes –ignore-security-exceptions -v -v -v 100 &gt; monkeylog.txt(5) 正常测试验证问题使用（不忽略crash,压力测试，所以不指定间隔时间）：adb -s DeviceID shell monkey -p PackageName –throttle 200 –ignore-security-exceptions -v 100000000 &gt; monkeyLog.txt停止monkey测试12(1) ps -A|grep monkey(2) kill pid（11111）重现monkey测出的bugmonkey日志搜索ANR exception，将之前的事件重新操作。尤其是seed值要一样，如monkey -p PackageName -v seed(-s) 100(seed的值) 500(随机时间次数)dump meminfo123adb shell dumpsys meminfo或者具体包adb shell dumpsys meminfo packageNamekernel使用printk调试打印调试logprintk(&quot;%d&quot;,intA);打印变量所占内存大小printk(&quot;sizeof(*intA)=%d&quot;,sizeof(*intA);查看设别是否支持Project TeableProject Treble是在最新的Android上应用兼容的芯片驱动，加快最新系统适配的速度。adb shell getprop ro.treble.enabled查看cpu架构adb shell getprop ro.product.cpu.abiService服务命令12服务列表： adb shell service list检测某服务是否存在： adb shell service check SurfaceFlinger测试CtsMediaTestCases需要CTS媒体文件（连接外网）Google官网下载，例如CTS媒体文件1.4，解压后阅读README文件，按照提示copy文件到device。123456chmod 544 copy_media.sh.&#x2F;copy_media.shchmod 544 copy_images.sh.&#x2F;copy_images.sh例如：run cts-dev --module CtsMediaTestCases --compatibility:module-arg CtsMediaTestCases:include-annotation:android.platform.test.annotations.RequiresDevice当前活动Activiy获取当前ACTIVITYadb shell dumpsys activity top|grep ACTIVITY命令启动指定Activityadb shell am start -n ActivityNameAndroid SDK抓取systrace12进入Android&#x2F;Sdk&#x2F;platform-tools&#x2F;systrace目录下python systrace.py -b 8000 -t 5 -o systrace.html打开模拟Vsync，从Systrace查看到源码： Android 10的AOSP方法： 修改surfaceflinger/Scheduler/DispSync.cpp的static const bool kEnableZeroPhaseTracer = false;为Trueadb devices很少识别1234567方法一：lsusb 查看usb是否识别到手机如果没有，检查“开发者选项 -&gt; USB调试”是否打开方法二： 重启ADB服务adb kill-serveradb start-server添加usb设备自动识别信息/etc/udev/rules.d/1234567（1）lsusb查看usb链接设备（2）然后编辑&#x2F;新增文件(&#x2F;etc&#x2F;udev&#x2F;rules.d&#x2F;)：sudo vi 51-android.rules 文件内容：SUBSYSTEM&#x3D;&#x3D;&quot;usb&quot;,ATTRS&#123;idVendor&#125;&#x3D;&#x3D;&quot;093a&quot;,ATTRS&#123;idProduct&#125;&#x3D;&#x3D;&quot;120d&quot;,MODE&#x3D;&quot;0666&quot;（3）保存后重启udev服务sudo &#x2F;etc&#x2F;init.d&#x2F;udev restart或者sudo service udev restart（4）重新连接设备测试adb shell获取设备信息参数（序列号）1234567getprop 查看机器的全部信息参数getprop ro.serialno 查看机器的序列号getprop ro.carrier 查看机器的CID号getprop ro.hardware 查看机器板子代号getprop ro.bootloader 查看SPL(Hboot)版本号getprop ro.build.version.release 查看系统版本（8、9...）getprop ro.build.display.id 获得厂商系统版本Android中CPU频率查看和修改1234567root权限（直接输入su命令）cd sys&#x2F;devices&#x2F;system&#x2F;cpu&#x2F;cpu0&#x2F;cpufreqls文件如下cpuinfo_cur_freq： 当前cpu正在运行的工作频率cpuinfo_max_freq：该文件指定了处理器能够运行的最高工作频率 （单位: 千赫兹）cpuinfo_min_freq ：该文件指定了处理器能够运行的最低工作频率 （单位: 千赫兹）Ubuntu下载更新杀毒软件123456789下载：sudo apt-get updatesudo apt-get install clamavsudo chmod 777 freshclam.lgfreshclamg更新扫描：clamav -a &#x2F;安装deb包sudo dpkg -i gapid-1.3.1-linux.deb查看手机服务开发者选项 -&gt; Running services可以查看正在运行的服务，以及运行内存情况查看修改屏幕分辨率和密度123456789101112查看：adb shellwm size 获得手机当前分辨率wm density 获得手机当前屏幕密度（例如560dpi）修改：wm size 1096*2560wm density 420恢复：wm size resetwm density reset查看进程map虚拟地址12345adb root;adb remountadb shell ps -A|grep camera 查看服务的进程号(例如4712) cd proc&#x2F;4712 进入进程号的文件夹 more maps 查看虚拟内存地址SELinux模式开启关闭SELinux(Security-Enabled Linux)是美国国家安全局（NSA）对于强制访问控制的实现（安全子系统）临时生效方法：adb shell setenforce 0（临时生效，关闭SELinux模式）adb shell setenforce 1（启用，开启SELinux模式）adb命令 – 录制手机视频adb shell screenrecord sdcard/record.mp41adb pull sdcard/record.mp4 .adb命令 – 截图adb shell screencap -p sdcard/1.pngadb命令 – 输入文本节省手动输入的时间：adb shell input text ****adb命令 – 获取APP路径adb shell dumpsys SurfaceFlinger 最下方查看正在运行的APKadb shell pm path &quot;com.**&quot; 获取路径台式机通过WIFI建立adb连接，实现无线连接手机通常在需要手机连接外设显示设备的同时需要抓取Log、Dump等操作：两台手机连上同一个无线网其中一台A关闭开发者选项的USB调试，并且连接到电脑作为热点（无线网卡）另一台B连接电脑输入adb tcpip 5555，然后输入adb shell ifconfig wlan0查看B的IP地址连接B手机的IP： adb connect IP断开B，保持A连接在电脑连接DP继续dump SurfaceFlinger的方法连接DP前启动：adb shell dumpsys SurfaceFlinger --file --no-limit断开DP后再次执行结束Dump：adb shell dumpsys SurfaceFlinger --file --no-limit接过文件pull出来：adb pull /data/misc/wmtrace/dumpsys.txtmd5sum命令检测文件通过md5sum filename查看文件的md5sum值是否一样GSI含义GSI是替换成google的frameworks等(即system.img, 即google的原生AOSP)system.img包含整个系统，framework、application等，被挂接到”/“目录下，包含系统的所有二进制文件。大概是编译出来的out/target/product/ProductName/system目录的映射GSI方法123456常用步骤：adb reboot bootloader (fastboot devices检测设备)fastboot erase systemfastboot -wfastboot flash system GSI(.img file)fastboot rebootCTS VTS跑测注意点重跑：run retry --retry 序列号跑测arm64-v8a还是armeabi-v7a等:run cts-suite -s ... -a arm64-v8 -m ...linxu命令查找命令查找字符串grep -rn 字符串grep 字符串 -Rin * //查找该目录下包含该字符串的文件查找文件find . -iname Test*Git命令回退到某个commitID： git reset --hard commitID新建一个Commit用于Revert某个分支： git revert commitID修改commit信息git commit --amend --author=&quot;**&quot; --date=&quot;**&quot; 修改作者和日期添加topic的方法(提交到Gerrit)git push origin HEAD:refs/for/BRANCH_Name%topic=&quot;name&quot;使用新的change ID覆盖原来已经提交的Patchgit push origin HEAD:refs/changes/99999 (gerrit上的已有Commit的Patch ID)git stash暂时储藏用于修改的代码暂时保存起来，并且不影响下次的修改(这个比生成本地补丁方便git format-patch -1 commitID)：git stash save &quot;Remarks&quot; 执行存储，并且添加备注git stash list 查看储藏列表git stash show stash@{1} 查看某次储藏的修改git stash apply stash@{$Num} 应用某次储藏git stash pop stash@{$Num} 从缓存堆栈中删除某次储藏并且应用到代码中，默认第一个stashgit stash drop stash@{$Num} 从列表删除这个存储git stash clear 删除所有缓存的stashRepo下载项目方法下载.repo：repo init -u Git远程仓库 -b Branch_Name(分支选择)Sync项目：repo sync -c -j4（当前分支）如果值Sync指定目录，则在指定目录下执行：repo sync -c . -j4Android常用编译方式source build/envsetup.shlunch //选择指定Productmake fullbuild -j4如果只编译部分模块：framework模块：make framework -j4，结果生成framework.jar包到/system/framework编译kernal/msm使用： make bootimage -j4指定目录下执行:mm/mmm/mma(依赖编译)","tags":[{"name":"graphics","slug":"graphics","permalink":"http://wizzie.top/tags/graphics/"}]},{"title":"nReal搭建Samepl APK","date":"2019-09-30T13:52:00.000Z","path":"2019/09/30/2019/190930_nReal_Sample/","text":"概述nrsdk是nreal开发混合现实体验的平台。使用简单的开发过程和高级api，nrsdk提供了一组强大的mr特性，并使nreal眼镜能够了解真实世界。nrsdk为开发者提供了五个核心特性：空间计算使眼镜能够跟踪它们相对于世界的实时位置，并了解周围的环境，例如检测和跟踪平面和图像。优化的渲染自动应用于应用程序并在后端运行，以最小化延迟并减少抖动，增强总体用户体验。多模态交互为不同的用例提供了交互的直观选择。提供了开发工具，以便您可以更好地开发和调试应用程序。第三方集成是通过为第三方sdk提供数据来实现的，这允许您充分利用nreal light的硬件功能并构建功能强大的mr/ar应用程序。开发工具包开发混合现实应用程序需要一个nreal开发工具包。开发工具包由一对nreal光学眼镜、nreal计算单元和nreal光学控制器组成。如果没有，请在这里注册nreal开发工具包！到目前为止，你还不能直接在android手机上开发应用程序。安卓手机开发将于2020年初推出。选择开发平台nrsdk支持许多最流行的开发环境。通过这些功能，您可以构建全新的mr体验，或者使用mr功能增强现有的原生android应用程序。Unity （Support Unity 2018.2.X） Android Native (to be released) Unreal (to be released)与Android本机应用程序兼容nreal眼镜现在与android原生应用程序兼容，这意味着只要应用程序安装在设备上，用户就可以通过眼镜查看所有应用程序活动。在你这边什么都不需要改变。要使2d应用程序更具沉浸感和三维感，可以使用nrsdk在现有应用程序中添加mr功能或3d虚拟对象。功能空间计算nreal眼镜使用各种传感器和相机，以建立对周围环境和用户本身的复杂理解，创造身临其境的体验，无缝融合数字世界和现实世界。HelloMR APP硬件清单一个nreal计算单元（把它想象成一个没有屏幕的android手机，所以所有的开发过程都将非常类似于移动应用程序开发）。一副自然光眼镜没有nreal设备？注册nreal开发工具包！或者尝试仿真器在没有nreal眼镜和计算单元的情况下引导nreal应用程序功能。连接nReal计算单元和PC的USB-C电缆不需要Wi-Fi连接。但是，可以使用Wi-Fi Android调试桥（ADB）连接进行调试和测试。软件清单Unity 2018.2.x或更高版本，支持Android构建下载Unity 1.1的nrsdk(sdk作为nrsdkforunity_1.1.unitypackage下载)android sdk 7.0（api级别24）或更高版本，使用android studio中的sdk管理器安装创建统一项目打开Unity并创建一个新的3D项目。set player settings&gt;other settings&gt;scriptping runtime version to.net 4.x等效版本为unity导入nrsdk选择“资源&gt;导入包&gt;自定义包”。选择您下载的nrsdkforunity_1.1.unitypackage。在“导入包”对话框中，确保选中了所有包选项，然后单击“导入”。在unity项目窗口中，通过选择assets&gt;nrsk&gt;demos&gt;hellomr找到hellomr示例应用程序。配置生成设置转到“文件&gt;生成设置”。选择android并单击switch platform。在“生成设置”窗口中，单击“播放器设置”。在Inspector窗口中，按如下方式配置播放机设置：(https://developer.nreal.ai/develop/unity/android-quickstart)连接到nReal设备(开发工具包)在计算单元上启用开发人员选项和USB调试。android调试桥（adb）作为默认设置启用，不需要手动设置）。将计算单元连接到Windows PC。建立并运行在Unity Build设置窗口中，单击Build。在构建成功后，通过wifi android调试桥（adb）安装应用程序。断开电脑与电脑的连接，然后将其连接到眼镜上。如果这是您第一次运行此应用程序，则需要使用某些工具（如scrcpy）对该应用程序进行身份验证。与nReal Light控制器一起启动应用程序。有关如何使用nReal Light控制器的说明，请参阅控制器指南。四处移动，直到nrsdk找到一个水平面，检测到的平面将被绿色网格覆盖。单击触发器按钮在其上放置nReal徽标对象。（可选）使用android logcat查看记录的消息。我们建议使用WiFi Android调试桥（ADB）连接到您的PC，这样您就不必在大多数时间通过数据线连接。Sample APP(立体方块)scene设置在SampleScene删除主摄像头；将Assets -&gt; NRSDK -&gt; Prefabs -&gt; NRCameraRig拖拽到SampleScene中；将Assets -&gt; NRSDK -&gt; Prefabs -&gt; NRInput拖拽到SampleScene中；将Assets -&gt; NRSDK -&gt; Emulator -&gt; Prefabs -&gt; NRTrackableImageTarget拖拽到SampleScene;在其中可以修改场景图像（Image Target）在SampleAPP右侧窗口中右击Create -&gt; 3D -&gt; Object -&gt; Cube，创建立方体将Scale均修改成0.25右击Create Empty,在Inspector中Add Component(1)Script设置为TrackableFoundTest(2)Observer设置为NRTrackableImageTarget(3)Obj设置为Cube打开Assets -&gt; NRSDK -&gt; Emulator -&gt; Scripts -&gt; TrackableFoundTest,编辑源文件C#，添加Update函数，增加每次点击切换立方体颜色1234567using NRKernal;... private void Update() &#123; if (NRInput.GetButtonDown(ControllerButton.TRIGGER)) Obj.GetComponent&lt;Renderer&gt;().material.color &#x3D; new Color(Random.value, Random.value, Random.value); &#125;File -&gt; BuildSettings添加SampleAPP，然后选择Android，最后Building生成APK，安装full screen black或者在Unity上方点击Play按钮使用Emulator查看，常用按键操作：1234567WASD控制前后左右；Space+鼠标表示头部旋转；SHIFT+鼠标移动模拟nReal控制器的旋转（3DOF控制器）；单击鼠标左键模拟控制器触发器的单击（此处会触发Update函数变化颜色）；单击鼠标右键以模拟控制器主页按钮的压力；单击鼠标滚轮按钮以模拟控制器的APP按钮的压力；使用箭头键模拟在控制器的触摸板上滑动；","tags":[{"name":"nReal","slug":"nReal","permalink":"http://wizzie.top/tags/nReal/"}]},{"title":"Android Handler消息循环处理机制(例ActivityThread)","date":"2019-09-22T07:01:32.000Z","path":"2019/09/22/2019/190922-android-handler-cpp/","text":"整体流程关键词：Handler、Looper、MessageQueue、handleMessage消息被存放于消息队列，应用程序的主线程会围绕这个消息队列进入一个无限循环，知道应用程序退出。（消息循环过程是由Looper实现的）如果队列中有消息，应用程序的主线程会把它取出来，分发给相应的Handler进行处理；如果队列中没有消息，应用程序的主县城就会进入空闲等待状态，等待下一个消息的到来；消息循环（以ActivityThread为例）应用程序的消息循环是从 ActivityThread 的 main()函数入口的，在 main()函数中会调用Looper.prepareMainLooper();和Looper.loop();代码： http://aosp.opersys.com/xref/android-10.0.0_r2/xref/frameworks/base/core/java/android/app/ActivityThread.java#7310frameworks/base/core/java/android/app/ActivityThread.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public static void main(String[] args) &#123; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"ActivityThreadMain\"); // Install selective syscall interception AndroidOs.install(); // CloseGuard defaults to true and can be quite spammy. We // disable it here, but selectively enable it later (via // StrictMode) on debug builds, but using DropBox, not logs. CloseGuard.setEnabled(false); Environment.initForCurrentUser(); // Make sure TrustedCertificateStore looks in the right place for CA certificates final File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId()); TrustedCertificateStore.setDefaultUserDirectory(configDir); Process.setArgV0(\"&lt;pre-initialized&gt;\"); Looper.prepareMainLooper(); // Find the value for &#123;@link #PROC_START_SEQ_IDENT&#125; if provided on the command line. // It will be in the format \"seq=114\" long startSeq = 0; if (args != null) &#123; for (int i = args.length - 1; i &gt;= 0; --i) &#123; if (args[i] != null &amp;&amp; args[i].startsWith(PROC_START_SEQ_IDENT)) &#123; startSeq = Long.parseLong( args[i].substring(PROC_START_SEQ_IDENT.length())); &#125; &#125; &#125; ActivityThread thread = new ActivityThread(); thread.attach(false, startSeq); if (sMainThreadHandler == null) &#123; sMainThreadHandler = thread.getHandler(); &#125; if (false) &#123; Looper.myLooper().setMessageLogging(new LogPrinter(Log.DEBUG, \"ActivityThread\")); &#125; // End of event ActivityThreadMain. Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); Looper.loop(); //消息循环 throw new RuntimeException(\"Main thread loop unexpectedly exited\"); &#125;创建Looper对象的时候，会同时创建一个 MessageQueue，保存在 Looper 的成员变量 mQueue 中。Looper和MessageQueue就是这样关联起来的。JNI层创建 Looper 时会通过 pipe 系统调用来创建一个管道。frameworks/base/core/java/android/os/Looper.java1234private Looper(boolean quitAllowed) &#123; mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread();&#125;该Looper对象创建好之后会保存在 NativeMessageQueue 对象的成员变量 mLooper 中，这个对象的作用是，通过管道实现以下功能：当Java层的消息队列中没有消息时，就使 Android 应用程序主线程进入等待状态，而当Java层的消息队列中来了消息时，就唤醒Android应用程序的主线程来处理这个消息。ActivityThread调用Looper.loop()才会进入消息循环。进入消息循环后，会不断地从消息队列mQueue中去获取下一个要处理的消息msg，如果消息的target为null，就表示要退出消息循环了，否则就会调用target对象的 dispatchMessage 函数来处理这个消息。调用 queue 的 next 函数去获取下一个要处理的消息，但调用这个函数有可能会让线程进入等待状态。一是当消息队列中没有消息时，它会使线程进入等待状态；二是消息队列中有消息，但是消息指定了执行的时间，而现在还没有到这个时间，线程也会进入等待状态。/frameworks/base/core/java/android/os/Looper.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115public static void loop() &#123; final Looper me = myLooper(); if (me == null) &#123; throw new RuntimeException(\"No Looper; Looper.prepare() wasn't called on this thread.\"); &#125; final MessageQueue queue = me.mQueue; // Make sure the identity of this thread is that of the local process, // and keep track of what that identity token actually is. Binder.clearCallingIdentity(); final long ident = Binder.clearCallingIdentity(); // Allow overriding a threshold with a system prop. e.g. // adb shell 'setprop log.looper.1000.main.slow 1 &amp;&amp; stop &amp;&amp; start' final int thresholdOverride = SystemProperties.getInt(\"log.looper.\" + Process.myUid() + \".\" + Thread.currentThread().getName() + \".slow\", 0); boolean slowDeliveryDetected = false; for (;;) &#123; Message msg = queue.next(); // might block if (msg == null) &#123; // No message indicates that the message queue is quitting. return; &#125; // This must be in a local variable, in case a UI event sets the logger final Printer logging = me.mLogging; if (logging != null) &#123; logging.println(\"&gt;&gt;&gt;&gt;&gt; Dispatching to \" + msg.target + \" \" + msg.callback + \": \" + msg.what); &#125; // Make sure the observer won't change while processing a transaction. final Observer observer = sObserver; final long traceTag = me.mTraceTag; long slowDispatchThresholdMs = me.mSlowDispatchThresholdMs; long slowDeliveryThresholdMs = me.mSlowDeliveryThresholdMs; if (thresholdOverride &gt; 0) &#123; slowDispatchThresholdMs = thresholdOverride; slowDeliveryThresholdMs = thresholdOverride; &#125; final boolean logSlowDelivery = (slowDeliveryThresholdMs &gt; 0) &amp;&amp; (msg.when &gt; 0); final boolean logSlowDispatch = (slowDispatchThresholdMs &gt; 0); final boolean needStartTime = logSlowDelivery || logSlowDispatch; final boolean needEndTime = logSlowDispatch; if (traceTag != 0 &amp;&amp; Trace.isTagEnabled(traceTag)) &#123; Trace.traceBegin(traceTag, msg.target.getTraceName(msg)); &#125; final long dispatchStart = needStartTime ? SystemClock.uptimeMillis() : 0; final long dispatchEnd; Object token = null; if (observer != null) &#123; token = observer.messageDispatchStarting(); &#125; long origWorkSource = ThreadLocalWorkSource.setUid(msg.workSourceUid); try &#123; msg.target.dispatchMessage(msg); if (observer != null) &#123; observer.messageDispatched(token, msg); &#125; dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : 0; &#125; catch (Exception exception) &#123; if (observer != null) &#123; observer.dispatchingThrewException(token, msg, exception); &#125; throw exception; &#125; finally &#123; ThreadLocalWorkSource.restore(origWorkSource); if (traceTag != 0) &#123; Trace.traceEnd(traceTag); &#125; &#125; if (logSlowDelivery) &#123; if (slowDeliveryDetected) &#123; if ((dispatchStart - msg.when) &lt;= 10) &#123; Slog.w(TAG, \"Drained\"); slowDeliveryDetected = false; &#125; &#125; else &#123; if (showSlowLog(slowDeliveryThresholdMs, msg.when, dispatchStart, \"delivery\", msg)) &#123; // Once we write a slow delivery log, suppress until the queue drains. slowDeliveryDetected = true; &#125; &#125; &#125; if (logSlowDispatch) &#123; showSlowLog(slowDispatchThresholdMs, dispatchStart, dispatchEnd, \"dispatch\", msg); &#125; if (logging != null) &#123; logging.println(\"&lt;&lt;&lt;&lt;&lt; Finished to \" + msg.target + \" \" + msg.callback); &#125; // Make sure that during the course of dispatching the // identity of the thread wasn't corrupted. final long newIdent = Binder.clearCallingIdentity(); if (ident != newIdent) &#123; Log.wtf(TAG, \"Thread identity changed from 0x\" + Long.toHexString(ident) + \" to 0x\" + Long.toHexString(newIdent) + \" while dispatching to \" + msg.target.getClass().getName() + \" \" + msg.callback + \" what=\" + msg.what); &#125; msg.recycleUnchecked(); &#125; &#125;调用 queue 的 next 函数去获取下一个要处理的消息，但调用这个函数有可能会让线程进入等待状态。一是当消息队列中没有消息时，它会使线程进入等待状态；二是消息队列中有消息，但是消息指定了执行的时间，而现在还没有到这个时间，线程也会进入等待状态。消息处理流程消息发送从应用程序启动入口分析下消息发送流程。应用程序启动过程中会调用 sendMessage 函数向应用程序的消息队列中加入一个新的消息。sendMessage将参数封装成Message，然后通过mH.sendMessage把该消息加入消息队列。mH是ActivityThread类的成员变量，它的类型为H，继承于Handler类。定义： final H mH = new H();/frameworks/base/core/java/android/app/ActivityThread.java123456789101112131415private void sendMessage(int what, Object obj, int arg1, int arg2, boolean async) &#123; if (DEBUG_MESSAGES) &#123; Slog.v(TAG, \"SCHEDULE \" + what + \" \" + mH.codeToString(what) + \": \" + arg1 + \" / \" + obj); &#125; Message msg = Message.obtain(); msg.what = what; msg.obj = obj; msg.arg1 = arg1; msg.arg2 = arg2; if (async) &#123; msg.setAsynchronous(true); &#125; mH.sendMessage(msg);&#125;sendMessage函数是继承于Handler的，Handler在它的构造函数中获取了Looper对象和MessageQueue 对象。frameworks/base/core/java/android/os/Handler.java123456789101112131415161718192021public final boolean sendMessage(@NonNull Message msg) &#123; return sendMessageDelayed(msg, 0);&#125;public final boolean sendMessageDelayed(@NonNull Message msg, long delayMillis) &#123; if (delayMillis &lt; 0) &#123; delayMillis = 0; &#125; return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);&#125;public boolean sendMessageAtTime(@NonNull Message msg, long uptimeMillis) &#123; MessageQueue queue = mQueue; if (queue == null) &#123; RuntimeException e = new RuntimeException( this + \" sendMessageAtTime() called with no mQueue\"); Log.w(\"Looper\", e.getMessage(), e); return false; &#125; return enqueueMessage(queue, msg, uptimeMillis);&#125;msg.target = this;表示这个消息最终由这个Handler对象来处理，即由ActivityThread对象的mH成员变量来处理。最终会调到MessageQueue的enqueueMessage函数最后会调到Looper.cpp的wake函数。/frameworks/base/core/java/android/os/Handler.java12345678910private boolean enqueueMessage(@NonNull MessageQueue queue, @NonNull Message msg, long uptimeMillis) &#123; msg.target = this; msg.workSourceUid = ThreadLocalWorkSource.getUid(); if (mAsynchronous) &#123; msg.setAsynchronous(true); &#125; return queue.enqueueMessage(msg, uptimeMillis);&#125;frameworks/base/core/java/android/os/MessageQueue.java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253boolean enqueueMessage(Message msg, long when) &#123; if (msg.target == null) &#123; throw new IllegalArgumentException(\"Message must have a target.\"); &#125; if (msg.isInUse()) &#123; throw new IllegalStateException(msg + \" This message is already in use.\"); &#125; synchronized (this) &#123; if (mQuitting) &#123; IllegalStateException e = new IllegalStateException( msg.target + \" sending message to a Handler on a dead thread\"); Log.w(TAG, e.getMessage(), e); msg.recycle(); return false; &#125; msg.markInUse(); msg.when = when; Message p = mMessages; boolean needWake; if (p == null || when == 0 || when &lt; p.when) &#123; // New head, wake up the event queue if blocked. msg.next = p; mMessages = msg; needWake = mBlocked; &#125; else &#123; // Inserted within the middle of the queue. Usually we don't have to wake // up the event queue unless there is a barrier at the head of the queue // and the message is the earliest asynchronous message in the queue. needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; for (;;) &#123; prev = p; p = p.next; if (p == null || when &lt; p.when) &#123; break; &#125; if (needWake &amp;&amp; p.isAsynchronous()) &#123; needWake = false; &#125; &#125; msg.next = p; // invariant: p == prev.next prev.next = msg; &#125; // We can assume mPtr != 0 because mQuitting is false. if (needWake) &#123; nativeWake(mPtr); //此处调用JNI函数 &#125; &#125; return true; &#125;/frameworks/base/core/jni/android_os_MessageQueue.cpp1234static void android_os_MessageQueue_nativeWake(JNIEnv* env, jclass clazz, jlong ptr) &#123; NativeMessageQueue* nativeMessageQueue = reinterpret_cast&lt;NativeMessageQueue*&gt;(ptr); nativeMessageQueue-&gt;wake();&#125;消息处理ActivityThread的main函数在Looper.loop函数中调用msg.target.dispatchMessage(msg)去处理消息。frameworks/base/core/java/android/os/Looper.java1234567891011121314151617try &#123; msg.target.dispatchMessage(msg); //处理消息 if (observer != null) &#123; observer.messageDispatched(token, msg); &#125; dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : 0; &#125; catch (Exception exception) &#123; if (observer != null) &#123; observer.dispatchingThrewException(token, msg, exception); &#125; throw exception; &#125; finally &#123; ThreadLocalWorkSource.restore(origWorkSource); if (traceTag != 0) &#123; Trace.traceEnd(traceTag); &#125; &#125;消息对象msg的成员变量target是在发送消息的时候设置好的，通过哪个Handler来发送消息，就通过哪个Handler来处理消息。当时是 H 类把消息加入消息队列的，现在也该由 H 类处理消息。 H类没有实现自己的dispatchMessage函数，但它继承了父类Handler的dispatchMessage函数。frameworks/base/core/java/android/os/Handler.java123456789101112public void dispatchMessage(@NonNull Message msg) &#123; if (msg.callback != null) &#123; handleCallback(msg); &#125; else &#123; if (mCallback != null) &#123; if (mCallback.handleMessage(msg)) &#123; return; &#125; &#125; handleMessage(msg); &#125;&#125;最终调用handleMessage处理消息。此处既是调用ActivityThread.java的该函数。/frameworks/base/core/java/android/app/ActivityThread.java12345678910public void handleMessage(Message msg) &#123; if (DEBUG_MESSAGES) Slog.v(TAG, \"&gt;&gt;&gt; handling: \" + codeToString(msg.what)); switch (msg.what) &#123; case BIND_APPLICATION: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"bindApplication\"); AppBindData data = (AppBindData)msg.obj; handleBindApplication(data); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; .......SurfaceFlinger的消息处理机制类似的消息处理机制在SurfaceFlinger也存在，拥有独自的文件frameworks/native/services/surfaceflinger/Scheduler/MessageQueue.cpp等待消息、发送消息、处理消息。从而进行Layer合成事件。/frameworks/native/services/surfaceflinger/Scheduler/MessageQueue.cpp123456789101112void MessageQueue::Handler::handleMessage(const Message&amp; message) &#123; switch (message.what) &#123; case INVALIDATE: android_atomic_and(~eventMaskInvalidate, &amp;mEventMask); mQueue.mFlinger-&gt;onMessageReceived(message.what); break; case REFRESH: android_atomic_and(~eventMaskRefresh, &amp;mEventMask); mQueue.mFlinger-&gt;onMessageReceived(message.what); break; &#125;&#125;","tags":[{"name":"android","slug":"android","permalink":"http://wizzie.top/tags/android/"}]},{"title":"Android WMS和View基本理解","date":"2019-09-21T13:32:22.000Z","path":"2019/09/21/2019/190921-android-wms-view-cpp/","text":"概述Window 可以看做是Surface的一个包装，本质上，Window的本体就是一片Surface。将操作对象Surface，对象关联属性集以及操作方法等组合在一起便是 Window。Surface 其实是一块画布，应用可以随心所欲地通过 Canvas 或者 OpenGL 在其上作画，然后通过 SurfaceFlinger 将多块 Surface 的内容按照特定的顺序(ZOrder)进行混合并输出到 FrameBuffer，从而将 Android 漂亮的脸蛋显示给用户。既然每个窗口都有一块 Surface 供自己涂鸦，所以必然需要一个角色对所有窗口的 Surface 进行协调管理。于是,WMS 应运而生。代码： http://aosp.opersys.com/xref/android-10.0.0_r2/xref/frameworks/base/core/java/android/view/对应的关系：1 IDirectFB (顶层) &lt;–&gt; N 屏幕(Screens)1 屏幕(Screen) &lt;–&gt; N 层(Layers)1 层(Layer) &lt;–&gt; 1 主表面(Primary Surface)1 层(Layer) &lt;–&gt; N 窗口(Windows)1 窗口(Window) &lt;–&gt; 1 窗口表面(Window Surface)1 表面(Surface) &lt;–&gt; N 子表面(Subsurfaces)Dump window信息adb shell dumpsys window windows123456789101112WINDOW MANAGER WINDOWS (dumpsys window windows) Window #0 Window&#123;bdae67a u0 InputMethod&#125;: mDisplayId=0 stackId=0 mSession=Session&#123;2b3f00f 19539:u0a10056&#125; mClient=android.os.BinderProxy@59092a5 mOwnerUid=10056 mShowToOwnerOnly=true package=com.baidu.input_yijia appop=NONE mAttrs=&#123;(0,0)(fillxwrap) gr=BOTTOM CENTER_VERTICAL sim=&#123;adjust=pan&#125; ty=INPUT_METHOD fmt=TRANSPARENT wanim=0x1030056 fl=NOT_FOCUSABLE LAYOUT_IN_SCREEN SPLIT_TOUCH HARDWARE_ACCELERATED DRAWS_SYSTEM_BAR_BACKGROUNDS&#125; Requested w=1080 h=2280 mLayoutSeq=207584 mIsImWindow=true mIsWallpaper=false mIsFloatingLayer=true mWallpaperVisible=false mBaseLayer=141000 mSubLayer=0 mAnimLayer=0+=0 mLastLayer=0 mToken=WindowToken&#123;92f628b android.os.Binder@c12205a&#125; mViewVisibility=0x8 mHaveFrame=true mObscured=false......可以列出当前系统中存在的所有窗口。查看下该命令的输出可以发现Android是一个同时存在着多个窗口的系统。比如 StatusBar、NavigationBar、Activity、InputMethod、WallPaper 等窗口都可能同时存在。因为同时有多个窗口各自为政，所以需要 WMS 作为管理者来协调，以便窗口们能在狭窄的显示屏幕上和睦相处。作为协调者，WMS的本职工作主要是负责管理各窗口的生命周期（创建/销毁）、各窗口的位置大小（Layout）、各窗口的显示层级（Z-order）以及窗口的显示属性（可见性等）。相关类DisplayContent：一个容器，一个 DisplayContent 内收集了所有需要显示到相应屏幕上的窗口PhoneWindowManager：定义了 Phone 相关的窗口策略，负责为 WMS 提供各种建议，包括布局，事件处理，屏幕旋转等WindowAnimator WindowStateAnimator AppWindowAnimator： 主要负责 Surface 相关操作，包括创建，销毁，Surface 属性变更，动画等WindowToken AppWindowToken： WindowToken 的作用是将一组相关性紧密的窗口组织在一起。达到批量管理的效果WindowState： 一般被认为是 WMS 眼中的窗口，管理着关联窗口的所有属性状态信息AppWindowToken 根据 AMS 侧 Activity 的顺序有序排列，WindowState 根据 Layer 值有序排列。Window分布WMS添加窗口流程（addView）WindowManagerGlobal，是一个进程唯一的实例，也就是说无论在应用的任何角落调用addView，都会通过WindowManagerGlobal 来处理相应的请求。从理解出发，可以认为WindowManagerGlobal是一个App进程中窗口管理者。AddView简单流程frameworks/base/core/java/android/view/WindowManagerImpl.java12345@Overridepublic void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) &#123; applyDefaultToken(params); mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow);&#125;调用WindowManagerGlobal的addView函数：frameworks/base/core/java/android/view/WindowManagerGlobal.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687 Display display, Window parentWindow) &#123; if (view == null) &#123; throw new IllegalArgumentException(\"view must not be null\"); &#125; if (display == null) &#123; throw new IllegalArgumentException(\"display must not be null\"); &#125; if (!(params instanceof WindowManager.LayoutParams)) &#123; throw new IllegalArgumentException(\"Params must be WindowManager.LayoutParams\"); &#125; final WindowManager.LayoutParams wparams = (WindowManager.LayoutParams) params; if (parentWindow != null) &#123; parentWindow.adjustLayoutParamsForSubWindow(wparams); &#125; else &#123; // If there's no parent, then hardware acceleration for this view is // set from the application's hardware acceleration setting. final Context context = view.getContext(); if (context != null &amp;&amp; (context.getApplicationInfo().flags &amp; ApplicationInfo.FLAG_HARDWARE_ACCELERATED) != 0) &#123; wparams.flags |= WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED; &#125; &#125; ViewRootImpl root; View panelParentView = null; synchronized (mLock) &#123; // Start watching for system property changes. if (mSystemPropertyUpdater == null) &#123; mSystemPropertyUpdater = new Runnable() &#123; @Override public void run() &#123; synchronized (mLock) &#123; for (int i = mRoots.size() - 1; i &gt;= 0; --i) &#123; mRoots.get(i).loadSystemProperties(); &#125; &#125; &#125; &#125;; SystemProperties.addChangeCallback(mSystemPropertyUpdater); &#125; int index = findViewLocked(view, false); if (index &gt;= 0) &#123; if (mDyingViews.contains(view)) &#123; // Don't wait for MSG_DIE to make it's way through root's queue. mRoots.get(index).doDie(); &#125; else &#123; throw new IllegalStateException(\"View \" + view + \" has already been added to the window manager.\"); &#125; // The previous removeView() had not completed executing. Now it has. &#125; // If this is a panel window, then find the window it is being // attached to for future reference. if (wparams.type &gt;= WindowManager.LayoutParams.FIRST_SUB_WINDOW &amp;&amp; wparams.type &lt;= WindowManager.LayoutParams.LAST_SUB_WINDOW) &#123; final int count = mViews.size(); for (int i = 0; i &lt; count; i++) &#123; if (mRoots.get(i).mWindow.asBinder() == wparams.token) &#123; panelParentView = mViews.get(i); &#125; &#125; &#125; //新疆一个ViewRootImpl对象，调用构造函数 root = new ViewRootImpl(view.getContext(), display); //布局参数 view.setLayoutParams(wparams); mViews.add(view); mRoots.add(root); mParams.add(wparams); // do this last because it fires off messages to start doing things try &#123; root.setView(view, wparams, panelParentView); //调用setView函数 &#125; catch (RuntimeException e) &#123; // BadTokenException or InvalidDisplayException, clean up. if (index &gt;= 0) &#123; removeViewLocked(index, true); &#125; throw e; &#125; &#125;&#125;setView做了很多处理，主要的是调用requestLayout()和 mWindowSession.addToDisplay。见下面：addWindowframeworks/base/core/java/android/view/ViewRootImpl.java12345678910111213141516171819202122232425262728293031323334public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) &#123; synchronized (this) &#123; if (mView == null) &#123; mView = view; mAttachInfo.mDisplayState = mDisplay.getState(); mDisplayManager.registerDisplayListener(mDisplayListener, mHandler); ...... try &#123; mOrigWindowType = mWindowAttributes.type; mAttachInfo.mRecomputeGlobalAttributes = true; collectViewAttributes(); //添加到Display res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes, getHostVisibility(), mDisplay.getDisplayId(), mTmpFrame, mAttachInfo.mContentInsets, mAttachInfo.mStableInsets, mAttachInfo.mOutsets, mAttachInfo.mDisplayCutout, mInputChannel, mTempInsets); setFrame(mTmpFrame); &#125; catch (RemoteException e) &#123; mAdded = false; mView = null; mAttachInfo.mRootView = null; mInputChannel = null; mFallbackEventHandler.setView(null); unscheduleTraversals(); setAccessibilityFocus(null, null); throw new RuntimeException(\"Adding window failed\", e); &#125; finally &#123; if (restore) &#123; attrs.restore(); &#125; &#125; .....这里出现了mWindowSession，它的类型是 IWindowSession，是WindowManagerGlobal#sWindowSession的一个引用，进程唯一的实例。它是常见的Binder远程调用中IWindowSession的Bp端，Bn端是一个Sessio 实例，存在于WMS所属进程，Session代表了WMS关于窗口管理服务的一个子集，Android 系统中，由App进程端主动向WMS发起的请求，都是通过mWindowSession进行的，也就是说Session提供了所有App进程能够请求WMS的服务请求。调用到实现类Session.java:frameworks/base/services/core/java/com/android/server/wm/Session.java123456789public int addToDisplay(IWindow window, int seq, WindowManager.LayoutParams attrs, int viewVisibility, int displayId, Rect outFrame, Rect outContentInsets, Rect outStableInsets, Rect outOutsets, DisplayCutout.ParcelableWrapper outDisplayCutout, InputChannel outInputChannel, InsetsState outInsetsState) &#123; return mService.addWindow(this, window, seq, attrs, viewVisibility, displayId, outFrame, outContentInsets, outStableInsets, outOutsets, outDisplayCutout, outInputChannel, outInsetsState);&#125;最终调用到WMS.java的addWindow函数。addWindow的工作可以分为4步：WindowToken 检查WindowState 创建将新建的 WindowState 插入到现有的 WindowState 有序列表里给系统中现有的所有 WindowState 重新分配 Layer1234567891011121314151617 public int addWindow(Session session, IWindow client, int seq, LayoutParams attrs, int viewVisibility, int displayId, Rect outFrame, Rect outContentInsets, Rect outStableInsets, Rect outOutsets, DisplayCutout.ParcelableWrapper outDisplayCutout, InputChannel outInputChannel, InsetsState outInsetsState) &#123; int[] appOp = new int[1]; int res = mPolicy.checkAddPermission(attrs, appOp); if (res != WindowManagerGlobal.ADD_OKAY) &#123; return res; &#125; boolean reportNewConfig = false; WindowState parentWindow = null; long origId; final int callingUid = Binder.getCallingUid(); final int type = attrs.type;......relayoutWindowrelayoutWindow处理流程Surface outSurface：输出参数，用于承载该窗口的 Surface，ViewRootImpl 获得此 Surface 便可以调用Draw在上面进行绘制窗口所承载的所有View。关于 relayoutWindow 的处理内容粗略分为下列：根据传入参数更新 WindowState 对象的对应属性，这些属性都会在布局的时刻用到。根据传入的可见性参数处理窗口 Surface 的创建或销毁处理一些由窗口更新带来的一些变化，如 Focus 变化，输入法窗口/壁纸窗口移动，屏幕构型 Configuration 改变等执行 performLayoutAndPlaceSurfaceLocked 函数进行布局View概述View就是一块可以用来进行绘画，可以处理输入事件进行交互的矩形区域，而ViewGroup就是一种可以容纳View的矩形容器。从设计模式的角度看，ViewGroup 和 View 是组合模式的典型应用。View 是基本的控件元素，ViewParent 接口定义了添加、删除 View 的接口 addView、removeView，ViewGroup 实现了 ViewParent 的接口，因此可以作为 View 的容器管理 View，同时 ViewGroup 又继承自 View，可以被其他的 ViewGroup 管理。这样 ViewGroup 和 View 就可以组成上面的树状结构了。View和ViewGroup应用程序启动的过程中，会加载一个或者多个 Activity。每个 Activity 对应一个 PhoneWindow。当Activity在onCreate方法中调用 setContentView 的时候，PhoneWindow 会根据布局文件，创建 View 树，同时，根据应用的一些参数设置，得到集合了窗口显示特性的 View 树的根节点 mDecor 。WindowManagerGlobal 会通过数组记录一个应用程序对应的所有 View 树的根节点 mDecor，布局参数，以及对应的 ViewRootImpl。同时，将 mDecor 和布局参数传递给 ViewRootImpl。ViewRootImpl中实现对 View 树的整体控制，包括与 WMS 的通信，View 的描绘处理，输入事件的分发处理等。View 的结构图如下：View关系图基本元素View ：最基本的UI组件，表示屏幕上的一个矩形区域Window ：1〉 表示顶层窗口，管理界面的显示和事件的响应；2 〉每个Activity均会创建一个PhoneWindow对象，是Activity和整个View系统交互的接口。该Window在Activity的attach方法中通过调用PolicyManager.makeNewWindow创建；DecorView ：是Window中view的RootViewWindowManager ：1〉 主要用来管理窗口的一些状态、属性、view 增加、删除、更新、窗口顺序、消息收集和处理等 2〉interface，继承自ViewManager。所在应用进程的窗口管理器；3〉实现类 WindowManagerImplViewRootImpl：1 〉界面控制和消息响应；2 〉通过IWindowSession接口与全局窗口管理器WMS进行交互ActivityThread：1〉 应用程序的主线程，其中会创建关联当前 Activity 与 Window；2〉创建 WindowManager 实现类实例，把当前 DecoView 加入到 WindowManagerView处理简单流程VSYNCVSYNC 信号，即 vertical synchronization，可以理解为垂直同步，或者帧同步。是 Android4.1 为了解决 UI 不流畅问题而引入的处理。当需要同步信号的时候，通过 Choreographer 注册回调，等到 VSYNC信号到来的时候，执行相应的回调。这样，一方面可以避免频繁更新导致的画面不流程；另一方面，因为 SYNC 信号的频率大概是 60 次/秒，即可以保证帧率 60，显示效果非常平滑。VSYNC由上图可见，View 的描绘工作，是在 performTraversals 中完成的。主要分为三步：performMeasure，负责计算View的尺寸；performLayout，负责计算 View 在界面上的位置；performDraw，根据前面两步的计算结果，完成实际的描绘工作。performTraversals触发描绘处理View 的描绘是通过 performTraversals 发起的，所以任何调到 performTraversals 的地方，都会触发描绘处理。ViewRootImpl 中初次添加 View:自上而下发起遍历。应用主动调用 requestLayout:自下而上通过 mParent 调用父节点的 requestLayout，直至 ViewRootImpl。应用主动调用 invalidate:自下而上通过 mParent 调用父节点的 invalidateChild，直至 ViewRootImpl。其他情况：如应用程序的 Visibility 发生变化的时候，LayoutParams 发生变化的时候等，都会触发遍历操作。performMeasure（测量）测量流程frameworks/base/core/java/android/view/ViewRootImpl.java1234567891011private void performMeasure(int childWidthMeasureSpec, int childHeightMeasureSpec) &#123; if (mView == null) &#123; return; &#125; Trace.traceBegin(Trace.TRACE_TAG_VIEW, \"measure\"); try &#123; mView.measure(childWidthMeasureSpec, childHeightMeasureSpec); &#125; finally &#123; Trace.traceEnd(Trace.TRACE_TAG_VIEW); &#125;&#125;frameworks/base/core/java/android/view/View.java12345678910111213141516171819202122232425262728293031323334353637383940public final void measure(int widthMeasureSpec, int heightMeasureSpec) &#123; boolean optical = isLayoutModeOptical(this); if (optical != isLayoutModeOptical(mParent)) &#123; Insets insets = getOpticalInsets(); int oWidth = insets.left + insets.right; int oHeight = insets.top + insets.bottom; widthMeasureSpec = MeasureSpec.adjust(widthMeasureSpec, optical ? -oWidth : oWidth); heightMeasureSpec = MeasureSpec.adjust(heightMeasureSpec, optical ? -oHeight : oHeight); &#125; ...... if (forceLayout || needsLayout) &#123; // first clears the measured dimension flag mPrivateFlags &amp;= ~PFLAG_MEASURED_DIMENSION_SET; resolveRtlPropertiesIfNeeded(); int cacheIndex = forceLayout ? -1 : mMeasureCache.indexOfKey(key); if (cacheIndex &lt; 0 || sIgnoreMeasureCache) &#123; // measure ourselves, this should set the measured dimension flag back onMeasure(widthMeasureSpec, heightMeasureSpec); //调用onMeasure函数 mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT; &#125; else &#123; long value = mMeasureCache.valueAt(cacheIndex); // Casting a long to int drops the high 32 bits, no mask needed setMeasuredDimensionRaw((int) (value &gt;&gt; 32), (int) value); mPrivateFlags3 |= PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT; &#125; // flag not set, setMeasuredDimension() was not invoked, we raise // an exception to warn the developer if ((mPrivateFlags &amp; PFLAG_MEASURED_DIMENSION_SET) != PFLAG_MEASURED_DIMENSION_SET) &#123; throw new IllegalStateException(\"View with id \" + getId() + \": \" + getClass().getName() + \"#onMeasure() did not set the\" + \" measured dimension by calling\" + \" setMeasuredDimension()\"); &#125; mPrivateFlags |= PFLAG_LAYOUT_REQUIRED; &#125; ......1234protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec)); &#125;performLayout（布局）布局流程performDraw（硬件渲染）performDraw调用draw，完成绘制工作。实际绘制操作可以分为硬件渲染和软件渲染两种情况。Step1. ViewRootImpl.setView当mSurfaceHolder为空，也就是说应用不会要求自己接管对窗口的渲染的情况下，才会开始硬件渲染环境的准备。Step2. ViewRootImpl.enableHardwareAccelerationframeworks/base/core/java/android/view/ViewRootImpl.java1234567891011121314151617public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) &#123; synchronized (this) &#123; ......// If the application owns the surface, don't enable hardware acceleration if (mSurfaceHolder == null) &#123; // While this is supposed to enable only, it can effectively disable // the acceleration too. enableHardwareAcceleration(attrs); final boolean useMTRenderer = MT_RENDERER_AVAILABLE &amp;&amp; mAttachInfo.mThreadedRenderer != null; if (mUseMTRenderer != useMTRenderer) &#123; // Shouldn't be resizing, as it's done only in window setup, // but end just in case. endDragResizing(); mUseMTRenderer = useMTRenderer; &#125; &#125;常驻内存的进程，禁止使用硬件加速，因为非常耗费内存。系统进程一般都要禁用硬件加速，但是以下两种情况除外：(1) 应用启动之前的Starting Window，会通过设置以下flag，标示启用硬件加速，但是不缓存：WindowManager.LayoutParams.PRIVATE_FLAG_FAKE_HARDWARE_ACCELERATED(2) 锁屏界面，虽然是在系统进程中，但是通过设置以下 flag，可以启用硬件加速：WindowManager.LayoutParams.PRIVATE_FLAG_FORCE_HARDWARE_ACCELERATED其他情况，根据 Activity 窗口是否请求硬件加速渲染决定是否开启硬件加速。通过判断flags位WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED被置为1，同时硬件支持硬件加速，就可以继续后面的初始化工作了。Step3: ThreaedRenderer.create设备支持 Open GL ES2.0，就创建对象：ThreadedRender。通过 nCreateRootRenderNode 在 Native 层创建一个 Render Node。通过 adopt 方法，将 Native 层的 Render Node 封装成 Java 层的 Render Node。通过 nCreateProxy 在 Native 层创建一个 Render Proxy 对象。该proxy对象以后负责从Main Thread向RenderThread发送命令。RenderProxy 有三个重要的成员变量：mRenderThread：进程单例，指向 RenderThread 对象，通过它可以向 RenderThread 线程发送命令。mContext：画布上下文。RenderThread 通过它完成渲染工作。mDrawFrameTask：指向一个 DrawFrameTask 对象，Main thread 通过它向 Render Thread 线程发送渲染下一帧的命令。Step4：ViewRootImpl.performTraversals当得到了有效的surface，就通过ThreadedRender的initialize方法，将该surface与RenderThread绑定。硬件渲染流程图硬件渲染流程ThreadedRender.draw主要执行三个操作：调用成员函数 updateRootDisplayList 构建或者更新应用程序窗口的 Root Render Node 的 DisplayList。RenderNode.start 和 RenderNode.end 直接的处理，与软件渲染的流程一样，只是硬件渲染的时候，只把渲染命令存储到 DisplayList 中，并不真正开始执行渲染操作。调用成员函数 registerAnimationRenderNode 注册应用程序窗口动画相关的 Render Node 到 native 层。这些RenderNode是用于描述当前窗口设置的动画。调用成员函数 nSyncAndDrawFrame，通知Render Thread绘制下一帧。其具体实现在 navtive 层。通DrawFrameTask 向 RenderThread 的 task Queue 抛出一个消息，等待 RenderThread 在合适的时候唤醒。软件渲染在 ViewRootImpld 的 draw()如果不进行硬件渲染，会进行软件渲染drawSoftware()Step1. ViewRootImpl.Draw计算窗口是否处于滚动状态。计算 dirty 区域，也就是需要重绘的区域。Dirty 区域不为空，或者动画进行中，继续判断是否选择了硬件加速，如果没有使用硬件加速，则通过 drawSoftware（）发起软件渲染。如果动画执行过程中，发起下一次轮询。frameworks/base/core/java/android/view/ViewRootImpl.java12345678private boolean draw(boolean fullRedrawNeeded) &#123; Surface surface = mSurface; ...... if (!drawSoftware(surface, mAttachInfo, xOffset, yOffset, scalingRequired, dirty, surfaceInsets)) &#123; return false; &#125; ......Step2. ViewRootImlp.drawSoftware通过 lockCanvas()获取画布。Step3. Framelayout.draw(Canvas)ViewRootImpl 中，通过 mView.draw(canvas)，调用 DecorView 的 draw 方法；DecorView 通过 super.draw(canvas)，调用父类 Framlayout 的 Draw 方法。在 FrameLayout 中，通过 super.draw(canvas)方法，调用 View.draw 方法，触发实际的描绘处理。Step4. View.draw描绘背景。如果 PFLAG_DIRTY_OPAQUE 被设置，并且 mAttachInfo.mIgnoreDirtyState=flase，说明有不透明子view遮挡了当前的 view，不需要绘制背景。保存当前画布的堆栈状态，并且创建额外的图层描绘当前视图滑动时的边框渐变效果。FADING_EDGE_VERTICAL 和FADING_EDGE_HORIZONTAL 都没有被设置的时候，不需要执行这步操作。通过 onDraw 调用子类描绘处理，完成当前视图的描绘。通过 dispatchDraw 调用子视图的描绘处理。绘制边框的渐变效果（与步骤 2 对应），并且恢复图层。此步骤不是必需的。如果需要显示滚动条，通过 onDrawScrollBars 调用描绘滚动条。Step5. ViewGroup.dispatchDrawFLAG_RUN_ANIMATION被设置，并且允许显示子视图的动画，则通过 bindLayoutAnimation 设置动画。设置完成后，通过LayoutAnimationController 的对象来启动动画，并且调用 mAnimationListener 的 onAnimationStart()来通知动画监听，当前视图开始显示动画了。如果子视图可见或者有动画需要显示，就通过方法 drawChild 实现子视图的绘制。如果动画结束，通过notifyAnimationListener发送消息，通知动画监听者，动画已经结束。Step6. ViewGroup.drawChild调用子 view 的 draw(Canvas, ViewGroup,long)方法，实现子视图的绘制。Step7. View.draw(Canvas, ViewGroup, long)通过方法drawAnimation实现动画的绘制。通过flag检查子视图是否支持缓冲方式绘制。即将子视图缓冲到一个Bitmap中，后续可以通过getDrawingCache获得该bitmap。以非缓冲的方式绘制：检查 SKIP_DRAW 标记是否被置位，如果为 1，则跳过当前视图的绘制，调用 ViewGroup 的dispatchDraw，重复前面过程，继续该视图的子视图的绘制；否则，通过调用 View.draw(Canvas)，重复 step4 的过程，完成当前视图的绘制以后，再发起子视图的绘制。以缓冲的方式绘制：通过 canvas.drawBitmap()将上次缓冲的 Bitmap 对象 cache 绘制到画布上。Step8. ViewRootImpl.drawSoftware循环上面的过程，直到所有子视图都被绘制到画布上，返回 drawSoftware 方法。通过 surface.unlockCanvasAndPost()方法，请求 SurfaceFlinger 服务渲染这块画布到图形缓冲区。软件渲染流程图软件渲染流程图","tags":[{"name":"graphics","slug":"graphics","permalink":"http://wizzie.top/tags/graphics/"}]},{"title":"C++ 运算符重载、友元、返回对象","date":"2019-09-16T14:59:00.000Z","path":"2019/09/16/2019/190916_cpp_useclass/","text":"运算符重载运算符重载将重载的概念扩展到运算符上，允许赋予C++运算符多种含义。例如* 用于地址，将获得存储在这个地址中的值；而用于两个数字之间，得到的是乘积。要重载运算符，可以使用被称为运算符函数的特殊函数形式，运算符函数的格式如下：operator(argument-list)例如operator+()重载+运算符，operator*()重载*运算符。op必须是有效的运算符，不能虚构新的符号。比如不存在operator@()。1234567Time Time::operator+(const Time &amp;t) const &#123; Time sum; sum.minutes = minutes + t.minutes; sum.hours = hours + t.hours + sum.minutes / 60; sum.minutes %= 60; return sum;&#125;重载限制重载后的运算符必须至少有一个操作数是用户定义的类型。防止用户为标准类型重载运算符。即不能用减法运算符重载求和，会影响性能。使用运算符不能违反运算符原来的句法规则。例如不能将求模（余数）运算符重载成使用一个操作数：12- int x;- % x; //Error同时不能修改运算符的优先级。不能创建新运算符，例如不能定义operator**()函数来表示求幂。不能重载以下运算符：运算符释义sizeofsizeof求长度运算符.成员运算符.*成员指针运算符::作用域解析运算符?条件运算符typeid一个RTTI运算符const_cast强制类型转换运算符dynamic_cast强制类型转换运算符reinterpret_cast强制类型转换运算符static_cast强制类型转换运算符友元C++控制对类对象私有部分的访问，通常公有类提供唯一的访问途径，但是有时候限制太严格，以致于不适合特定的编程情形。因而C++提供另一种形式的访问权限：友元 ， 有三种：友元函数友元类友元成员函数（通过让函数成为类的友元，可以赋予该函数与类的成员函数相同的访问权限。）在为类重载二元运算符时常常需要友元。创建友元将原型放在类声明中，并在原型声明前加上关键字friend。friend Time operator* (double m, const Time &amp;t);//goes in class declaration表明两点：虽然是在类声明中声明，但不是成员函数，因此不能使用成员运算符调用（.或者-&gt;），不能使用Time::限定符虽然不是成员函数，但是和成员函数的访问权限相同在函数实现中不要使用关键字friend123Time operator*(double m, const Time &amp;t) &#123; ......&#125;返回对象相关当成员函数或独立的函数返回对象时，有几种返回方式可供选择，可以返回指向对象的引用、指向对象的const引用或const对象。返回指向const对象的引用使用const引用的常见原因是极高效率，但是对何时可以采用这种方式存在限制。如果函数返回（通过调用对象的方法或者将对象作为参数）传递给他的对象，可以通过返回引用来提高效率。1234567891011121314151617181920212223Vector force1(50, 60);Vector force2(10, 70);Vector max;max = Max(force1, force2);//version 1 //返回对象将调用复制构造函数Vector Max(const Vector &amp; v1, const Vector &amp; v2) &#123; if (v1.magval() &gt; v2.magval()) return v1; else return v2;&#125;//version 2 //返回引用不会调用构造函数，因而效率更高；//其次引用指向的对象在调用函数时存在（此处的force1和force2在调用函数中定义，满足条件）；//v1和v2都被声明为const引用，因此返回类型必须是const，这样才匹配const Vector &amp; Max(const Vector &amp; v1, const Vector &amp; v2) &#123; if (v1.magval() &gt; v2.magval()) return v1; else return v2;&#125;返回指向非const对象的引用两种常见的返回非const对象的情形：重载赋值运算符（旨在提高效率）重载与const一起使用的&lt;&lt;运算符（必须这么做）1234//operator=()的返回值用于连续赋值String s1(\"Good stuff\");String s2,s3;s3 = s2 = s1; //s2.operator=()的返回值被赋值给s3，通过使用引用可以避免该函数调用String的复制构造函数来创建一个新的String对象在这个例子中，返回类型不是const，因为方法operator=()返回一个指向s2的引用，可以对其进行修改。12String s1(\"Good\");cout &lt;&lt; s1 &lt;&lt; \"is coming\";在这个例子中，返回类型必须是ostream&amp; ，而不能仅是ostream，否则将调用ostream类的复制构造函数，而ostream没有共有的复制构造函数。返回对象如果返回的对象是被调用函数中的局部变量，则不应使用引用方式返回它。因为在被调用函数执行完毕，局部对象将调用其析构函数。小结指针和对象使用使用常规表示法来声明指向已有的对象，String * glamour;可以将指针初始化为指向已有的对象，String * first = &amp;sayings[0];可以使用new来初始化指针，这将会创建一个新的对象，String * favorite = new String(sayings[choice]);对类使用new将调用相应的构造函数来初始化新建的对象可以使用-&gt;运算符通过指针访问类的方法，shortest-&gt;length()可以对对象的指针应用解除引用运算符*来获得对象，’if (sayings[i] &lt; *first&gt;)’重载&lt;&lt;运算符要重新定义&lt;&lt;运算符，以便将他和cout一起用来显示对象的内容，请定义下面的友元运算符函数：12345//c_name是类名，如果该类提供了能够返回所需内容的公有方法，则可在运算符函数中使用这些方法，这样编不用将他们设置为友元函数ostream &amp; operator&lt;&lt; (ostream &amp;os, const c_name &amp; obj) &#123; os &lt;&lt; ...; //display object contents return os;&#125;转换函数要将单个值转换为类类型，需要创建原型如下所示的类构造函数：c_name(type_name value)其中c_name是类名，type_name是要转换的类型的名称。要将类转换为其他类型，需要创建类如下所示的类成员函数:operator type_name();虽然该函数没有声明返回类型，但应返回所需类型的值。使用转换函数时，可以在声明构造函数中使用关键字explicit，放置它被用于隐式转换。其构造函数使用new的类对于指向的内存是由new分配的所有类成员，都应在类的析构函数中对其使用delete，该运算符将释放分配的内存如果析构函数通过对指针类成员使用delete来释放内存，则每个构造函数都应当使用new来初始化指针，或将其设置为空指针构造函数中要么使用new，要么使用new[]，不能混用。对应的析构函数使用delete，和delete[]应定义一个分配内存的复制构造函数，这样程序能够将类对象初始化为另一个类对象，通常的函数原型：className(const className &amp;)应定一个重载赋值运算符的类成员函数，其函数定义如下:12345678910c_name &amp; c_name::operator=(const c_name &amp; cn) &#123; if (this == &amp;cn) return *this; delete [] c_pointer; //是c_name的类成员，是指向type_name的指针 //set size number of type_name unite to be copied c_pointer = new type_name[size]; //then copy data pointed to by cn.c_pointer to location pointed to by c_pointer ... return *this;&#125;Share一个Ubuntu免费使用ultraEdit的方法在bin目录下建立一个脚本，并且在打开软件前执行：uexClearCache.sh123rm -rfd ~/.idm/uex rm -rf ~/.idm/*.spl rm -rf /tmp/*.spl","tags":[{"name":"cpp","slug":"cpp","permalink":"http://wizzie.top/tags/cpp/"}]},{"title":"Android zygote和SystemServer进程","date":"2019-09-10T14:52:00.000Z","path":"2019/09/10/2019/190910_android_zygote_systemserver/","text":"zygote和system_server在Android中的Java层很重要。zygote分析zygote由init进程根据init.rc的配置项创建的。最初叫app_process，但是在运行过程中，通过Linux的pctrl系统调用将其换成了zygote。通过adb shell ps -ef|grep zygote查看到该进程。Android-10.0.0_r2 AOSP源码中，查看其入口函数：frameworks/base/cmds/app_process/app_main.cpp12345678910111213141516171819202122232425262728int main(int argc, char* const argv[])&#123; if (!LOG_NDEBUG) &#123; String8 argv_String; for (int i = 0; i &lt; argc; ++i) &#123; argv_String.append(\"\\\"\"); argv_String.append(argv[i]); argv_String.append(\"\\\" \"); &#125; ALOGV(\"app_process main with argv: %s\", argv_String.string()); &#125; AppRuntime runtime(argv[0], computeArgBlockSize(argc, argv)); // Process command line arguments // ignore argv[0] argc--; argv++;...... if (zygote) &#123; runtime.start(\"com.android.internal.os.ZygoteInit\", args, zygote); &#125; else if (className) &#123; runtime.start(\"com.android.internal.os.RuntimeInit\", args, zygote); &#125; else &#123; fprintf(stderr, \"Error: no class name or --zygote supplied.\\n\"); app_usage(); LOG_ALWAYS_FATAL(\"app_process: no class name or --zygote supplied.\"); &#125;&#125;重要的功能由AppRuntime的start函数完成。而AppRuntime类就在app_main.cpp中，从AndroidRuntime派生而来。frameworks/base/core/jni/AndroidRuntime.cpp12345678910111213141516171819202122232425262728293031323334353637383940414243void AndroidRuntime::start(const char* className, const Vector&lt;String8&gt;&amp; options, bool zygote)&#123; ALOGD(\"&gt;&gt;&gt;&gt;&gt;&gt; START %s uid %d &lt;&lt;&lt;&lt;&lt;&lt;\\n\", className != NULL ? className : \"(unknown)\", getuid()); static const String8 startSystemServer(\"start-system-server\");...... /* start the virtual machine */ JniInvocation jni_invocation; jni_invocation.Init(NULL); JNIEnv* env; if (startVm(&amp;mJavaVM, &amp;env, zygote) != 0) &#123; //创建虚拟机 return; &#125; onVmCreated(env); /* * Register android functions. */ if (startReg(env) &lt; 0) &#123; //注册JNI函数 ALOGE(\"Unable to register all android natives\\n\"); return; &#125;..... /* * Start VM. This thread becomes the main thread of the VM, and will * not return until the VM exits. */ char* slashClassName = toSlashClassName(className != NULL ? className : \"\"); jclass startClass = env-&gt;FindClass(slashClassName); if (startClass == NULL) &#123; ALOGE(\"JavaVM unable to locate class '%s'\\n\", slashClassName); /* keep going */ &#125; else &#123; jmethodID startMeth = env-&gt;GetStaticMethodID(startClass, \"main\", \"([Ljava/lang/String;)V\"); if (startMeth == NULL) &#123; ALOGE(\"JavaVM unable to find main() in '%s'\\n\", className); /* keep going */ &#125; else &#123; env-&gt;CallStaticVoidMethod(startClass, startMeth, strArray); //通过JNI调用Java中ZygoteInit的main函数，进入Java世界......创建虚拟机startVM该函数调用JNI的Dalvik虚拟机创建函数，在sdtartVM中确定创建虚拟机的一些参数注册JNI函数 startReg给虚拟机注册一些JNI函数，采用native方式实现。java入口 CallStaticVoidMethodCallStaticVoidMethod最终调用frameworks/base/core/java/com/android/internal/os/ZygoteInit.java的main函数。1234567891011121314151617181920212223242526272829 @UnsupportedAppUsage public static void main(String argv[]) &#123; ZygoteServer zygoteServer = null; // Mark zygote start. This ensures that thread creation will throw // an error. ZygoteHooks.startZygoteNoThreadCreation(); // Zygote goes into its own process group. try &#123; Os.setpgid(0, 0); &#125; catch (ErrnoException ex) &#123; throw new RuntimeException(\"Failed to setpgid(0,0)\", ex); &#125; Runnable caller;...... if (startSystemServer) &#123; //启动system_server Runnable r = forkSystemServer(abiList, zygoteSocketName, zygoteServer); // &#123;@code r == null&#125; in the parent (zygote) process, and &#123;@code r != null&#125; in the // child (system_server) process. if (r != null) &#123; r.run(); return; &#125; &#125;......forkSystemServer会创建java世界中系统service所驻留的进程system_server，该进程是framework的核心。SystemServerSystemServer的进程名叫做system_server，由zygote进程中创建。forkSystemServer函数中调用handleSystemServerProcess()来处理自己的事务。调用到systemserver的main函数。frameworks/base/services/java/com/android/server/SystemServer.java123456789101112131415161718192021222324/** * The main entry point from zygote. */public static void main(String[] args) &#123; new SystemServer().run();&#125;public SystemServer() &#123; // Check for factory test mode. mFactoryTestMode = FactoryTest.getMode(); // Record process start information. // Note SYSPROP_START_COUNT will increment by *2* on a FDE device when it fully boots; // one for the password screen, second for the actual boot. mStartCount = SystemProperties.getInt(SYSPROP_START_COUNT, 0) + 1; mRuntimeStartElapsedTime = SystemClock.elapsedRealtime(); mRuntimeStartUptime = SystemClock.uptimeMillis(); // Remember if it's runtime restart(when sys.boot_completed is already set) or reboot // We don't use \"mStartCount &gt; 1\" here because it'll be wrong on a FDE device. // TODO: mRuntimeRestart will *not* be set to true if the proccess crashes before // sys.boot_completed is set. Fix it. mRuntimeRestart = \"1\".equals(SystemProperties.get(\"sys.boot_completed\"));&#125;随后会创建一些系统服务，并将调用线程加入到Binder通信中。并且会创建一个单独的线程，用以启动系统的各项服务，例如电池管理服务BatteryService，电源管理服务PowerManagerService，StartWindowManagerService，ActivityManagerService等等。开机耗时长的原因ZygoteInit的main函数中的preloadClasses加载了上千个类开机启动时会对系统所有的APK扫描并收集信息SystemServer创建的一系列service，占用不少时间虚拟机heapsize的限制zygote创建虚拟机的时候，系统默认设置的java虚拟机堆栈值（可修改）对于使用较大内存的程序远远不够。zygote通过fork创建子进程，因而本身设置的信息会被子进程全部继承，例如设置堆栈对32MB，则子进程也会使用32MB。watchdog看门狗watchdog作用是每隔一段时间去检查某个参数是否被设置了，如果发现该参数没有被设置，则判断为系统出错，然后强制重启。Android对于systemserver的参数是否被设置也增加了一条看门狗。主要检查几个重要的service，如果service出了问题就会杀掉system_server，这回导致zygote也一起杀掉，导致java层重启。SystemServer和Watchdog的交互大致分为三个步骤(frameworks/base/services/core/java/com/android/server/Watchdog.java)：Watchdog.getInstance().init()初始化Watchdog.getInstance().start()，派生于Thread类，start启动线程，导致Watchdog的run在另外一个线程中被执行。该函数实现隔一段时间发送一条信息，那个线程将检查各个service的健康状况，而看门狗等待检查结果，如果第二次没有返回结果，将会杀掉systemserverWatchdog.getInstance().addMonitor()，如果要支持看门狗的检查，就需要让service实现monitor接口（比如ActivityManagerService,PowerManagerService,WindowManagerService）Example:当一个函数占着锁，长时间没有返回（原因是这个函数需要和硬件交互，而硬件没有及时返回），导致系统服务死锁被watchdog检查到。","tags":[{"name":"android","slug":"android","permalink":"http://wizzie.top/tags/android/"}]},{"title":"Android init进程","date":"2019-09-09T13:52:00.000Z","path":"2019/09/09/2019/190909_android_init_service/","text":"概述init是Linux系统中用户空间的第一个进程。通过adb shell ps -rf查看我的一加手机进程信息。12UID PID PPID C STIME TTY TIME CMDroot 1 0 0 12:43:34 ? 00:00:10 initinit进程负责创建系统中的几个关键进程，例如zygoteinit提供了一个property service（属性服务）来管理Android系统的众多属性init分析使用android-10.0.0_r2 AOSP最新源码（http://192.99.106.107:8080/xref/android-10.0.0_r2/）init进程的入口函数从/system/core/init/main.cpp的main函数开始：system/core/init/main.cpp123456789101112131415161718192021222324252627int main(int argc, char** argv) &#123;#if __has_feature(address_sanitizer) __asan_set_error_report_callback(AsanReportCallback);#endif if (!strcmp(basename(argv[0]), \"ueventd\")) &#123; return ueventd_main(argc, argv); &#125; if (argc &gt; 1) &#123; if (!strcmp(argv[1], \"subcontext\")) &#123; android::base::InitLogging(argv, &amp;android::base::KernelLogger); const BuiltinFunctionMap function_map; return SubcontextMain(argc, argv, &amp;function_map); &#125; if (!strcmp(argv[1], \"selinux_setup\")) &#123; return SetupSelinux(argv); &#125; if (!strcmp(argv[1], \"second_stage\")) &#123; return SecondStageMain(argc, argv); //此处调用init.cpp的函数入口 &#125; &#125; re在Android Q之前，此处一直都是直接调用入口函数：system/core/init/main.cpp123int main(int argc, char** argv) &#123; android::init::main(argc, argv);&#125;然后会调用到init.cpp中的SecondStageMain函数。init的工作流程精简为以下四点：解析配置文件执行各个阶段的动作（创建zygote的工作就是此时完成）调用Property_init初始化属性相关的资源init进入一个无线循环，等待一些事情的发生（init处理来自socket和来自属性服务器的相关事情）解析系统配置文件init.rc在入口函数调用LoadBootScripts(am, sm);然后调用parser.ParseConfig(bootscript);调用system/core/init/parser.cpp的parseConfig函数调用Parser::ParseConfigFile函数，读取配置文件并解析1234567891011121314bool Parser::ParseConfigFile(const std::string&amp; path) &#123; LOG(INFO) &lt;&lt; \"Parsing file \" &lt;&lt; path &lt;&lt; \"...\"; android::base::Timer t; auto config_contents = ReadFile(path); //读取init.rc配置文件 if (!config_contents) &#123; LOG(INFO) &lt;&lt; \"Unable to read config file '\" &lt;&lt; path &lt;&lt; \"': \" &lt;&lt; config_contents.error(); return false; &#125; ParseData(path, &amp;config_contents.value()); LOG(VERBOSE) &lt;&lt; \"(Parsing \" &lt;&lt; path &lt;&lt; \" took \" &lt;&lt; t &lt;&lt; \".)\"; return true;&#125;init.rc解析service查看/system/core/rootdir/init.rc123456789101112131415161718192021222324252627282930313233343536373839404142on init //on关键字表示一个section，对应的名字时init sysclktz 0 # Mix device-specific information into the entropy pool copy /proc/cmdline /dev/urandom copy /system/etc/prop.default /dev/urandom symlink /proc/self/fd/0 /dev/stdin...# It is recommended to put unnecessary data/ initialization from post-fs-data# to start-zygote in device's init.rc to unblock zygote start.on zygote-start &amp;&amp; property:ro.crypto.state=unencrypted # A/B update verifier that marks a successful boot. exec_start update_verifier_nonencrypted start netd start zygote start zygote_secondaryon zygote-start &amp;&amp; property:ro.crypto.state=unsupported # A/B update verifier that marks a successful boot. exec_start update_verifier_nonencrypted start netd start zygote start zygote_secondaryon zygote-start &amp;&amp; property:ro.crypto.state=encrypted &amp;&amp; property:ro.crypto.type=file # A/B update verifier that marks a successful boot. exec_start update_verifier_nonencrypted start netd start zygote start zygote_secondaryon boot //新的section，名为boot # basic network init ifup lo //一个command hostname localhost domainname localdomain # IPsec SA default expiration length write /proc/sys/net/core/xfrm_acq_expires 3600...init.rc中：class_start，标识一个COMMAND，对应的处理函数是do_class_start，位于boot section范围内。属性服务注册标可以存储一些类似ket/value的键值对，一般系统或某些应用程序会吧自己的一些属性存储在注册表中，即使重启，还是能够根据之前在注册表中设置的属性，进行相应的初始化工作。Android平台也提供了一个类似的机制，称为属性服务（property service）property的初始化在init.cpp的主函数里面：123456789101112131415161718property_init();...... // Make the time that init started available for bootstat to log. property_set(\"ro.boottime.init\", getenv(\"INIT_STARTED_AT\")); property_set(\"ro.boottime.init.selinux\", getenv(\"INIT_SELINUX_TOOK\")); // Set libavb version for Framework-only OTA match in Treble build. const char* avb_version = getenv(\"INIT_AVB_VERSION\"); if (avb_version) property_set(\"ro.boot.avb_version\", avb_version);... property_load_boot_defaults(load_debug_prop); UmountDebugRamdisk(); fs_mgr_vendor_overlay_mount_all(); export_oem_lock_status(); StartPropertyService(&amp;epoll); MountHandler mount_handler(&amp;epoll); set_usb_controller();......","tags":[{"name":"android","slug":"android","permalink":"http://wizzie.top/tags/android/"}]},{"title":"C++对象和类","date":"2019-09-04T14:52:00.000Z","path":"2019/09/04/2019/190904_cpp_class_object/","text":"类型指定基本类型完成了三项工作：决定数据对象需要的内存数量决定如何解释内存中的位（long和float所占位数相同，但是将他们转换成数值的方法不同）决定可使用数据对象执行的操作和方法类class类规范由两部分组成：类声明：以数据成员的方式描述数据部分，以成员函数（方法）的方式描述公有接口类方法定义：描述如何实现类成员函数即类声明提供类的蓝图，方法定义则提供了细节。类声明举例：stock00.h12345678910111213141516171819#ifndef STOCKOO_H_#define STOCKOO_H_#include&lt;string&gt;class Stock &#123; private: //只能通过公共成员（或友元函数）访问的类成员，例如要修改shares，只能通过Stock的成员函数 std::string company; long shares; double share_val; double total_val; void set_tot() &#123; total_val = shares * share_val; &#125; public: void acquire(const std::String &amp;co, long n); //函数原型 protected: ...&#125;实现类成员函数为由类声明中的函数原型表示的成员函数提供代码。成员函数定义和常规函数相似，有函数头和函数体、返回类型和参数，但是有两个特征：定义成员函数时，使用作用域解析运算符::来标识函数所属的类void Stock::update(double price) {...}此处的update即是Stock的成员函数，这就意味着可以将另一个类的成员函数也命名为update。类方法可以访问类的private组件构造函数函数声明对象时，将自动调用构造函数。构造函数的参数表示的不是类成员，而是赋给类成员的值。因此，参数名不能和类成员相同，否则会导致混乱。使用构造函数：显示调用构造函数：Stock food = Stock(&quot;World cabbage&quot;, 250, 1.25);隐式调用构造函数：Stock garment(&quot;Furry&quot;, 50, 2.6);创建类对象：Stock *pstock = new Stock(&quot;ABC&quot;, 18, 19.0);Notes:如果没有提供任何构造函数，则自动提供默认构造函数。比如：Sotck::stock() {...}如果定义了构造函数，就必须提供默认构造函数，否则会报错。定义的方式有两种：给已有构造函数的所有参数提供默认值，Stock(const string&amp;co = &quot;Error&quot;, int n =0;)通过函数重载来定义另一个没有参数的构造函数，Stock()而只能拥有一个默认构造函数，所以不要同时使用这两个方式。而用户定义的默认构造函数通常给所有成员提供了隐式初始值。例如：123456Stock::Stock() &#123; company = \"no name\"; share = 0; share_val = 0.0; total_val = 0.0;&#125;隐式的调用默认构造函数时，不用使用圆括号。Stock stock1;析构函数如果构造函数使用new发根配内存，则析构函数将使用delete释放内存。而析构函数的名称是在函数名前加上~，例如~Stock()。Stock的析构函数不承担任何重要的工作，因此直接编写不执行任何操作的函数：123Stock::~Stock() &#123;&#125;编译器决定调用析构函数的时机如果创建的是静态存储对象，则其析构函数就爱你挂在程序结束时自动调用如果创建的是自动存储类对象，则其析构函数将在程序执行完代码块时（该对象是在其中定义的）自动被调用如果对象通过new创建的，则将驻留在栈内存或者自由存储区中，当使用delete来释放内存时，其析构函数将自动被调用程序可以创建临时对象来完成特定的操作，此时程序将在结束对该对象使用时自动调用其析构函数this指针this指针指向用来调用成员函数的对象（this被称为隐藏参数传递给方法）每个成员函数（包含构造函数和析构函数）都有一个this指针。this指针指向调用对象。如果方法想要引用整个调用对象，则可以使用表达式*this。在函数的括号后面使用const限定符将this限定为const，这样将不能使用this来修改对象的值。然而要返回的不是this，因为this是对象的地址，*this是指向的值。123456const Stock &amp; Stock::topval(const Stock &amp; s) const &#123; if (s.total_val &gt; total_val) return s; else return *this;&#125;对象数组创建同一个类的多个对象，创建对象数组比独立对象变量更合适。Stock mystuff[4];123456789101112mystuff[0].update();mystuff[3].show();const Stock * tops = mystuff[2].topval(mystuff[1]);//使用构造函数初始化数组元素，此时必须为没够元素调用构造函数const int STKS = 4;Stock stocks[STKS] = &#123; Stock(\"A\", 12.5, 20), Stock(\"B\", 11.5, 530), Stock(\"C\", 13.5, 120), Stock(\"D\", 14.5, 30),&#125;;类作用域在类中定义的名称（如类数据称源和类成员函数名）的作用域都为整个类。在类声明或成员函数定义中，可以使用未修饰的成员名称（未限定的名称）。构造函数名称被调用时，才能被识别，因为他的名称和类名相同。在其他情况下，使用类成员名时，必须根据上下文使用直接成员运算符（.），间接成员运算符（-&gt;）或者作用域解析运算符（::）作用域于为类的常量声明类只是描述了对象的形式，并没有创建对象。因此，在创建对象前，没有用于存储值的空间（C++11提供了成员初始化，但不适用于数组声明）。因此以下的方式初始化不正确：12345class Bck &#123; private:- const int Months = 12; //fail- double costs[Months];&#125;可以使用以下方式,在类中声明一个枚举，枚举的作用域是整个类。12345class Bck &#123; private:+ enum &#123;Months= 12&#125;;+ double costs[Months];&#125;可以在类中定义常量的方式，使用关键字static。这将常量和其他静态变量存储在一起，而不是存储在对象中。因此只有一个Months常量，被所有的Bck类对象共享。12345class Bck &#123; private:+ static const int Months= 12;+ double costs[Months];&#125;C++11作用域内枚举传统的枚举容易出现冲突，例如在一个类中定义：12enum egg &#123;Small. Large, Medium&#125;;enum t_shirt &#123;Small. Large, Medium&#125;;C++11提供一种新枚举，其枚举量的作用域是类，如下：12345678enum class egg &#123;Small. Large, Medium&#125;;enum class t_shirt &#123;Small. Large, Medium&#125;;//或者使用struct关键字代替classenum struct egg &#123;Small. Large, Medium&#125;;enum struct t_shirt &#123;Small. Large, Medium&#125;;egg choic = egg::Large;t_shirt Floyd = t_shirt::Large; //此时将不再发生冲突抽象数据类型C++使用栈来管理自动变量，当新的自动变量被生成后，他们被添加到栈顶；消亡时，从栈中删除他们。栈的特征栈存储了多个数据项（该特征使得栈成为一个容器，一种通用的抽象），其次，栈由可对他执行的操作来描述。可创建空栈可将数据项添加到栈顶（压入）可从栈顶删除数据项（弹出）可查看栈是否填满可查看栈是否为空如果将上述描述转换为一个类声明，其中公有成员函数提供了栈操作的接口，而私有数据成员负责存储栈数据。私有部分必须表明数据存储的方式，例如可以使用常规数组、动态分配数组或者更高级的数据结构。小结通常将类声明分成两部分，类声明（包含函数原型表示的方法）应该放在头文件中。定义成员函数的源代码放在方法文件中。使用OOP方法的第一步是根据他和程序之间的接口描述数据，从而指定如何使用数据。然后设计一个类来实现该接口。一般来说，私有数据成员存储信息，公有成员函数（又称作方法）提供访问数据的唯一途径。类将数据和方法组合成一个单元，其私有性实现数据隐藏。类是用户定义的类型，而对象是类的实例。也可以说对象是这种类型的变量，例如由new按类描述分配的内存。如果希望成员函数对多个对象进行操作，可以将额外的对象作为参数传递给它。如果方法需要显示的引用调用他的对象，则可以使用this指针。由于this指针被设置为调用对象的地址，因此*this是该对象的别名。","tags":[{"name":"cpp","slug":"cpp","permalink":"http://wizzie.top/tags/cpp/"}]},{"title":"C++头文件、作用域、内存模型和名称空间","date":"2019-09-01T13:52:00.000Z","path":"2019/09/01/2019/190901_cpp_namespace/","text":"单独编译C++提供#include语法，因而可以将程序划分，大致可以分成三部分：头文件a.h：包含结构声明和使用这些结构的函数原型源代码文件a.cpp：包含与结构相关的函数的代码源代码文件b.cpp：包含调用与结构相关的函数的代码头文件内容和引用头文件常包含的内容：函数原型使用#define或者const定义的符号常量结构声明struct类声明class模板声明template内联函数inline头文件引用时，使用#include &quot;coordin.h&quot;，而不是#include &lt;coordin.h&gt;因为尖括号的文件名，C++编译器将在存储标准头文件的主机系统的文件系统中查找；而双引号的头文件，则编译器将首先查找当前的工作目录或源代码目录（或其他目录，取决于编译器）头文件管理在同一个文件中只能将同一个头文件包含一次。有时候会存在包含了另一个头文件的头文件。因而有一种方法基于预处理器编译指令#ifndef即if not defined可以忽略第一次包含之外的所有内容，但是这种方法不能防止编译器将文件包含两次。。12345//仅当以前没有使用预处理器编译指令#define定义名称COORDIN_H_时，才处理#inndef和#endif之间的语句#ifndef COORDIN_H_#define COORDIN_H_ //完成该名称的定义...#endif作用域scope作用域描述名称在文件的多大范围可见。C++变量的作用域有多种。局部变量只在定义他的代码块中可用。作用域为全局（也叫文件作用域）的变量在定义位置到文件结尾之间都可用。自动变量的作用域为局部静态变量的作用域是全局还是局部取决于它如何被定义在函数原型作用域中使用的名称只包含参数列表的括号内可用在类中声明的成员的作用域为整个类在名称空间中声明的变量的作用域是整个名称空间C++函数的作用域可以是整个类或者命名空间，但不能是局部的，不能只对自己可见，这样会导致不能被其他函数调用不同的C++存储方式是通过存储持续性（数据内存存储方式）、作用域和链接性来描述的。数据内存的存储方式（存储持续性）C++使用三种方案存储数据，见文章《C++内存分配方式和模板类vector,array》C++11新增了线程存储持续性线程存储持续性在多核处理器很常见，这些CPU可以同时处理多个执行任务（可以使用SDK的systrace工具抓取一份trace查看）。这让程序能够将计算放在可并行处理的不同线程中。如果变量是使用关键字thread_local声明的，则其生命周期和所属的线程一样长。自动存储持续性默认情况下，在函数中声明的函数参数和变量的存储持续性是自动，作用域是局部，没有链接性。当函数结束时，这些变量将小时（执行到代码块时，将为变量分配内存，但是其作用域的起点是其声明位置）如果在代码块中定义了变量，则该变量的存在时间和作用域将被限制在该代码块内。通常存储在栈stack中，先进后出。之所以被称为栈，是由于新数据被象征性的放在原有数据的上面（相邻的内存单元），当程序使用完后，将其从栈中删除（栈的默认长度取决于实现，编译器通常提供改变栈长度的选项）。程序使用两个指针跟踪栈，一个指向栈底（开始位置），一个指向栈顶（下一个可用内存单元）。当函数被调用时，其自动变量被加入栈中，栈顶指针指向变量后的下一个可用内存单元。函数结束时，栈顶指针被重置为函数被调用前的值，从而释放新变量使用的内存。有些自动变量存储在寄存器中，关键字register最初由C语言引入，C++11之前，它建议编译器使用CPU寄存器存储自动变量。这旨在提高访问变量的速度。register int count_fast;在C++11中，失去了这种提示作用，关键字register只是显式的指出变量是自动的。鉴于它只能用于原本就是自动的变量，使用他的唯一原因是指出这个变量的名称可能与外部变量相同，避免使用了该关键字的现有代码非法。静态持续变量C++未静态存储持续性变量提供三种链接性：外部链接性（可在其他文件中访问）内部链接性（只能在当前文件中访问）无链接性（只能在当前函数或者代码块中访问）123456789101112...int global = 1000; //外部链接，作用域是整个文件static int one_file = 50; //内部链接，作用域是整个文件int main()&#123; ...&#125;void fun1(int n) &#123; static int count = 0; //无链接 int ma = 0; //自动变量，两者区别在于静态无链接变量在函数没有被执行时，也会在内存中 ...&#125;存储描述持续性作用域链接性声明方法自动自动代码块无代码块中寄存器自动代码块无代码块中，使用关键字register静态，无链接性静态代码块无使用关键字’static’静态，外部链接性静态文件外部不再任何函数内静态，内部链接性静态文件内部不再任何函数内，使用关键字static所有静态持续变量的初始化特征：未被出的初始化的静态变量的所在位都被设置为0，这种变量被称为零初始化的零初始化和常量表达式初始化被统称为静态初始化，这意味着在编译器处理文件（翻译单元）时初始化变量。动态初始化意味着变量将在编译后初始化。12int x; //零初始化int y = 5; //y先被零初始化，然后编译器计算常量表达式，初始化成5静态持续性、外部链接性链接性为外部的变量通常简称为外部变量，存储持续性是静态，作用域是整个文件。在函数外部定义，因此对所有函数都是外部的。例如可以在main()前面或者头文件中定义他们。可以在文件中位于外部变量定义后面的任何函数中使用它，因此也被称为全局变量（相对于局部的自动变量）C++有“单定义规则”，每个变量只能有一次定义。因而C++提供两种变量声明，一种是定义声明，分配存储空间；另一种是引用声明，不给变量分配存储空间，引用已有的变量。引用声明使用关键字extern，则不进行初始化。123double up; //零初始化extern int blem;; //引用声明，不进行初始化（此处可以引用其他文件已经声明的外部变量）extern char gr = 'z'; //已经初始化了，所以导致分配存储空间静态持续性、内部链接性不同于外部变量，将static限定符用于作用域为整个文件的变量时，该变量的链接性是内部的。两者区别是 内部链接的变量只能在所属的文件中使用，外部变量具有外部链接性，可以在其他文件中使用。静态持续性、无链接性将static限定符用于在代码块中定义的变量，导致局部变量的存储持续性是静态的。这意味着虽然只能在该代码块使用，但是在该代码块不处于活动状态时仍然存在。因此在两次调用该函数时，静态局部变量的值将保持不变。此外如果初始化了静态局部变量，则程序只在启动时进行一次初始化，再次调用时不会初始化，即值保持上次的值限定符和说明符存储说明符auto(在C++11不再是说明符)registerstaticexternthread_localmutable同一个声明中不能使用多个说明符（除了thread_local可以和static或者extern结合使用）C++11之前auto指出变量是自动变量，但是在C++11中，auto用于自动类型推断register用于在声明中指示寄存器存储，在C++11中只是显式的指出变量是自动的static被用在作用域是整个文件的声明中时，表示内部链接性；被用于局部声明中，表示局部变量的存储持续性是静态的extern表明是引用声明，即声明引用在其他地方定义的变量thread_local指出变量的持续性和所属线程的持续性相同。thread_local变量之于线程，犹如常规静态变量之于整个程序。mutable的含义根据const来解释（查看下一小节）cv-限定符(const和volatile)constvolatileconst表示内存被初始化后，程序不能再对其进行修改volatile表明即使程序代码没有对内存单元进行修改，其值也可能发生变化。作用是为了改善编译器的优化能力。例如，如果编译器发现程序在几条语句中两次使用了某个变量的值，则编译器可能不是让程序查找这个值两次，而是将这个值缓存到既存区中。（这种优化假设变量的值在两次使用之间不发生变化）将变量声明为volatile，则编译器不会进行这种优化；否则将进行这种优化。可以使用mutable指出，即使结构（或者类）变量为const，其某个成员也可以被修改。123456789struct data &#123; char name[30]; mutable int accesses; ...&#125;;const data veep = &#123;\"peter\", 0, ...&#125;;+ strcpy(veep.name, \"nancy\"); //not allowed,因为const- veep.accesses++; //allowveep的const限定符禁止程序修改veep的成员，但access成员的mutable说明符可以使的access不受这种限制。名称空间声明区域是可以在其中进行声明的区域。例如函数外面声明全局变量，其声明区域为所在的文件；函数中声明变量，声明区域为所在代码块；潜在作用域：变量的潜在作用域从声明点开始，到其声明区域的结尾。因此潜在作用域比声明作用域小，这是由于变量必须定义后才能使用。关键字namespace通过定义一种新的声明区域来创建命名的空间，如此不会和另一个名称空间发生同名冲突。1234567891011namespace Javk &#123; double pail; int pal; ...&#125;namespace Jil &#123; double pail; int pal; ...&#125;作用域解析运算符::双冒号123Jil::pal = 3; //限定的名称int pal = 10; //未限定的名称Javk::pail = 23.4;using声明恶化using编译指令using声明使得特定的标识符可用，using编译指令使得整个命名空间可用。12345678namespace Jil &#123; ...&#125;int main() &#123; using Jil::pail; //using声明 double a;&#125;using编译指令由名称空间和关键字using namespace组成。12using namespace Jil;using namespace std;建议不要在头文件使用using编译指令，如果非要使用，应将其放在所有的预处理编译指令#include后面导入名称时，首选使用作用域解析运算符或者using声明的方法对于using声明，首选将其作用域设置为局部而不是全局","tags":[{"name":"cpp","slug":"cpp","permalink":"http://wizzie.top/tags/cpp/"}]},{"title":"Android JNI理解","date":"2019-08-29T15:41:06.000Z","path":"2019/08/29/2019/190829_android_JNI/","text":"概述JNI,即Java Native Interface，Java本地调用。通过JNI可以实现：Java程序函数可以调用Natvie语言（C/C++）写的函数Natvie程序函数可以调用Java层的函数MediaScanner示例使用Android Xref提供的 Android 9.0.0_r3的源码Java层的MediaScanner完成两件事：加载JNI库Java的native函数frameworks/base/media/java/android/media/MediaScanner.java12345678910111213141516public class MediaScanner implements AutoCloseable &#123; static &#123; System.loadLibrary(\"media_jni\"); //加载对应的JNI库，media_jni是库名，在实际加载动态库的时候会拓展成libmedia_jni.so native_init(); //调用函数 &#125; private final static String TAG = \"MediaScanner\";... private native void processDirectory(String path, MediaScannerClient client); private native boolean processFile(String path, String mimeType, MediaScannerClient client); private native void setLocale(String locale); public native byte[] extractAlbumArt(FileDescriptor fd); private static native final void native_init(); private native final void native_setup(); private native final void native_finalize();动态库是运行时加载的库。如果Java要调用native函数，必须通过一个位于JNI层的动态库实现。通常是在类的static语句中加载，调用System.loadLibrary方法就可以加载。函数名前有Java的关键字native的函数表示将由JNI层实现。因而Java层只需要两项工作：加载对应的JNI库，和声明由关键字native修饰的函数JNI层的MediaScannerJNI对应的文件是frameworks/base/media/jni/android_media_MediaScanner.cppframeworks/base/media/jni/android_media_MediaScanner.cpp123456789101112131415161718// This function gets a field ID, which in turn causes class initialization.// It is called from a static block in MediaScanner, which won't run until the// first time an instance of this class is used.static voidandroid_media_MediaScanner_native_init(JNIEnv *env)&#123; ALOGV(\"native_init\"); jclass clazz = env-&gt;FindClass(kClassMediaScanner); if (clazz == NULL) &#123; return; &#125; fields.context = env-&gt;GetFieldID(clazz, \"mNativeContext\", \"J\"); if (fields.context == NULL) &#123; return; &#125;&#125;...java层的native_init函数对应android_media_MediaScanner_native_init。通过文件路径来命名，观察两个文件的路径：frameworks/base/media/java/android/media/MediaScanner.javaframeworks/base/media/jni/android_media_MediaScanner.cpp注册JNI函数java层的MediaScanner.java函数native_init位于android.media包中，全路径名是：android/media/MediaScanner.java，对应JNI层函数的名字。JNI层将Java函数名称（包含包名）中的.转换成_，通过这种方式，native_init对应JNI的函数。JNI函数注册的意思是将java层的native函数和JNI层对应的实现函数关联起来。注册有两种方式：静态方法和动态注册静态注册根据函数名来找对应的JNI函数。（1） 编写Java代码，编译生成.class文件（2） 使用Java的工具命令javah -o output packagename.classname，生成一个output.h的JNI头文件，里面声明了对应的JNI函数，只要实现里面的函数即可。动态注册因为Java native函数和JNI函数是一一对应的，所以存在一种JNINativeMethod的结构记录这种一一对应的关系。例如frameworks/base/media/jni/android_media_MediaScanner.cpp文件中：1234567891011121314151617181920212223...static const JNINativeMethod gMethods[] = &#123; ...... &#123; \"native_setup\", \"()V\", (void *)android_media_MediaScanner_native_setup &#125;, &#123; \"native_finalize\", \"()V\", (void *)android_media_MediaScanner_native_finalize &#125;,&#125;;//注册上面的数组// This function only registers the native methods, and is called from// JNI_OnLoad in android_media_MediaPlayer.cppint register_android_media_MediaScanner(JNIEnv *env)&#123; return AndroidRuntime::registerNativeMethods(env, kClassMediaScanner, gMethods, NELEM(gMethods));&#125;当Java层通过System.loadLibrary加载完JNI动态库后，会查找该库中JNI_OnLoad函数，然后调用他，之后完成动态注册。12345678910111213141516171819202122232425262728293031323334jint JNI_OnLoad(JavaVM* vm, void* /* reserved */)&#123; JNIEnv* env = NULL; jint result = -1; if (vm-&gt;GetEnv((void**) &amp;env, JNI_VERSION_1_4) != JNI_OK) &#123; ALOGE(\"ERROR: GetEnv failed\\n\"); goto bail; &#125; assert(env != NULL);...... if (register_android_media_MediaRecorder(env) &lt; 0) &#123; ALOGE(\"ERROR: MediaRecorder native registration failed\\n\"); goto bail; &#125; if (register_android_media_MediaScanner(env) &lt; 0) &#123; //此处开始动态注册 ALOGE(\"ERROR: MediaScanner native registration failed\\n\"); goto bail; &#125; if (register_android_media_MediaMetadataRetriever(env) &lt; 0) &#123; ALOGE(\"ERROR: MediaMetadataRetriever native registration failed\\n\"); goto bail; &#125;...... /* success -- return valid version number */ result = JNI_VERSION_1_4;bail: return result;&#125;","tags":[{"name":"JNI","slug":"JNI","permalink":"http://wizzie.top/tags/JNI/"}]},{"title":"ubuntu输入法无法选择候选文字","date":"2019-08-29T14:28:00.000Z","path":"2019/08/29/2019/190829_linux_ibus/","text":"解决方法1234#删除配置文件rm -rf ~/.cache/ibus/libpinyinibus-daemon -drxibus-daemon -drx","tags":[{"name":"linux","slug":"linux","permalink":"http://wizzie.top/tags/linux/"}]},{"title":"C++双冒号、点号、箭头的区别","date":"2019-08-29T13:52:00.000Z","path":"2019/08/29/2019/190829_cpp_maohao/","text":"箭头-&gt;和点号.声明一个结构：123struct mystruct &#123; int age;&#125;;如果有个结构变量a，访问成员元素的方法：a.age = 1;如果采用指针方法访问，则必须用箭头访问元素，比如:12mystruct *ps;ps-&gt;age = 1;指针对象当定义类对象是指针对象的时候，需要用到-&gt;指向类中的成员；当定义一般对象的时候，使用:单冒号指向类中的成员。12345678910class A &#123; public: play();&#125;A *p;p-&gt;play(); //左边是结构指针A pr;pr.play(); //左边是结构变量双冒号::双冒号只用在类成员函数和类成员变量中。比如：1234567891011class CA &#123; public: int ca_var; int add(int a, int b);&#125;//函数实现int CA::add(int a, int b) &#123; int c = ::ca_var; //访问当前类实例中的变量 return a+b;&#125;","tags":[{"name":"cpp","slug":"cpp","permalink":"http://wizzie.top/tags/cpp/"}]},{"title":"Android中的makefile（Android.mk）","date":"2019-08-28T13:52:00.000Z","path":"2019/08/28/2019/190828_android_makefile/","text":"makefile是和make命令一起使用，在Android中，可以使用mm、mmm、mma进行编译。Makefile可以组织项目中各种库和代码之间的依赖，构建项目，和maven、gradle一样属于构建工具。常用于大型项目。基本语法变量定义=或者:=123OBJS &#x3D; programA.o&#x2F;&#x2F;或者OBJS :&#x3D; programA.o两者区别在于:=只能使用前面定义好的变量，=可以使用后面定义的变量。变量值追加+=12SRCS :&#x3D; programB.cSRCS +&#x3D; programC.cmakefile在Android中的运用namenoteLOCAL_PATH = $(call my-dir)调用my-dir函数，返回Android.mk文件所在的目录，放在第一行，地址是当前目录include file Makefile引入其他的makefile文件include $(CLEAR_VARS)编译模块时清空LOCAL_MODULE等参数LOCAL_MODULE模块名称LOCAL_SRC_FILES编译需要的源文件LOCAL_C_INCLUDES需要的头文件LOCAL_SHARED_LIBRARIES编译需要的动态库LOCAL_LDLIBS链接库引入aidl文件12345LOCAL_SRC_FILES :&#x3D; $(call all-laidl-files-under, src&#x2F;com&#x2F;srm&#x2F;aidl)或者直接如下，但是最后要加上 \\ 符号，并且符号之后要回车：LOCAL_SRC_FILES +&#x3D; $(call all-java-files-under, src) \\src&#x2F;com&#x2F;srm&#x2F;aidl&#x2F;test.aidl \\添加jar包（libs和mk同目录）：12345678LOCAL_STATIC_JAVA_LIBRARIES :&#x3D; testjar&#x2F;&#x2F;需要用CLEAR_VARS分割include $(CLEAR_VARS)LOCAL_PREBUILT_STATIC_JAVA_LIBRARIES :&#x3D; testjar:libs&#x2F;testjar.jar&#x2F;&#x2F;需要添加include $(BUILD_MULTI_PREBUILT)","tags":[{"name":"makefile","slug":"makefile","permalink":"http://wizzie.top/tags/makefile/"}]},{"title":"C++内联函数、引用变量、函数重载、函数模板","date":"2019-08-26T14:23:05.000Z","path":"2019/08/26/2019/190826_cpp_inline/","text":"内联函数常规函数调用使程序跳到另一个地址（函数的地址），并在函数结束后返回。来回跳跃并记录跳跃位置意味着一定的开销。内联函数使得编译器将相应的函数代码替换函数调用。程序无需跳到另一个位置处执行代码，再调回来。因而，内联函数运行速度比常规函数快，但是代价是需要占用更多的内存。如果程序在10个不同的地方调用调用同一个内联函数，则该程序将包含该函数代码的10个副本。使用内联函数：在函数声明前加上关键字inline在函数定义前加上关键字inline通常的做法是省略原型，将整个定义（即函数头和所有函数代码）放在本应提供原型的地方。示例代码：inline.cpp1234567891011121314#include&lt;iostream&gt;using namespace std;inline double square(double x) &#123;return x * x;&#125;int main() &#123; double a, b; a = square(5.0); b = square(4.5 + 7.5); cout &lt;&lt; \"a = \" &lt;&lt; a &lt;&lt; \", b = \" &lt;&lt; b &lt;&lt;endl; return 0;&#125;执行结果： a = 25, b = 144NOTE：C语言使用预处理语句**#define提供宏（内联代码的原始实现），比如：#define SQUARE(X) X*X这是通过文本替换来实现的。引用变量标识符&amp;引用变量的主要用途是用作函数的形参。通过将引用变量用作参数，函数将使用原始数据，而不是副本。这样除了指针以外，引用也为函数处理大型结构提供了方便的途径。创建引用变量12int rats;int &amp; rodents = rats; //此处的&amp;不是地址运算符，而是类型标识符的一部分。int&amp;是指向int的引用。上述的引用声明允许将rats和rodents互换，他们指向相同的值和内存单元。示例代码：firstref.cpp12345678910111213141516#include&lt;iostream&gt;using namespace std;int main()&#123; int rats = 101; int &amp; rodents = rats; //必须在声明引用时初始化，不可以分成两句 //上一句等价于 int * const pr = &amp;rats; cout &lt;&lt; \"rats = \" &lt;&lt; rats &lt;&lt; \", rodents = \" &lt;&lt; rodents &lt;&lt;endl; rodents++; cout &lt;&lt; \"After rodents++, rats = \" &lt;&lt; rats &lt;&lt; \", rodents = \" &lt;&lt; rodents &lt;&lt; endl; cout &lt;&lt; \"Address &amp;rats = \" &lt;&lt; &amp;rats &lt;&lt; \", &amp;rodents = \" &lt;&lt; &amp;rodents &lt;&lt;endl; return 0;&#125;执行结果：123rats = 101, rodents = 101After rodents++, rats = 102, rodents = 102Address &amp;rats = 0x7ffe8c156f1c, &amp;rodents = 0x7ffe8c156f1c //相同的地址和值将引用用作函数参数12345678910111213141516171819202122&#x2F;&#x2F;按值传递void lazy(int x);int main() &#123; int times &#x3D; 20; lazy(times); return 0;&#125;void lazy(int x) &#123; ...&#125;&#x2F;&#x2F;按引用传递void work(int &amp;x);int main() &#123; int times &#x3D; 20; work(times);&#125;void work(int &amp;x) &#123; ...&#125;如果让函数使用传递给她的信息，而不对信息进行修改，同时又箱使用引用，则应使用常量引用，即使用const。double refcube(const double &amp;ra);将引用参数声明为常量数据的引用的理由三个：使用const可以避免无意中修改数据的编程错误使用const使函数能够处理const和非const实参，否则将只能接受非cosnt数据使用const引用使函数能够正确生成并使用临时变量C++11新增了另一种引用 – 右值引用，这种引用可以指向右值，是使用&amp;&amp;声明的。目的用来实现移动语义。而’&amp;’引用是左值引用。123double &amp;&amp; rref = std::sqrt(36.00); //6double j = 15.0;douvle &amp;&amp; jref = 2.0 * j + 18.5; //48.5合适使用引用参数使用引用参数的主要原因有两个：能够修改调用函数中的数据对象通过传递引用而不是整个数据对象，提高程序运行速度对于使用传递的值而不做修改的函数：如果数据对象很小，如内置数据类型或小型数据。则按值传递如果数据对象是数组，则使用指针，并将指针声明为指向const的指针如果数据对象是较大的结构，则使用const指针或const引用，提高效率，节省复制结构所需的时间和空间如果数据对象是类对象，则使用const引用，传递类对象参数的标准方式是按引用传递对于修改函数中数据的函数：如果数据对象是内置数据类型，则使用指针。例如调用fixit(&amp;x)这样的函数，则很明显要修改x如果数据对象是数组，则只能使用指针如果数据对象是结构，则使用引用或者指针如果数据对象是类对象，则使用引用默认参数默认参数指的是当函数调用中省略了实参时自动调用的一个值。例如将void wow(int n)设置成n有默认值是1，则函数调用wow()就等价于wow(1)通过函数原型设置默认值：char * left(const char *str, int n = 1);函数重载同名的函数使用不同的参数列表。因而关键是参数列表，也称作函数特征标。如果两个函数的参数数目和类型相同，同时参数的排列顺序相同，则他们的特征标相同。返回类型可以不同，但是特征标也必须不同1234567891011void print(const char *str, int width);void print(double d, int width);void print(long l, int width);void print(int i, int width);void print(const char *str);//返回类型不同long gronk(int n, float m);double gronk(int n, float); //互斥，不允许重载double gronk(float n, float m); //可以重载因而在使用print()函数时，编译器根据采取的用法使用有相应特征标的函数原型。123print(1999.0, 10);print(1999L, 15);print(\"pen\", 12);当函数基本上执行相同的人物，但使用不同形式的数据时，才应采用函数重载。名称修饰（或名称矫正）根据函数原型中指定的形参类型对每个函数名进行加密。long MyFun(int, float);编译器将其转化为内部表示来描述接口：?MyFun@@YAXH函数模板函数模板是通用的函数描述，使用泛型来定义函数，其中泛型可以用具体的类型（如int或double）替换。通过将类型作为参数传递给模板，可以使编译器生成该类型的函数由于模板允许以泛型的方式编写程序，因此也称作通用编程由于类型是用参数表示的，因此模板特性有时也称作参数化类型函数模板允许以任意类型的方式来定义函数。例如，可以建立一个交换模板：123456789template &lt;typename AnyType&gt;//template &lt;class T&gt;void swap(AnyType &amp;a, AnyType &amp;b) &#123; AnyType temp; temp = a; a = b; b = temp;&#125;第一行建立一个模板，将类型命名为AnyType，关键字template和typename是必需的，除非使用另一个关键字class代替typename(这两个关键字等价的)。另外，必须使用尖括号。类型名可以任意选择（此处是AnyType），常用T如果需要多个将同一个算法用于不同类型的函数，请使用函数模板。如果不考虑向后兼容的问题，并愿意键入较长的单词，则声明类型参数时，应使用关键字typename而不使用class。Example:funtemp.cpp12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;using namespace std;template &lt;typename T&gt; //or class Tvoid Swap(T &amp;a, T &amp;b); //函数原型、函数模板使用、引用变量//函数模板定义template &lt;typename T&gt; //or class Tvoid Swap(T &amp;a, T &amp;b) &#123; T temp; temp = a; a = b; b = temp;&#125;int main()&#123; int i = 10; int j = 20; cout &lt;&lt; \"Before swap, i = \" &lt;&lt; i &lt;&lt; \",j = \" &lt;&lt; j &lt;&lt;endl; Swap(i, j); cout &lt;&lt; \"After swap, i = \" &lt;&lt; i &lt;&lt; \",j = \" &lt;&lt; j &lt;&lt;endl; double x = 24.45; double y = 45.2; cout &lt;&lt; \"Before swap, x = \" &lt;&lt; x &lt;&lt; \",y = \" &lt;&lt; y &lt;&lt;endl; Swap(x, y); cout &lt;&lt; \"After swap, x = \" &lt;&lt; x &lt;&lt; \",y = \" &lt;&lt; y &lt;&lt;endl; return 0;&#125;Result:1234Before swap, i = 10,j = 20 //当接收两个int参数，则会用int代替TAfter swap, i = 20,j = 10Before swap, x = 24.45,y = 45.2After swap, x = 45.2,y = 24.45Note:函数模板不能缩短可执行程序，最终仍将由独立的函数定义，最终的代码不包含任何函数模板，而只包含了为程序生成的实际函数。使用函数模板的好处是使得多个函数定义更简单可靠。重载的函数模板可以像重载常规函数定义一样重载函数模板定义。保证被重载的函数模板特征标必须不同12345678910111213141516template &lt;typename T&gt;void Swap(T &amp;a, T &amp;b);template &lt;typename T&gt;void Swap(T *a, T *b, int n);//实现第二个template &lt;typename T&gt;void Swap(T a[], T b[], int n) &#123; T temp; for (int i = 0; i &lt; n; i++) &#123; temp = a[i]; a[i] = b[i]; b[i] = temp; &#125;&#125;局限性模板函数可能无法处理某些类型。例如数组、指针、结构的某些运算。一种解决方案是C++允许你重载运算符+，以便能够将其用于特定的结构或类；另一种是为特定类型提供具体化的模板定义。显示具体化C++98标准选择了以下的方法实现第三代具体化：对于给定的函数名，可以有非模板函数、模板函数、显示具体化模板函数、以及他们的重载版本显示具体化的原型和定义应该以template &lt;&gt;开头，并通过名称指出类型优先级： 非模板函数 &gt; 显示具体化模板函数 &gt; 常规模板函数123456789101112131415struct job &#123; char name[40]; double salary; int floor;&#125;;//非模板函数(首先调用)void Swap(job &amp;, job &amp;);//显示具体化模板函数（其次调用）template &lt;&gt; void Swap&lt;job&gt;(job &amp; ,job &amp;);//常规模板函数template &lt;typename T&gt;void Swap(T &amp;, T &amp;);Swap&lt;job&gt;的&lt;job&gt;是可选的，因为函数的参数类型声明，这是job的一个具体化。因此，该原型也可以写作：template &lt;&gt; void Swap(job &amp;, job &amp;);Example:twoswap.cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;iostream&gt;using namespace std;template &lt;typename T&gt;void Swap(T &amp;a, T &amp;b);struct job&#123; char name[40]; double salary; int floor;&#125;;template &lt;&gt; void Swap&lt;job&gt;(job &amp;j1, job &amp;j2);void Show(job &amp;j);template &lt;typename T&gt;void Swap(T &amp;a, T &amp;b) &#123; T temp; temp = a; a = b; b = temp;&#125;template &lt;&gt; void Swap&lt;job&gt;(job &amp;j1, job &amp;j2) &#123; double t1; int t2; t1 = j1.salary; j1.salary = j2.salary; j2.salary = t1; t2 = j1.floor; j1.floor = j2.floor; j2.floor = t2; &#125;void Show(job &amp;j) &#123; cout &lt;&lt; j.name &lt;&lt; \" : $\" &lt;&lt; j.salary &lt;&lt; \" on floor \" &lt;&lt; j.floor &lt;&lt;endl;&#125;int main()&#123; cout.precision(2); cout.setf(ios::fixed, ios::floatfield); int i = 10, j = 20; cout &lt;&lt; \"Before swap, i = \" &lt;&lt; i &lt;&lt; \",j = \" &lt;&lt; j &lt;&lt;endl; Swap(i, j); cout &lt;&lt; \"After swap, i = \" &lt;&lt; i &lt;&lt; \",j = \" &lt;&lt; j &lt;&lt;endl; job sue = &#123;\"Susan\", 7300.60, 7&#125;; job sidney = &#123;\"Sidney Taffee\", 78060.72, 9&#125;; cout &lt;&lt; \"Before job swap,\\n\"; Show(sue); Show(sidney); Swap(sue, sidney); cout &lt;&lt; \"After job swap,\\n\"; Show(sue); Show(sidney); return 0;&#125;Results:12345678Before swap, i = 10,j = 20After swap, i = 20,j = 10Before job swap,Susan : $7300.60 on floor 7Sidney Taffee : $78060.72 on floor 9After job swap,Susan : $78060.72 on floor 9Sidney Taffee : $7300.60 on floor 7关键字decltype(c++11)123456template &lt;class T1, class T2&gt;void ft(T1 x, T2 y) &#123; ... ?type? xpy = x + y; ...&#125;此处的xpy不知道如何确定类型，在C++11中提供关键字decltype，使用方法：12345678910111213141516171819int x;decltype(x) y;decltype(x+y) xpy;xpy = x + y;//或者合并成一句decltype(x+y) xpy = x + y;//举例decltype(auto) a;//完善上述的模板函数template &lt;class T1, class T2&gt;void ft(T1 x, T2 y) &#123; ... decltype(x+y) xpy = x + y; ...&#125;C++11后置返回类型声明语法1234template&lt;class T1, class T2&gt;?type? gt(T1 x, T2 y) &#123; return x + y;&#125;此处无法确定返回的类型，因为未声明参数x和y，所以他们不再作用域呢，无法使用decltype关键字（必须声明参数后使用）。C++11新增了一种语法：double h(int x, float y);使用新增的语法后可以这样编写：auto h(int x, float y) -&gt; double;这样将返回类型已到了参数声明之后，-&gt;double被称为后置返回类型。因而使用这种方法声明模板函数：1234template&lt;class T1, class T2&gt;auto gt(T1 x, T2 y) -&gt; decltype(x+y) &#123; return x + y;&#125;","tags":[{"name":"cpp","slug":"cpp","permalink":"http://wizzie.top/tags/cpp/"}]},{"title":"C++函数模块（函数指针、递归）","date":"2019-08-21T14:23:05.000Z","path":"2019/08/21/2019/190821_cpp_function/","text":"本章节主要是围绕函数为圆心，涉及到字符串、指针、C++11特性auto、typedef。由于接触android源码、opengl，需将C++学习一遍，之前只是用过java、c、c#这些。涉及到android源码，例如frameworks/native的surfaceflinger,gui,ui, 以及vender,hardware都是需要仔细的阅读C++代码才能够理解。再如graphics的测量、绘制渲染、硬件加速、合成显示，私以为学习一些图形学是有必要的。人生在勤，不索何获。函数function是否有返回值（void）main()函数函数原型，diybke vikyne = cube(side);，函数原型是一条语句，必须以份好结束。一般可以放在头文件中（.h）。函数原型可以确保以下几点：编译器正确处理函数返回值编译器检查使用的参数数目是否正确编译器检查使用的参数类型是否正确传递给函数的参数类型和数量（形参）可以有多个参数，通过逗号分隔参数的变量名可以和函数原型的不同，而且原型的变量名可以省略void n_chars(char, int);示例代码：twoarg.cpp1234567891011121314151617181920212223242526#include&lt;iostream&gt;using namespace std;void n_chars(char, int); //函数原型int main()&#123; int times; char ch; cout &lt;&lt; \"Enter a character: \"; cin &gt;&gt; ch; while (ch != 'q') &#123; cout &lt;&lt; \"Enter an integer: \"; cin &gt;&gt; times; n_chars(ch, times); //调用函数 cout &lt;&lt; \"\\nEnter another character or press the 'q' to quit: \"; cin &gt;&gt; ch; &#125; cout &lt;&lt; \"The value of times is \" &lt;&lt; times &lt;&lt;endl; return 0;&#125;void n_chars(char c, int n) &#123; while (n-- &gt; 0) cout &lt;&lt; c;&#125;执行结果：12345678Enter a character: aEnter an integer: 3aaaEnter another character or press the 'q' to quit: bEnter an integer: 5bbbbbEnter another character or press the 'q' to quit: qThe value of times is 5函数使用指针处理数组C++将数组名解释为其第一个元素的地址:cookies == &amp;cookies[0]数组声明使用数组名来标记存储位置对数组名使用sizeof将得到数组的长度（以字节为单位）将地址运算符&amp;用于数组名，将得到整个数组的地址在C++中，只有用于函数头或者函数原型中，int *arr才等价于int arr[]例如函数原型： int sum_arr(int *arr, int n)指针和const让指针指向一个常量对象，这样可以防止使用该指针修改所指向的值将指针本身声明为常量，可以防止改变指针指向的位置12int age = 39;const int *pt = &amp;age; //并不意味着指向的值是常量，而是对于pt而言，这个值是常量。即可以通过age改变age的值，但是不能通过pt指针改变它建议将指针参数声明为指向常量数据的指针有两条理由：可以避免由于无意间修改数据而导致的编程错误使用const使得函数能够处理const和非const的实参，否则将只能接收非cosnt数据1234int sloth = 3;const int * ps = &amp;sloth; //不允许ps来修改sloth的值，但是允许将ps指向另一个位置，即ps不是const，*ps是constint * const finger = &amp;sloth; //允许*finger来修改sloth的值，但是finger只能指向sloth，即finger是const，但是*finger不是constconst int * const strick = &amp;sloth; //strick和*strick都是const函数和字符串C-风格字符串的表示方式有三种：char数组用引号括起的字符串常量（也称作字符串字面值）被设置为字符串的地址的char指针12345char ghost[15] = \"galloping\";char * str = \"galumphing\";int n1 = strlen(ghost); //ghost是&amp;ghost[0]int n2 = strlen(str); //指向charint n3 = strelan(\"gambolling\"); //字符串string地址示例代码：strgfun.cpp12345678910111213141516171819202122232425#include&lt;iostream&gt;using namespace std;unsigned int c_in_str(const char * str, char ch); //只针对非负数int main() &#123; char mmm[15] = \"minimum\"; char *wail = \"ululate\"; unsigned int ms = c_in_str(mmm, 'm'); unsigned int us = c_in_str(wail, 'u'); cout &lt;&lt; ms &lt;&lt; \" m characters in \" &lt;&lt; mmm &lt;&lt;endl; cout &lt;&lt; us &lt;&lt; \" u characters in \" &lt;&lt; wail &lt;&lt;endl; return 0;&#125;unsigned int c_in_str(const char * str, char ch) &#123; unsigned int count = 0; while (*str) &#123; if (*str == ch) count++; str++; &#125; return count;&#125;执行结果：123 m characters in minimum2 u characters in ululate返回字符串的函数函数无法返回一个字符串，但是可以返回字符串的地址，并且效率更高示例代码：strgback.cpp1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;using namespace std;char * buildstr(char c, int n);int main() &#123; int times; char ch; cout &lt;&lt; \"Enter a character: \"; cin &gt;&gt; ch; cout &lt;&lt; \"Enter an integer: \"; cin &gt;&gt; times; char *ps = buildstr(ch, times); cout &lt;&lt; \"Result is \" &lt;&lt; ps &lt;&lt;endl; delete []ps; return 0;&#125;char* buildstr(char c, int n) &#123; char * pstr = new char[n+1]; pstr[n] = '\\0'; while (n-- &gt; 0) pstr[n] = c; return pstr;&#125;执行结果：123Enter a character: sEnter an integer: 10Result is ssssssssss函数和结构最直接的方式是像处理基本类型那样处理结构，将结构作为函数传递，并在需要时将结构作返回值使用。示例代码：travel.cpp1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;using namespace std;struct travel_time &#123; int hours; int mins;&#125;;const int Mins_per_hr = 60;travel_time sum(travel_time tl, travel_time t2);void show_time(travel_time t);travel_time sum(travel_time t1, travel_time t2) &#123; travel_time total; total.mins = (t1.mins + t2.mins) % Mins_per_hr; total.hours = t1.hours + t2.hours + (t1.mins + t2.mins) / Mins_per_hr; return total;&#125;void show_time(travel_time t) &#123; cout &lt;&lt; t.hours &lt;&lt; \" hours, \" &lt;&lt; t.mins &lt;&lt; \" minutes\\n\"; &#125;int main() &#123; travel_time day1 = &#123;5, 45&#125;; travel_time day2 = &#123;4, 55&#125;; travel_time trip= sum(day1, day2); show_time(trip); return 0;&#125;执行结果10 hours, 40 minutes函数和string对象代码示例：topfive.cpp123456789101112131415161718192021222324252627#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;const int SIZE = 5;void display(const string sa[], int n);void display(const string sa[], int n) &#123; for (int i =0; i &lt; n; i++) cout &lt;&lt; i+1 &lt;&lt; \" : \" &lt;&lt; sa[i] &lt;&lt; endl;&#125;int main()&#123; string list[SIZE]; cout &lt;&lt; \"Enter your \" &lt;&lt; SIZE &lt;&lt; \" favorite astronomical sights: \\n\"; for (int i =0; i &lt; SIZE;i++) &#123; cout &lt;&lt; i+1 &lt;&lt; \" : \"; getline(cin, list[i]); &#125; cout &lt;&lt; \"Your list : \\n\"; display(list, SIZE); return 0;&#125;执行结果：123456789101112Enter your 5 favorite astronomical sights: 1 : Peter2 : Nancy3 : Good4 : Wizzie5 : JackYour list :1 : Peter2 : Nancy3 : Good4 : Wizzie5 : Jack函数和array对象要使用数组模板类array，需要包含头文件array，#include&lt;array&gt;，而arrat位于命名空间std中。array不仅可以存储基本数据类型，还可以存储类对象。12void show(std::array&lt;double, 4&gt; da);void fill(std::array&lt;double, 4&gt; *pa);示例代码：arrobj.cpp12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;#include&lt;array&gt;#include&lt;string&gt;using namespace std;const int Seasons = 4;const array&lt;string, Seasons&gt; snames = &#123;\"spring\", \"summer\", \"fall\", \"winter\"&#125;;void fill(array&lt;double, Seasons&gt; *pa);void show(array&lt;double, Seasons&gt; da);void fill(array&lt;double, Seasons&gt; *pa) &#123; for (int i = 0; i &lt; Seasons; i++) &#123; cout &lt;&lt; \"Enter \" &lt;&lt; snames[i] &lt;&lt; \" expenses: \"; cin &gt;&gt; (*pa)[i]; &#125;&#125;void show(array&lt;double, Seasons&gt; da) &#123; double total = 0.0; cout &lt;&lt; \"\\nExpenses\\n\"; for (int i =0; i&lt;Seasons; i++) &#123; cout &lt;&lt; snames[i] &lt;&lt; \" : $\" &lt;&lt; da[i] &lt;&lt; endl; total += da[i]; &#125; cout &lt;&lt; \"Total Expenses : $\" &lt;&lt; total &lt;&lt;endl;&#125;int main() &#123; array&lt;double, Seasons&gt; expenses; fill(&amp;expenses); show(expenses); return 0;&#125;执行结果：因为array模板类是C++11新增，所以编译命令： g++-5 arrobj.cpp -std=c++111234567891011Enter spring expenses: 212Enter summer expenses: 256Enter fall expenses: 208Enter winter expenses: 244Expensesspring : $212summer : $256fall : $208winter : $244Total Expenses : $920递归C++函数可以调用自己，和C不同的是，不允许main()调用自己123456void resurs(argumentlist) &#123; statements1 if (test) recurs(arguments) statements2&#125;示例代码：头文件：recur.h1void countdown(int n);CPP文件：recur.cpp1234567891011121314151617#include&lt;iostream&gt;#include \"recur.h\"using namespace std;//void countdown(int n);int main() &#123; countdown(10); return 0;&#125;void countdown(int n) &#123; cout &lt;&lt; \"Counting down ...\" &lt;&lt; n &lt;&lt;endl; if (n &gt; 0) countdown(n-1); cout &lt;&lt; n &lt;&lt; \" : Kaboom!\\n\";&#125;执行结果：12345678910111213141516171819202122Counting down ...10Counting down ...9Counting down ...8Counting down ...7Counting down ...6Counting down ...5Counting down ...4Counting down ...3Counting down ...2Counting down ...1Counting down ...00 : Kaboom!1 : Kaboom!2 : Kaboom!3 : Kaboom!4 : Kaboom!5 : Kaboom!6 : Kaboom!7 : Kaboom!8 : Kaboom!9 : Kaboom!10 : Kaboom!函数指针函数也存在地址，函数的地址是存储其机器语言代码的内存的开始地址。例如，可以编写将另一个函数的地址作为参数的函数，这样第一个函数将能够找到第二个函数并运行它。释义函数指针必要工作：获取函数的地址只需使用函数名（后面不用跟参数）。比如think()函数的地址是think。要将函数作为参数进行传递，必须传递函数名。一定要区分传递的是函数的地址还是函数的返回值12process(think); //传递地址thought(think()); //传递返回值声明函数指针声明指向某种数据类型的指针时，必须指定指针指向的类型。同样，声明指向函数的指针时，必须指定指针指向的函数类型。即声明应该像函数原型那样指出有关函数的信息。通常要声明指向特定类型的函数的指针，可以首先编写如下的函数原型，然后用(*pf)替换函数名。如此，pf就是这个函数的指针。1234567double pam(int); //函数原型double (*pf)(int); //如果(*pf)是函数，pf就是函数指针double *pf(int); //返回double指针pf = pam; //pf指向pam函数，但是要注意参数类型必须相同使用指针来调用函数123456789doubld pam(int);double (*pf)(int);pt = pam; //pf指向pam()函数double x = pam(4);double y = (*pf)(5); //（1） 等价，调用pam(5)double y = pf(5); //（2） 也可以调用函数指针指向的pam函数，但是没有第一种易懂代码示例：fun_ptr.cpp12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;double betsy(int);double pam(int);void estimate(int lines, double (*pf)(int));using namespace std;double betsy(int lns) &#123; return 0.05 * lns;&#125;double pam(int lns) &#123; return 0.03 * lns + 0.0004 * lns * lns;&#125;void estimate(int lines, double (*pf)(int)) &#123; //函数指针 cout &lt;&lt; lines &lt;&lt; \" lines will take\"; cout &lt;&lt; (*pf)(lines) &lt;&lt; \" hours\\n\";&#125;int main() &#123; int code; cout &lt;&lt; \"How many lines of code do you need?\"&lt;&lt;endl; cin &gt;&gt; code; cout &lt;&lt; \"Here is Betsy's estimate:\\n\"; estimate(code, betsy); //入参函数名 cout &lt;&lt; \"Here is Pam's estimage:\\n\"; estimate(code, pam); return 0;&#125;执行结果：123456How many lines of code do you need?6Here is Betsy's estimate:6 lines will take0.3 hoursHere is Pam's estimage:6 lines will take0.1944 hours案例12345678910const double * f0(const double ar[], int);const double * f1(const double [], int);const double * f2(const double * , int); //这三种表达方式相同//声明一个指针指向这三个函数之一，假设指针名是pa，则只需将目标函数原型中的函数名代替为(*pa)const double * (*pa)(const double *, int);//可以在声明的同时初始化const double * (*pa)(const double *, int) = f1;//简洁的使用autoauto p2 = f2; //也是函数指针示例代码：arfupt.cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;using namespace std;const double * f1 (const double ar[], int n);const double * f2 (const double [], int);const double * f3 (const double *, int);const double * f1(const double * ar, int n) &#123; return ar;&#125;const double * f2(const double ar[], int n) &#123; return ar+1;&#125;const double * f3(const double ar[], int n) &#123; return ar+2;&#125;int main() &#123; double av[3] = &#123;1.2, 2.3, 3.4&#125;; const double *(*p1)(const double *, int ) = f1; auto p2 = f2; cout &lt;&lt; \"Using pointers to functions:\\n\"; cout &lt;&lt; \"Address Vaule\\n\"; cout &lt;&lt; (*p1)(av, 3) &lt;&lt; \" : \" &lt;&lt; *(*p1)(av, 3) &lt;&lt;endl; cout &lt;&lt; p2(av, 3) &lt;&lt; \" : \" &lt;&lt; *p2(av, 3) &lt;&lt;endl; const double *(*pa[3])(const double *, int) = &#123;f1, f2, f3&#125;; auto pb = pa; cout &lt;&lt; \"\\nUsing pointers to functions:\\n\"; cout &lt;&lt; \"Address Value\\n\"; for (int i = 0; i&lt;3; i++) cout &lt;&lt; pa[i](av, 3) &lt;&lt; \" : \" &lt;&lt; *pa[i](av,3) &lt;&lt;endl; cout &lt;&lt; \"\\nUsing pointers to functions:\\n\"; cout &lt;&lt; \"Address Value\\n\"; for (int i = 0; i&lt;3; i++) cout &lt;&lt; pb[i](av, 3) &lt;&lt; \" : \" &lt;&lt; *pb[i](av,3) &lt;&lt;endl; auto pc = &amp;pa; cout &lt;&lt; (*pc)[0](av,3) &lt;&lt; \" : \" &lt;&lt; *(*pc)[0](av,3) &lt;&lt;endl; return 0;&#125;执行结果：1234567891011121314151617Using pointers to functions:Address Vaule0x7ffef6915240 : 1.20x7ffef6915248 : 2.3Using pointers to functions:Address Value0x7ffef6915240 : 1.20x7ffef6915248 : 2.30x7ffef6915250 : 3.4Using pointers to functions:Address Value0x7ffef6915240 : 1.20x7ffef6915248 : 2.30x7ffef6915250 : 3.40x7ffef6915240 : 1.2typedef关键字简化除了auto，C++11提供了typedef穿件类型别名，typedef double real;12345typedef const double *(*p_fun)(const douvle *, int); //p_fun现在是一个类型名称（别名）p_fun p1 = f1; //p1指向f1()函数p_fun pa[3] = &#123;f1, f2 ,f3&#125;; //pa是一个指向三个函数的函数指针p_fun (*pd)[3] = &amp;pa; //pd指向一个包含三个函数指针的数组小结函数必须提供定义和原型，并且调用该函数函数原型描述了函数的接口：入参的数目和类型、返回类型默认情况，C++函数按值传递参数，意味着函数定义中的形参是新的变量，被初始化为函数调用所提供的值。因此通过使用拷贝保护了原始数据的完整性C++将数组名参数视为数组第一个元素的地址，typename arr[]和typename * arr是等价的C++提供三种表示C风格字符串的方法：字符数组、字符串常量、字符串指针，类型都是char*C++提供string类，用于表示字符串，使用size()用于判断存储的字符串的长度处理结构的方式和基本类型完全相同，可以按值传递结构，并将其用作函数返回类型。如果结构非常大，则传递结构指针，同时函数能够使用原始数据支持递归函数名和函数地址的作用相同。通过函数指针作为参数，可以传递要调用的函数的名称","tags":[{"name":"cpp","slug":"cpp","permalink":"http://wizzie.top/tags/cpp/"}]},{"title":"ubuntu搭建opengl环境","date":"2019-08-20T14:23:05.000Z","path":"2019/08/20/2019/190820_opengl_setup/","text":"安装1234sudo apt-get install build-essentialsudo apt-get install libgl1-mesa-devsudo apt-get install libglu1-mesa-devsudo apt-get install freeglut3-dev安装完成后，库文件：123456789wizzie@wizzie:&#x2F;usr&#x2F;lib&#x2F;x86_64-linux-gnu|⇒ ls -tl lib[gG][lL]*.solrwxrwxrwx 1 root root 22 5月 10 20:17 libGLdispatch.so -&gt; libGLdispatch.so.0.0.0lrwxrwxrwx 1 root root 15 5月 10 20:17 libGLX.so -&gt; libGLX.so.0.0.0lrwxrwxrwx 1 root root 17 2月 14 2019 libGLESv1_CM.so -&gt; libGLESv1_CM.so.1lrwxrwxrwx 1 root root 14 2月 14 2019 libGLESv2.so -&gt; libGLESv2.so.2lrwxrwxrwx 1 root root 10 2月 14 2019 libGL.so -&gt; libGL.so.1lrwxrwxrwx 1 root root 16 8月 24 2016 libglut.so -&gt; libglut.so.3.9.0lrwxrwxrwx 1 root root 15 5月 22 2016 libGLU.so -&gt; libGLU.so.1.3.1测试测试C代码test.c12345678910111213141516171819202122232425262728293031323334353637#include &lt;GL/glut.h&gt;void init(void)&#123; glClearColor(0.0, 0.0, 0.0, 0.0); glMatrixMode(GL_PROJECTION); glOrtho(-5, 5, -5, 5, 5, 15); glMatrixMode(GL_MODELVIEW); gluLookAt(0, 0, 10, 0, 0, 0, 0, 1, 0); return;&#125;void display(void)&#123; glClear(GL_COLOR_BUFFER_BIT); glColor3f(1.0, 0, 0); glutWireTeapot(3); glFlush(); return;&#125;int main(int argc, char *argv[])&#123; glutInit(&amp;argc, argv); glutInitDisplayMode(GLUT_RGB | GLUT_SINGLE); glutInitWindowPosition(0, 0); glutInitWindowSize(300, 300); glutCreateWindow(\"OpenGL 3D View\"); init(); glutDisplayFunc(display); glutMainLoop(); return 0;&#125;编译12$ gcc -o test test.c -lGL -lGLU -lglut$ .&#x2F;test编译结束后执行，会出现一个红色的小茶壶，表示配置完成。测试C++代码test1.cpp123456789101112131415161718192021// File Name: example.cpp #include &lt;GL/glut.h&gt; void draw()&#123; glClearColor(1, 0, 0, 1); glClear(GL_COLOR_BUFFER_BIT); glFlush();&#125; int main(int argc, char** argv)&#123; glutInit(&amp;argc, argv); glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB); glutInitWindowPosition(100, 100); glutInitWindowSize(300, 300); glutCreateWindow(\"My First OpenGL Program\"); glutDisplayFunc(draw); glutMainLoop(); return 0;&#125;编译12gcc -o test1 test1.cpp -lGL -lGLU -lglut.&#x2F;test1编译结束后执行，会出现一个红色的窗口，表示配置完成。","tags":[{"name":"opengl","slug":"opengl","permalink":"http://wizzie.top/tags/opengl/"}]},{"title":"C++分支语句、逻辑表达式、字符函数库、switch、文本I/O","date":"2019-08-15T14:23:05.000Z","path":"2019/08/15/2019/190815_cpp_ifelse/","text":"if语句两种格式： if和if elseif.cpp12345678910111213141516171819#include&lt;iostream&gt;using namespace std;int main() &#123; char ch; int spaces = 0; int total = 0; cin.get(ch); while (ch != '.') &#123; if (ch == ' ') ++spaces; ++total; cin.get(ch); &#125; cout &lt;&lt; spaces &lt;&lt; \" spaces, total is \" &lt;&lt; total &lt;&lt;endl; return 0;&#125;执行结果：123456789101112abc //space //space.2 spaces, total is 10 //总数为10是因为包含换行符或者如下结果：dwdadw .3 spaces, total is 9嵌套ifelse123456789if (ch == 'A') a++;else if (ch =='B') b++; else if (ch == 'C') c++; else x++;逻辑表达式三种：逻辑or||， 逻辑and&amp;&amp;，逻辑NOT!例如：12345675 &gt; 3 || 5 &gt; 10 //如果左侧为true，就不会判断右侧等同于(2 &lt; 3) || (5 &gt; 10) //说明逻辑运算符优先级低于关系运算符5 &gt; 8 &amp;&amp; 5 &lt; 10 //优先判断左侧，如果左侧为false，就不会判断右侧!(x &gt; 5) //取反使用保留字表达逻辑运算符另一种表达方式&amp;&amp;and或or!not字符函数库cctype使用isalpha()来检查字符是否为字母字符使用isdigit()来测试字符是否是数字字符使用isspace()来测试字符是否是空白（如换行符、空格、制表符）使用ispunct()来测试字符是否是标点符号函数名入参返回值isalnum()字母或数字trueisalpha()字母trueiscntrl()控制字符trueisdigit()数字（0～9）trueisgraph()除空格外的打印字符trueislower()小写字符trueisprint()打印字符，包含空格trueispunct()标点符号trueisspace()标准空白字符，如空格、换行、回车、水平制表符、垂直制表符trueisupper()大写字母trueisxdigit()十六进制数字，即0～9、a~f、A～F返回truetolower()大写字符返回其小写，否则返回参数toupper()小写字符返回大写，否则返回参数三目条件运算符（?:）5 &gt; 3 ? 10 : 12，如果true，则返回10，false返回12switchswitch中的每个case标签必须是一个单独的值。这个值必须是整数（含char）。因此switch无法处理浮点测试。另外case标签必须是常量。break和continue都呢该构跳过代码。不同之处前者跳出整个循环，后者跳出本次循环。switchtest.cpp12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;using namespace std;int main() &#123; char choice; cin &gt;&gt; choice; while (choice != 'Q' &amp;&amp; choice != 'q') &#123; switch(choice) &#123; case 'a': case 'A': cout &lt;&lt; \"result is a/A\\n\"; break; case 'b': case 'B': cout &lt;&lt; \"result is b/B\\n\"; break; case 'd': case 'D': cout &lt;&lt; \"result is d/D\\n\"; break; case 'c': case 'C': cout &lt;&lt; \"result is c/C\\n\"; break; default: cout &lt;&lt; \"Not abcd\" &lt;&lt;endl; break; &#125; cin &gt;&gt; choice; &#125; return 0;&#125;执行结果：1234567891011aresult is a/ABresult is b/Bcresult is c/CD result is d/DFNot abcdq文件输入输出I/O写入1234567char ch;std::cin &gt;&gt; ch;std::cout &lt;&lt; \"Result is \" &lt;&lt; ch &lt;&lt;std::endl;char word[50];cin &gt;&gt; word; //不断读取，直到遇到空白字符cin.getline(word, 50); //不断读取，直到遇到换行符写入到文本文件outfile.cpp1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;#include&lt;fstream&gt;using namespace std;int main() &#123; char automobile[50]; int year; double a_price; double b_price; ofstream outFile; outFile.open(\"carinfo.txt\"); cout &lt;&lt; \"Enter the make and model of automobile: \\n\"; cin.getline(automobile, 50); cout &lt;&lt; \"Enter the model year: \\n\"; cin &gt;&gt; year; cout &lt;&lt; \"Enter the original asking price: \\n\"; cin &gt;&gt; a_price; b_price = 0.913 * a_price; outFile &lt;&lt; fixed; outFile.precision(2); outFile.setf(ios_base::showpoint); outFile &lt;&lt; \"Make and model: \" &lt;&lt; automobile &lt;&lt;endl; outFile &lt;&lt; \"Year : \" &lt;&lt; year &lt;&lt;endl; outFile &lt;&lt; \"Was asking $\" &lt;&lt; a_price &lt;&lt;endl; outFile &lt;&lt; \"Now asking $\" &lt;&lt; b_price &lt;&lt;endl; outFile.close(); return 0;&#125;执行结束后生成的文件：carinfo.txt1234Make and model: Flitz PerkyYear : 2009Was asking $13500.00Now asking $12325.50读取文本读取文件：readfile_test.txt12312 31.2 32123 23.21 3123 31代码：readfile.cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;iostream&gt;#include&lt;fstream&gt;#include&lt;cstdlib&gt;const int SIZE = 60;int main() &#123; using namespace std; char filename[SIZE]; ifstream inFile; cout &lt;&lt; \"Enter file name: \\n\"; cin.getline(filename, SIZE); inFile.open(filename); if (!inFile.is_open()) &#123; cout &lt;&lt; \"Could not open file \" &lt;&lt; filename &lt;&lt;endl; exit(EXIT_FAILURE); &#125; double value; double sum = 0.0; int count = 0; //读取的数量 inFile &gt;&gt; value; //获取第一个alue while (inFile.good()) &#123; ++count; //读取数量+1 sum += value; //极端总和 inFile &gt;&gt; value; //获取下一个value &#125; if (inFile.eof()) cout &lt;&lt; \"End of file reached.\\n\"; else if (inFile.fail()) cout &lt;&lt; \"Input terminated by data mismatch.\\n\"; else cout &lt;&lt; \"Input terminated for unknown reason.\\n\"; if (count == 0) cout &lt;&lt; \"No data processed.\\n\"; else &#123; cout &lt;&lt; \"Item read : \" &lt;&lt; count &lt;&lt;endl; cout &lt;&lt; \"Sum : \" &lt;&lt; sum &lt;&lt;endl; &#125; inFile.close(); return 0;&#125;执行结果：12345Enter file name: readfile_test.txtEnd of file reached.Item read : 8Sum : 495.41","tags":[{"name":"cpp","slug":"cpp","permalink":"http://wizzie.top/tags/cpp/"}]},{"title":"C++循环语句for, while, do-while","date":"2019-08-14T14:23:05.000Z","path":"2019/08/14/2019/190814_cpp_for/","text":"for循环12for (int i = 5; i &lt; 0; i--) cout &lt;&lt; \"i=\" &lt;&lt; i &lt;&lt;endl;阶乘运算：formore.cpp12345678910111213141516#include&lt;iostream&gt;using namespace std;const int SIZE = 16;int main() &#123; long long factorials[SIZE]; factorials[1] = factorials[0] = 1LL; for (int i = 2; i &lt; SIZE; i++) factorials[i] = i * factorials[i-1]; for (int i = 0; i &lt; SIZE; i++) cout &lt;&lt; i &lt;&lt; \"! = \" &lt;&lt; factorials[i] &lt;&lt;endl; return 0;&#125;执行结果：123456789101112131415160! &#x3D; 11! &#x3D; 12! &#x3D; 23! &#x3D; 64! &#x3D; 245! &#x3D; 1206! &#x3D; 7207! &#x3D; 50408! &#x3D; 403209! &#x3D; 36288010! &#x3D; 362880011! &#x3D; 3991680012! &#x3D; 47900160013! &#x3D; 622702080014! &#x3D; 8717829120015! &#x3D; 1307674368000while循环while循环是没有初始化和更新部分的for循环，只有测试条件和循环体。循环的指导原则：指定循环终止的条件在首次测试之前初始化条件在条件被再次测试之前更新条件示例代码：while.cpp123456789101112131415161718#include&lt;iostream&gt;using namespace std;const int SIZE = 20;int main() &#123; char name[SIZE]; cout &lt;&lt; \"Enter your name: \"; cin &gt;&gt; name; int i = 0; while(name[i] != '\\0') &#123; cout &lt;&lt; name[i] &lt;&lt; \" : \" &lt;&lt; int(name[i]) &lt;&lt;endl; i++; &#125; return 0;&#125;执行结果：1234567Enter your name: wizziew : 119i : 105z : 122z : 122i : 105e : 101类型别名使用预处理器#define BYTE char使用关键字typedef，例如typedef char * byte_pointer;do while循环不同于前两种循环，他是出口条件循环。首先执行循环体，然后判断测试表达式。基于范围的for循环（C++11新增）对数组或者容器类（例如vector， array）的每个元素执行相同的操作。For example:123double prices[3] = &#123;2.33, 4122.2, 321.33&#125;;for (double x : prices) std::cout &lt;&lt; x &lt;&lt;std::endl;嵌套循环12345for (int row = 0; row &lt; 4; row++) &#123; for (int col = 0; col &lt; 5; ++col) cout &lt;&lt; maxtemps[row][col] &lt;&lt; \"\\t\"; cout &lt;&lt; endl;&#125;二维数组123456int btus[3][2] =&#123; &#123;23, 31&#125;, &#123;23, 532&#125;, &#123;31243, 4231&#125;&#125;;","tags":[{"name":"cpp","slug":"cpp","permalink":"http://wizzie.top/tags/cpp/"}]},{"title":"C++内存分配方式和模板类vector, array","date":"2019-08-13T15:31:05.000Z","path":"2019/08/13/2019/190813_cpp_typeTemplete/","text":"使用new创建动态结构在运行时创建数组优于编译时创建数组，对于结构也是如此。需要在程序运行时为结构分配所需的空间，可以使用new完成。动态意味着内存是在运行时，而不是编译时分配的。例如inflatable *ps = new inflatable;其中inflatable是一个结构类型。这句代码将把存储结构inflatable的一块可用内存的地址赋值给ps。箭头成员运算符-&gt;，可用于指向结构的指针。例如ps指向一个inflatable结构的成员price，即ps-&gt;priceNote：如果结构标识符是结构名，则使用句点运算符如果标识符是指向结构的指针，则使用箭头运算符示例代码：newstruct.cpp12345678910111213141516171819202122232425262728#include&lt;iostream&gt;using namespace std;struct inflatable &#123; char name[20]; float volume; double price;&#125;;int main() &#123; inflatable *ps = new inflatable; cout &lt;&lt; \"Enter name: \"; cin.get(ps-&gt;name, 20); cout &lt;&lt; \"Enter volume:\"; cin &gt;&gt; (*ps).volume; cout &lt;&lt; \"Enter price: $\"; cin &gt;&gt; ps-&gt;price; cout &lt;&lt; \"Result: Name=\" &lt;&lt; (*ps).name &lt;&lt;endl; cout &lt;&lt; \"Volume=\" &lt;&lt; ps-&gt;volume &lt;&lt;endl; cout &lt;&lt; \"Price=\" &lt;&lt; ps-&gt;price &lt;&lt;endl; delete ps; //删除new创建的对象 return 0;&#125;执行结果：123456Enter name: PeterEnter volume:27.99Enter price: $23.54Result: Name&#x3D;PeterVolume&#x3D;27.99Price&#x3D;23.54示例代码：delete.cpp1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;char * getname(void); //一般可以放在头文件int main()&#123; char * name; name = getname(); cout &lt;&lt; name &lt;&lt; \" at \" &lt;&lt; (int*)name &lt;&lt;endl; delete []name; name = getname(); cout &lt;&lt; name &lt;&lt; \" at \" &lt;&lt; (int*)name &lt;&lt;endl; delete []name; return 0;&#125;char * getname() &#123; char temp[80]; //暂时内存 cout &lt;&lt; \"Enter name: \"; cin &gt;&gt; temp; char * pn = new char[strlen(temp)+1]; //+1包含空字符 strcpy(pn, temp); return pn; //返回指针&#125;执行结果：1234Enter name: peterpeter at 0x21ee440Enter name: nancynancy at 0x21ee440管理数据内存的四种方式根据用于分配内存的方法，C++有三种管理数据内存的方式：自动存储、静态存储、动态存储（有时候也叫做自由存储空间或堆）C++11增加了第四种类型：线程存储自动存储(stack)在函数内部定义的常规变量使用自动存储空间，被称为自动变量。这意味着他们所属的函数被调用时自动产生，函数结束时消亡。实际上，自动变量是一个局部变量，其作用域是包含他的代码块。（代码块是被包含在花括号中的一段代码）自动变量通常存储在栈中，这意味着执行代码时，其中的变量将依次加入到栈中，而在离开代码块时，按照相反的顺序释放这些变量（先进后出LIFO）。因此，在程序执行过程中，栈将不断地的增大和缩小。静态存储静态存储是整个程序执行期间都存在的存储方式。使变量成为静态的方式有两种：在函数外面定义它在声明变量时使用关键字static (例如static double fee = 56.30;)自动存储和静态存储的关键在于： 这些方法严格的限制了变量的寿命。变量可能存在于程序的整个生命周期（静态变量），也有可能只在特定函数被执行时存在（自动变量）动态存储(heap or free store)new和delete提供了一种比前两者更加灵活的方法。他们管理了一个内存池，这个在C++中被称为自由存储空间free store或者堆heap该内存池同用于静态变量和自动变量的内存是分开的。new和delete能够让你在一个函数中分配内存，而在另一个函数中释放它。有关栈、堆和内存泄漏如果使用new在堆（或者自由存储空间）上创建变量后，没有调用delete。将会发生什么情况呢？如果没有调用delete，则即使包含指针的内存由于作用域规则和对象生命周期的原因被释放，在堆上动态分配的变量或者结构还是会继续存在。实际上，将会无法方位堆中的结构，因为指向这些内存的指针无效。这将会导致内存泄漏memory leak。被泄漏的内存在程序的整个生命周期都不能使用，这些内存被分配出去，但是无法收回。 极端情况下，内存泄漏可能会非常严重，以致于应用程序的可用内存被耗尽，导致程序崩溃crash。因此为比描内存泄漏，同时使用new和delete运算符类型组合123456789101112131415161718192021222324struct yearinfo&#123; int year;&#125;;yearinfo s1, s2, s3; //都是结构s0.year = 1996; //使用句点运算符访问成员yearinfo *pa = &amp;s0; //创建指向这个结构变量的指针（地址运算符）pa-&gt;year = 1999; //使用指针的箭头运算符访问成员yearinfo info[3]; //创建结构数组info[0].year = 2019; (info+1)-&gt;year = 2004; //地址加一（一个类型的字节数） ， 同info[1].yearconst yearinfo * arp[3] = &#123;&amp;s0, &amp;s1, &amp;s2&#125;;arp[1]-&gt;year //访问成员const yearinfo ** ppa = arp; //建立上述指针的指针auto ppb = arp; //C++11版本的auto能够正确的推断ppb的类型(*ppa)-&gt;year(*(ppb+1))-&gt;year数组的替代品vector模板类vector类似于string类，也是一种动态数组。基本使用：必须包含头文件vector包含在命名空间std中模板使用不同的语法来指出它存储的数据类型使用不同的语法来指定元素数示例代码：1234567#include&lt;vector&gt;...using namespace std;vector&lt;int&gt; vi;int n;cin &gt;&gt; n;vector&lt;double&gt; vd(n); //创建数组包含n个double元素缺点：效率相比数组稍低；而数组长度固定，不方便和安全。C++11新增模板类array位于命名空间std中，并且长度固定，也是使用栈（静态内存分配），因此效率和数组相同。创建需要包含头文件array。12345#include&lt;array&gt;...using namespace std;array&lt;int, 5&gt; ai; //创建长度是5，类型是int的array模板array&lt;double, 4&gt; ad = &#123;1.2, 32.2, 31.2, 3.2&#125;;复杂类型的小结结构可以将多个不同类型的值存储在同一个数据对象中，可以使用成员关系运算符(.)访问成员。共同体可以存储一个值，但是这个值可以是不同的类型，成员名指出了使用的模式。指针是被设计用来存储地址的变量。指针声明指出了指针指向的对象的类型。指针指向了它存储的地址。对指针应用接触引用运算符，将得到指针指向的位置中的值。字符串以空字符为结尾的一系列字符。字符串可用引号括起的字符串常量表示，其中隐式包含了结尾的空字符。可以将字符串存储在char数组中，可以用被初始化为指向字符串的char指针表示字符串。函数strlen()返回字符串长度，但是不包含空字符。函数strcpy()将字符串从一个位置复制到另一个位置。需要加入头文件cstring或者string.hnew运算符允许在程序运行时为数据对象请求内存。该运算符返回获得内存的地址，可以将这个地址赋值给一个指针，程序将只能使用该指针来访问这块内存。如果是简单变量，使用解除引用运算符*来获取值；如果数据对象是数组，则可以使用数组名那样使用指针来访问元素；如果数据对象是结构，使用-&gt;访问成员指针和数组紧密相关，如果ar是数组名，则表达式ar[i]被解释为*(ar+i)，其中数组名被解释为数组第一个元素的地址。这样，数组名的作用同指针。反之，可以使用数组表示法，通过指针名来访问new分配的数组中的元素。","tags":[{"name":"cpp","slug":"cpp","permalink":"http://wizzie.top/tags/cpp/"}]},{"title":"C++复合类型之枚举、指针","date":"2019-08-12T14:21:05.000Z","path":"2019/08/12/2019/190812_cpp_complex2/","text":"枚举enumC++的enum工具提供了另一种创建符号常量的方式，可以代替const。它还允许定义新的类型，但是必须严格按照格式。使用enum语法格式和结构相似，例如enum colorInfo{red, blue, orange};colorInfo是新类型的名称；colorInfo被成为枚举red,blue,orange是符号常量，对应整型树脂0,1,2，这些常量叫做枚举量默认情况下，将整型数值赋给枚举量，从0开始以此类推声明使用枚举名来声明这种枚举的变量：colorInfo band;赋值只能使用定义枚举量赋值给枚举的变量：1234567891011+ band = red; //将定义枚举中的red值赋给band变量- band = black; //在枚举中不存在double *pn;char *pa;double *pc;double bu = 4.2;pn = &amp;bu;pa = new char;pc = new double[10];设置枚举的值使用赋值运算符显式设置枚举的值：enum bits {one=1, two=2};显式定义部分元素（其他的元素以前一个元素作为参照依次+1）enum bytes {a, b=100, c} //此时a=0,b=100,c=101创建多个值相同的枚举量enum {zero, null=0, one, numero_uno=1}; //其中zero和null都是0，后面两个都是1，这是合法的枚举的取值范围枚举的最大值的最小的2的次幂，将其减去1，得到取值范围的上限。例如最大值是101，则最小的2的次幂是128，减去1，所以取值的上限是127如果枚举量的最小值&gt;=0，则取值范围的下限是0；否则同上，取2的最小次幂，减一，加上负号。例如最小值是-6，则取最小2次幂减一是7，加上负号，所以取值下限是-7指针计算机在存储数据的时候必须跟踪的三种基本属性：信息存储的位置存储的值存储的类型指针是一个变量，其存储的值是值的地址地址运算符&amp;地址运算符&amp;可以获取一个常规变量的地址，例如home是变量，&amp;home即是他的地址address1.cpp1234567891011121314#include&lt;iostream&gt;using namespace std;int main() &#123; int dog = 6; double food = 4.5; cout &lt;&lt; \"dog = \" &lt;&lt; dog &lt;&lt; \", food = \" &lt;&lt; food &lt;&lt;endl; cout &lt;&lt; \"dog address = \" &lt;&lt; &amp;dog &lt;&lt; \", food address = \" &lt;&lt; &amp;food &lt;&lt;endl; return 0;&#125;打印结果：12dog = 6, food = 4.5dog address = 0x7fff81decc1c, food address = 0x7fff81decc20Notes:常用十六进制描述地址（也存在十进制表示法）。 使用常规变量时，值是指定的量，而地址是派生量面向对象OOP和面向过程的编程区别在于，OOP强调的是在运行阶段（非编译阶段）进行决策。运行阶段指的是程序正在运行，编译阶段指的是编译器将程序组合起来时。运行阶段决策提供了灵活性，可以根据实时情况进行调整。例如声明数组的时候定义长度。指针用于存储值的地址。指针名表示的是地址，*运算符被称为间接值或解除引用运算符，将其应用于指针，可以得到该地址处存储的值。例如：假设manly是一个指针，则manly表示的是一个地址，而*manly表示存储在该处的值。*manly和常规int变量等效。例如下列代码：pointer.cpp123456789101112131415#include&lt;iostream&gt;using namespace std;int main() &#123; int updates = 6; //变量 int * p_updates; //指针 p_updates = &amp;updates; //指针存储了变量的地址 cout &lt;&lt; \"value updates = \" &lt;&lt; updates &lt;&lt; \", p_updates = \" &lt;&lt; p_updates &lt;&lt; \", &amp;updates = \" &lt;&lt; &amp;updates &lt;&lt;endl; *p_updates = *p_updates + 1; cout &lt;&lt; \"Now updates = \"&lt;&lt; updates &lt;&lt; \", *p_updates = \"&lt;&lt; *p_updates &lt;&lt; \", p_updates = \" &lt;&lt; p_updates &lt;&lt;endl; return 0;&#125;执行结果：12value updates = 6, p_updates = 0x7ffcf520fbcc, &amp;updates = 0x7ffcf520fbccNow updates = 7, *p_updates = 7, p_updates = 0x7ffcf520fbcc声明和初始化指针声明必须指定指针指向的数据的类型int * p_updates;*p_updates的类型是int，由于*被用于指针，因此p_updates变量本身必须是指针，即p_updates指向int类型，或者是指向int的指针，或int*p_updates是指针（地址）；*p_updates是int，而不是指针。Notes:(1) *两边的空格是可选的。int *ptr; 强调*ptr是int类型的变量。int* ptr; 强调int*是一种指向int的指针。（在C++中，int*是复合类型，是指向int的指针）(2) 在C++中创建指针时，计算机将分配内存用来存储地址的内存，但是不会分配用来存储指针所指向的数据的内存。例如：long *fellow;*fellow = 2333; //ERROR此处没有给2333赋地址。指针和数字整数可以加减乘除，而指针表示地址，描述的是位置，将两个地址相乘没有意义。1234567//ERROR 不可以直接赋值，编译器会有错误消息：通用类型不匹配int* ptr;ptr = 0xB8000000;//Right 转换int* ptr;ptr = (int*) 0xB8000000;使用new分配内存在C++中，除了可以使用C语言的方法malloc()函数分配内存，还可以使用new运算符例如：(1) int *ptr = new int;new int告诉程序需要合适存储int的内存。new运算符根据类型确定需要多少字节的内存，然后找到这样的内存并返回地址。接着将地址赋给ptr，ptr是被声明为指向int的指针。(2) int hig;int *pn = &amp;hig;这种方法是使用hig名称来访问int为一个数据对象（可以是结构，或者基本类型等）获得并指定分配内存的通用格式：typename * poniter_name = new typename;代码示例：use_new.cpp1234567891011121314151617181920212223#include&lt;iostream&gt;using namespace std;int main()&#123; int nights = 1001; int *pt = new int; //分配内存 *pt = 1001; //赋值 cout &lt;&lt; \"nights = \" &lt;&lt; nights &lt;&lt; \", its' address = \" &lt;&lt; &amp;nights &lt;&lt;endl; cout &lt;&lt; \"*pt = \" &lt;&lt; *pt &lt;&lt; \", its' address = \" &lt;&lt; pt &lt;&lt;endl; double *pd = new double; *pd = 10000001.0; cout &lt;&lt; \"*pd = \" &lt;&lt; *pd &lt;&lt; \", address of pointer *pd = \" &lt;&lt; &amp;pd &lt;&lt;endl; cout &lt;&lt; \"size of pt = \" &lt;&lt; sizeof(pt); cout &lt;&lt; \" : size of *pt = \" &lt;&lt; sizeof(*pt) &lt;&lt;endl; cout &lt;&lt; \"size of pd = \" &lt;&lt; sizeof(pd); cout &lt;&lt; \" : size of *pd = \" &lt;&lt; sizeof(*pd) &lt;&lt;endl; return 0;&#125;执行结果：12345nights = 1001, its' address = 0x7fff3426f484*pt = 1001, its' address = 0x150bc20*pd = 1e+07, address of pointer *pd = 0x7fff3426f488size of pt = 8 : size of *pt = 4size of pd = 8 : size of *pd = 8Note:变量nights和pd的值都存储在栈stack的内存区域；而new从堆heap或者自由存储区free store的内存区域分配内存。使用delete释放内存使用delete时，后面要加上指向内存块的指针（这些内存块最初是由new分配的）123int *ps = new int;...delete ps;这将会释放ps指向的内存，但是不会删除指针ps本身。例如，可以将ps重新指向另一个新分配的内存块。一定要配对的使用new和delete，否则会发生内存泄漏 memory leak。只能用delete来释放使用new分配的内存（对空指针使用delete是安全的）使用delete的关键是，将他用于new分配的内存，这并不意味者要使用用于new的指针，而是用于new的地址。例如：1234567891011int *ps = new int;delete ps; //okdelete ps; //not okint jugs = 6;int *pi = &amp;jugs; //okdelete pi; //not allowedint *pk = new int; //分配内存int *pq = pk; //声明第二个指针delete pq; //delete第二个指针，并不会影响pk的值（但是pk的值必须要new分配内存）使用new创建动态数组例如下面的语句创建指针，它指向包含十个int值的内存块中的第一个元素：int *psome = new int[10];不能修改数组名的值，但是可以修改指针变量。将指针变量加一后，增加的量等于它指向类型的字节数（例如int数组一个变量四个字节）代码：arraytnew.cpp123456789101112131415161718192021#include&lt;iostream&gt;int main() &#123; using namespace std; double *p3 = new double[3]; p3[0] = 0.2; p3[1] = 0.5; p3[2] = 0.8; cout &lt;&lt; \"p3[1] = \"&lt;&lt; p3[1] &lt;&lt;endl; p3+=1; cout &lt;&lt; \"Now p3[0] = \"&lt;&lt; p3[0] &lt;&lt;endl; cout &lt;&lt; \"Now p3[1] = \"&lt;&lt; p3[1] &lt;&lt;endl; p3-=1; delete []p3; //free memory return 0;&#125;结果：123p3[1] = 0.5Now p3[0] = 0.5Now p3[1] = 0.8 //+1之后的数组第一个元素就变成了第二个元素指针小结对数组使用sizeof得到的是数组的长度（int4个字节乘以元素数量，单位是字节），而对指针使用sizeof得到的是指针的长度，即指针指向的是一个数组（元素数量）。1234567int *pt = new int[10];*pt = 5; //pt[0]=5 or pt=5pt[0] = 6; //resetpt[9] = 44;int coats[10];*(coats + 4) = 12; //coats[4] = 12数组名被解释为其第一个元素的地址arrayname，而对数组名应用地址运算符&amp;时，即&amp;arrayname，得到的是整个数组的地址。例如：123short tell[10];tell //display &amp;tell[0]，一个2字节内存块的地址&amp;tell //display address of whole array，一个20字节内存块的地址对指针接触引用意味着获取指针指向的值，例如*pn，另一种接触引用的方法是使用数组表示法，例如pn[0]。区别指针和指针指向的值，int *pt = new int; *pt = 5;其中pt是指向int的指针，而*pt是完全等同于一个int类型的变量。数组的静态联编是使用数组声明来创建数组时，数组的长度在编译时设置int tacos[10];数组的动态联编是使用new[]创建数组，在运行时为数组分配空间，其长度在运行时者之。使用完这种数组后，应该使用delete[]释放占用的内存。ptrstr.cpp1234567891011121314151617181920212223242526#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;int main() &#123; char animal[20] = \"bear\"; const char *bird = \"wren\"; char *ps; cout &lt;&lt; animal &lt;&lt; \" and \" &lt;&lt; bird &lt;&lt;endl; //cout &lt;&lt; ps &lt;&lt;endl; //may crash, may garbage, may skip, print nothing ps = animal; cout &lt;&lt; ps &lt;&lt; endl; cout &lt;&lt; (int *)animal &lt;&lt; \" and \" &lt;&lt; (int *)ps &lt;&lt;endl; ps = new char(strlen(animal) + 1); //get new storage返回字符串的长度 strcpy(ps, animal); //copy string to new storage将字符串从一个位置复制到另一个位置 cout &lt;&lt; \"After using strcpy, animal \" &lt;&lt; animal &lt;&lt; \" at \"&lt;&lt; (int*)animal &lt;&lt;endl; cout &lt;&lt; ps &lt;&lt; \" at \" &lt;&lt; (int*)ps &lt;&lt;endl; delete []ps; return 0;&#125;执行结果：12345bear and wrenbear0x7ffde23d00b0 and 0x7ffde23d00b0After using strcpy, animal bear at 0x7ffde23d00b0bear at 0x1b2b030","tags":[{"name":"cpp","slug":"cpp","permalink":"http://wizzie.top/tags/cpp/"}]},{"title":"C++复合类型之数组、字符串、结构、共用体","date":"2019-08-01T13:41:05.000Z","path":"2019/08/01/2019/190801_cpp_complex/","text":"题外话： 在我眼里，我实习的第一家公司教会了我两件事，一是让自己忙起来，二是代码规范整洁。有时候有所悟会很晚，但终究不迟。序： C++提供了基于整型和浮点类型创建的复合类型。影响最深远的复合类型是类。然而，C++还支持几种普通的复合类型。例如，数组 可以存储多个同类型的值。结构 可以存储多个不同类型的值。指针 则是一种将数据所处位置告诉计算机的类型。数组array数组声明应指出以下三点：存储每个元素中的值的类型数组名数组的元素数量格式：short months[12];typename arrayname[size];size 必须是整型常数或const值，也可以是常量表达式。他不能是变量。C++11新增初始化的功能初始化数组可以省略等于号=，例如double ear {1.2e2, 1.6e3, 2.3e4,3.5e10};可以不在大括号内包含任何东西，意味着所有元素是0列表初始化禁止缩窄转换123long plifs[] = &#123;23,12,3.0&#125;; //浮点数转换成长整型是缩窄操作，不能编译通过char slifs[] = &#123;'g',1123456,'\\o'&#125;; //1123456超过char变量的取值范围，不能编译通过char tlifs[] = &#123;'h',112,'o'&#125;; //OK数组的替代品 – 模板类vector在C++标准模板库STL提供了vector，以及C++11增加了模板类array。字符串C++处理字符串的方式有两种，一种来自C语言，常称为C-风格字符串，另一种基于string类库的方法。C-风格字符串(字符数组)C-风格字符串以空字符 \\0 结尾，其ASCII码是0。char dog[3] = {&#39;d&#39;,&#39;o&#39;,&#39;g&#39;}; //not a stringchar dog[3] = {&#39;d&#39;,&#39;o&#39;,&#39;g&#39;, &#39;\\0&#39;}; //is a string字符串常量或者称字符串字面值使用双引号表示字符串常量，而字符是单引号char bird[11] = &quot;Mr. cheeps&quot;; //the \\0 is hideen,隐式包含结尾的空字符char fish[] = &quot;buddles&quot;; //left the complier countsizeof()指出整个数组长度，而strlen返回的是存储在数组中字符串的长度，而不是数组本省的长度。strlen()只计算可见的字符，不计算空字符\\0在内。(只针对char数组，并且需要加入头文件 #include&lt;cstring&gt;)读取一行字符串输入istream中的类（例如cin）提供了一些面向行的成员函数：getline()和get()这两个函数都读取一行输入，直到到达换行符随后，getline将丢弃换行符，get()将换行符保留在输入序列。（1）cin.getline(name,20); 将一行数据读入到一个包含20个元素的name数组。如果这行包含的字符不超过19个（\\0）instr2.cpp12345678910111213141516 #include&lt;iostream&gt; int main() &#123;using namespace std;const int size = 20;char name[size];char group[size];cout &lt;&lt; \"Enter your name : \\n\";cin.getline(name, size); //read info inlinecout &lt;&lt; \"Enter group: \\n\";cin.getline(group, size);cout &lt;&lt; \"name is \"&lt;&lt; name &lt;&lt;endl;cout &lt;&lt; \"groupf is \" &lt;&lt; group &lt;&lt;endl;return 0; &#125;结果：123456Enter your name : abcEnter group: defname is abcgroupf is def（2）cin.get(name,size)不会换行，而是将换行符读入到下一行开始。可以通过以下两种方式换行：123456//firstcin.get(name,size);cin.get();cin.get(group,size);//secondcin.get(name.size).get();(3) 读取空行当get()或者getline()读取空行后将设置失效位 failbit。这意味接下来的输入将被阻断。恢复输入方法： cin.clear();(4) 输入字符串比分配的空间（数组size）长，则getline()和get()将把余下的字符留在输入队列中，getline()还会设置失效位，并关闭后续的输入。string类string类需要头文件string。并且string位于命名空间std中。代码示例：strtype1.cpp123456789101112131415#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main()&#123; string str1; string str2 = \"cat\"; cout &lt;&lt; \"Enter string data:\\n\"; cin &gt;&gt; str1; cout &lt;&lt; \"str1=\" &lt;&lt; str1 &lt;&lt;\", str2 = \"&lt;&lt; str2 &lt;&lt; \", str2[2] = \"&lt;&lt; str2[2] &lt;&lt;endl; return 0;&#125;结果：123Enter string data:dogstr1=dog, str2 = cat, str2[2] = tNote:类设计让程序能够自动处理string的大小。例如str1声明的时候长度为0，读取到输入后长度是3。C++11新增的字符串初始化：12345char char1[] = &#123;\"hello boy\"&#125;;char char2[] &#123;\"hello girl\"&#125;;string str1 = &#123;\"good boy\"&#125;;string str2 &#123;\"good girl\"&#125;;字符串拼接合并123string str3;str3 = str1 + str2;str1 += str2;cstring头文件的字符数组char[]复制和附加操作12strcpy(char1, char2); //将char2数组赋值到char1strcat(char1, char2); //将char2数组附加到char1末尾对比来说，字符串string的拼接和附加操作更加简单。两种字符串书写方式的I/O和字符串长度代码：strtype2.cpp123456789101112131415161718192021222324#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;cstring&gt;using namespace std;int main() &#123; char ch[10]; string str; cout &lt;&lt; \"length of ch[10] = \" &lt;&lt; strlen(ch) &lt;&lt;endl; cout &lt;&lt; \"length of str = \" &lt;&lt; str.size() &lt;&lt;endl; cout &lt;&lt; \"Enter a line for ch[10]: \\n\"; cin.getline(ch,10); cout &lt;&lt; \"Enter a line for str:\\n\"; getline(cin, str); //这个getline()不是类方法，他将cin作为参数，指出到哪里去查找输入 cout &lt;&lt; \"Now length of ch[10] = \" &lt;&lt; strlen(ch) &lt;&lt;endl; cout &lt;&lt; \"Now length of str = \" &lt;&lt; str.size() &lt;&lt;endl; return 0;&#125;结果：12345678length of ch[10] = 0length of str = 0Enter a line for ch[10]:cat dogEnter a line for str:cat dog2Now length of ch[10] = 7Now length of str = 8wchar_t, char16_t, char32_t的初始化123wchar_t title[] = L\"Paper\"; //Lchar16_t name[] = u\"Nancy\"; //uchar32_t subject[] = U\"math\"; //UC++11新增的原始字符串raw，以R为前缀cout &lt;&lt; R&quot;(&quot;king&quot; \\n and queue)&quot;结果：&quot;king&quot; \\n and queue原始字符串使用&quot;(和)&quot;作为限定符，换行符\\n也只打印两个单独的符号。或者使用&quot;+*(和)*+&quot;作为限定符结构结构可以存储多种类型的数据。结构是用户定义的类型而结构声明定义了这种类型的数据属性定义了类型之后，便可以创建这种类型的变量创建结构包含两步：定义结构描述（它描述并且标记能够存储在结构中的各种数据的类型）按照描述创建变量（结构数据变量）例如以下结构描述123456struct inflatable //结构的关键字`struct`，标识符`inflatable`是这种数据格式的名称&#123; char name[20]; float volume; double price;&#125;;创建这种类型的变量：12inflatable hat; //允许省略关键字`struct`，因为结构声明定义了一种新的数据格式inflatable mainframe;因为hat是数据结构类型，所以允许使用hat.name来访问成员。示例代码：strucetype1.cpp1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;struct inflatable //结构的关键字`struct`，标识符`inflatable`是这种数据格式的名称&#123; char name[20]; float volume; double price;&#125;;int main()&#123; using namespace std; inflatable hat = &#123; \"pen\", 1.88, 29.99 &#125;; inflatable pal = &#123; \"pencil\", 3.13, 32.99 &#125;; cout &lt;&lt; \"List name : \" &lt;&lt; hat.name &lt;&lt; \" ,and \" &lt;&lt; pal.name &lt;&lt;endl; cout &lt;&lt; \"List volume: \" &lt;&lt; hat.volume &lt;&lt; \",and \" &lt;&lt; pal.volume &lt;&lt;endl; cout &lt;&lt; \"Total price : \" &lt;&lt; hat.price + pal.price &lt;&lt;endl; return 0;&#125;执行结果：123List name : pen ,and pencilList volume: 1.88,and 3.13Total price : 62.98结构声明的位置结构声明的位置很重要，可以将声明放在main函数中，紧跟在开始括号的后面也可以选择将声明放在main函数前面位于函数外面的声明被成为外部声明，如果类包含两个或更多的函数，外部声明可以被后面的函数使用而内部声明只能当前函数使用C++11的初始化同字符串和数组，结构也支持列表初始化，即在初始化的时候=等于号是可选的。`inflatable duck {&quot;Dada&quot;, 0.12, 9.98};`同时定义结构和和创建变量1234567891011121314151617181920struct perks &#123; int keynum; char car[10];&#125; mr_smith,ms_jones; //定义的两个结构体变量//或者同时进行初始化struct perks &#123; int keynum; char car[10];&#125; mr_smith &#123; 7, \"Peak\"&#125;;//声明一次性没有名称的结构，此时直接使用`position.x`进行访问struct //没有结构体名称&#123; int x, int y&#125; position;结构数组可以创建结构数组，例如inflatable gifts[100];，此时访问成员元素使用gifts[0].name此时的gifts不是结构，而是数组‘gifts[0]’是结构结构中的位字段C++允许指定占用特定位数的结构成员。这使得创建与某个硬件的寄存器对应的数据结构非常方便。字段的类型应为整型或者枚举，接下来是冒号，冒号后面是数字，它指定了使用的位数每个成员都被称为位字段位字段常用于低级编程中12345struct torgle &#123; unsigned int SN : 4; //4位给SN变量 unsigned int : 4; //不指定的4位 bool googin : 1; //非法输入&#125;共用体unionunion能够存储不同类型的数据，但是只能同时存储其中的一种类型。例如：12345union one4all &#123; int val; long val2; double val3;&#125;可以使用one4all存储不同的类型，存储int，long，或者double123456one4all pail;pail.val = 10;cout &lt;&lt; pail.val; //10pail.val3 = 1.35;cout &lt;&lt; pail.val3; //1.35因此，pail有时候是int类型，有时候也可以使long，double成员名称标识了变量的容量共同体每次只能存储一个值，因此必须有足够的空间来存储里面最大的成员，所以共同体的长度为其最大成员变量的长度共同体的用途之一是：当数据项使用两种或者更多的格式，但是不会同时使用时，可以节省时间。例如一些商品的ID是整数，而另一些的ID是字符，则可以定义：123456789struce thing &#123; char name[20]; union id &#123; long id_num; //整型的ID char id_char[20]; //字符型的ID &#125; id_val; //id_val是声明在结构体中，可以使用`结构体.id_val.id_num`初始化&#125;;匿名共用体匿名共用体没有名称，其成员将成为位于相同地址的变量。每次只有一个成员是当前的成员。123456789101112131415161718struce thing &#123; char name[20]; int type; union &#123; //匿名 long id_num; //整型的ID char id_char[20]; //字符型的ID &#125;;&#125;;......thing prize;if (type == 1) &#123; cin &gt;&gt; prize.id_num;&#125; else &#123; cin &gt;&gt; prize.id_char; //此时直接调用匿名共用体的成员&#125;因为是匿名共用体，所以id_num和id_char被视为结构体thing的成员，他们的地址相同（相对于结构体来理解），因而不需要中间标识符id_val（即共用体的变量声明）。共用体常用于节省内存（例如操作系统数据结构或硬件数据结构）","tags":[{"name":"cpp","slug":"cpp","permalink":"http://wizzie.top/tags/cpp/"}]},{"title":"linux配置zsh终端","date":"2019-07-27T09:41:06.000Z","path":"2019/07/27/2019/190727-linux-zsh-md/","text":"从echo $SHELL可以查看当前使用的终端是/bin/bash。zsh是Ubuntu的一种终端工具，虽然听说功能很强很给力，事实上我只是被他的众多主题迷住了。具体查看文档安装zsh下载zshsudo apt-get install zshNote:生成配置文件/home/wizzie/.zshrc,对应默认的文件.bashrc下载 oh-my-zsh 项目配置 zshwget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | shNote:生成文件夹wizzie@wizzie:~/.oh-my-zsh,包含所有的zsh主题切换zsh模式123456chsh -s /bin/zsh//如果想切换会bash可以使用命令：chsh -s /bin/bash//重启电脑reboot修改主题修改.zshrc的ZSH_THEME=&quot;pygmalion&quot; #&quot;robbyrussell&quot;主题的文件预览样式主题文件从/home/wizzie/.oh-my-zsh/themes移动到/home/wizzie/.oh-my-zsh/custom/themes打开一个新的终端窗口，会发现主题修改成功例如我修改的pygmalion主题：pygmalion主题","tags":[{"name":"linux","slug":"linux","permalink":"http://wizzie.top/tags/linux/"}]},{"title":"hexo文章中使用iframe插件插入网易云音乐","date":"2019-07-26T17:12:19.000Z","path":"2019/07/27/2019/190726-next-addmusic/","text":"为了收藏一些喜欢的音乐分享在博客上，使用iframe插件生成网易云音乐的控件。获取链接简单的可以直接获取到，点击音乐进入播放界面，然后点击生成外链播放器生成外链播放器获取代码例如此处的音乐《约定》的iframe插件代码是：1&lt;iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&amp;id=187911&amp;auto=1&amp;height=66\"&gt;&lt;/iframe&gt;Note: 其中的id就是和网址的id相同（重点就是这个id）此时只需要将代码拷贝到md博客文章中，发布博客后就可以查看到音乐。有些音乐没有获取外链的版权如下图：无法获取外链此时只需要注意这首歌的网址里面的id即可，然后替换上面的那个代码里面的id，之后就可以播放了～观察网址获取id","tags":[{"name":"hexo","slug":"hexo","permalink":"http://wizzie.top/tags/hexo/"},{"name":"music","slug":"music","permalink":"http://wizzie.top/tags/music/"}]},{"title":"Ubuntu安装后的环境配置注意点","date":"2019-07-26T13:31:37.000Z","path":"2019/07/26/2019/190725_linux_linuxEnv/","text":"Ubuntu系统刚安装完成后，工作还只是进行了一小半，还有一大堆的环境需要配置搭建。比如说JDK, nodejs, python, vs code编译器 …apt查询包的版本apt-cache madison &lt;&lt;package name&gt;&gt;git配置安装： sudo apt-get install gitconfig配置：git config --global user.name &quot;username&quot;git config --global user.email &quot;username@example.com&quot;ssh公钥生成：ssh-keygen 或者 ssh-keygen -t rsa -C ****@**.com然后会生成.ssh/id_rsa.pub文件 将其拷贝到需要的地方即可（github）vscode下载1234567sudo add-apt-repository ppa:ubuntu-desktop/ubuntu-makesudo apt-get updatesudo apt-get install ubuntu-makeumake ide visual-studio-codereboot //如果安装完成没有vscode，就重启电脑gnome主题切换类似以下的方法：pop命令安装1234567sudo add-apt-repository ppa:system76&#x2F;popsudo apt updatesudo apt install pop-theme&#x2F;&#x2F;重启alt+f2输入r或者reboot在gnome主题网站下载安装下载后的压缩包解压到用户目录.local/themes或者.local/icons/目录下，之后使用gnome tweaks tool修改即可npm install一直卡住输入： npm config set registry http://registry.cnpmjs.org截图工具sudo apt-get install shutterjava环境sudo apt install default-jdksudo apt install default-jre_测试结果：java --versionjavac","tags":[{"name":"linux","slug":"linux","permalink":"http://wizzie.top/tags/linux/"}]},{"title":"C++浮点常量表示、算术运算符、类型转换","date":"2019-07-25T14:01:37.000Z","path":"2019/07/25/2019/190725_cpp_operator/","text":"浮点常量默认情况下，8.27和3.4E5这类浮点常量都属于double类型。如果希望常量是float类型，使用f或者F后缀对于long double的类型，使用l和L的后缀例如：12341.234f //float2.2L //long double2.34F //float23.231E24 //double (defalut)算术运算符五种C++基本运算符operationnoteexample+加法3+43=46-减法20-5=15*乘以3*5=15/除以10/3=3（整型相除，小数部分丢弃）%取余10%3=1例如：arith.cpp123456789101112131415#include&lt;iostream&gt;using namespace std;int main() &#123; float a = 50.25f; float b = 11.17f; cout&lt;&lt; \"a=\" &lt;&lt; a &lt;&lt; \",b=\"&lt;&lt;b&lt;&lt;endl; cout&lt;&lt; \"a+b=\"&lt;&lt; a+b &lt;&lt;endl; cout&lt;&lt; \"a-b=\"&lt;&lt; a-b &lt;&lt;endl; cout&lt;&lt; \"a*b=\"&lt;&lt; a*b &lt;&lt;endl; cout&lt;&lt; \"a/b=\"&lt;&lt; a/b &lt;&lt;endl; return 0;&#125;结果：Result12345a=50.25,b=11.17a+b=61.42a-b=39.08a*b=561.292a/b=4.49866除法如果两个整数相除，结果的小数部分将被丢弃，只保留整数部分如果其中一个（或者两个）是浮点数，则结果也会保留小数部分，类型是浮点数类型转换C++自动执行的类型转换：将一个算数类型的值赋给另一种算数类型的变量时，C++会对值转换表达式包含不同的类型时，C++会对值转换将参数传递给函数时，C++会对值转换类型转换的潜在问题转换潜在问题将较大的浮点类型转换成较小的浮点类型，例如double转换成float精度（有效位数降低），值可能超出目标类型的取值范围将浮点类型转换成整型小数部分丢失将较大的整型转换成较小的整型，例如long转换成short值可能超出目标类型的取值范围，通常只复制右边的字节将0赋值给bool类型，被转换成true非零的则是false以{}方式初始化时进行的转换（C++11）C++11将使用{}的初始化称为列表初始化因为这种初始化常用于给复杂的数据类型提供值列表列表初始化不允许缩窄，即可能无法赋值。例如浮点型不允许转换成整型12345678910const int code = 66; //整型常量int x = 66; //整型变量- char c1 &#123;31366&#125;; //类型缩窄，非法+ char c2 = &#123;66&#125;; //合法+ char c3 &#123;code&#125;; //合法- char c4 = &#123;x&#125;; //非法，x是一个变量，对于编译器而言，这个值可能很大。所以编译器不会跟踪执行以下阶段：从x被初始化，到被用来初始化c4x = 31355;+ char c5 = x; //合法，因为x已经被初始化表达式中的自动转换C++在表达式会执行两种自动转换：类型出现时就自动转换类型和其他类型同时出现在表达式中，将被转换整型提升在计算表达式时，C++将 bool,char,unsigned char,signed char,short 转换成int其中true -&gt; 1, false -&gt; 0123short a =20;short b =30;short c = a+b; //在进行计算的时候，会先将a,b转换成int，然后将结果转换成shortNote: 因为int是计算机最自然的类型，计算机使用这种类型时，运算速度可能最快。如果short比int短，则unsigned short会被转换成int；如果两个长度相同，unsigned short会被转换成unsigned int；这种规则保证unsigned short进行整型提升的时候不会损失数据C++11校验后，编译器在进行算术运算时，依次如下查阅：如果有一个操作类型是long double, 则另一个转换成long double否则，有一个是double， 另一个转换成double否则，有一个是float， 另一个转换成float否则，说明操作数都是整型，执行整型提升在这种情况下，如果两个操作数都是有符号或者无符号的，且级别不同，则转换成级别高的类型如果一个操作数有符号，另一个没有符号，且无符号操作数的级别比有操作符的高，则将有符号操作数转换成无符号操作数（还是转向级别高的类型）否则，有符号类型可以表示无符号类型的所有可能取值，则将无符号操作数转换成有符号操作数的类型否则，将两个操作数都转换成有符号类型的无符号版本传递参数的时候转换类型传递参数时的类型转换 通常由C++函数原型控制C++将对char和short类型应用整型提升（int）强制类型转换强制转换不会修改原变量本身，而是创建一个新的、指定类型的值通用格式如下：123456(typename) value //C的方式typename (value) //C++的方式例如将变量a的int值转换成long类型：(long) along (a)强制类型转换符1234static_cast&lt;typename&gt; (value)例如：static_cast&lt;long&gt; (a)C++11的auto声明auto是C++的关键字使用auto，而不指定变量类型，编译器将把变量的类型设置成和初始值相同1234567891011121314auto n = 10; //intauto x = 1.5; //doubleauto y = 1.3e12L //long doubleauto a = 0; //int，自动类型判断不会判断double类型auto b = 0.0; //doubledouble c = 0; //double，显示声明不会出现问题//标准模块库(STL)的自动类型判断（复杂类型）std::vector&lt;double&gt; scores;//(1)std::vector&lt;double&gt;::iterator pv = scores.begin();//(2)auto pv = scores.begin();小结C++的基本类型分为两组：一组存储整数的类型一组存储浮点数的类型整型由小到大依次是：bool, char, signed char, unsigned char, short, signed char, unsigned char, int, signed int, unsigned int, long, unsinged long, long long, unsigned long long还有在一种wchar_t类型，取决于实现C++11新增的char16_t和char32_t，分别存储16和32位的字符编码short 至少16位int 至少和short一样长long 至少32位","tags":[{"name":"cpp","slug":"cpp","permalink":"http://wizzie.top/tags/cpp/"}]},{"title":"Ubuntu18系统安装（无需制作启动盘）","date":"2019-07-25T13:31:37.000Z","path":"2019/07/25/2019/190724_ubuntu_install/","text":"数据备份准备工具Ubuntu系统（官网选择版本下载ISO文件）U盘（之前有一个U盘是做了window10的启动盘）安装步骤移除备份好的机械硬盘制作一个启动盘(win10系统不需要用软碟通UltraISO作启动盘)123456789（1）U盘最好是16g，USB3.0（2）清空U盘（格式化）（3）将ISO文件双击然后选中所有的文件将其复制到U盘（win10好像是不需要启动装置软件）（4）U盘保持插到电脑上（5）win10关闭快速启动选项，“电源选项”-》“选择电源按钮的功能”-》点击“更改当前不可用的设置”-》取消“启动快速启动”选项修改启动项（保持U盘插到电脑上！）1234567（1） 重启电脑，一直按F2（或者F1），进入BIOS（2） 点击方向箭头移动到Security，再向下移动到Secure Boot点击回车键，选择Disable（3） 点击方向箭头移动到boot,查看USB Boot是否是Enalbed（有的电脑没有USB Boot，在Devices模块的USB Setup选项修改）（4） 按F10保存退出安装123456789（1）上一个步骤保存后还是会进入windows，再重启一遍（U盘不要拔出来，如果光驱位有机械硬盘记得拔出来）（2）重启一直按F12，进入Boot Option Menu开机选择界面（3）选择U盘（USB3.0&#x2F;2.0这种标识）（4）等待一会进入启动选项，先选择&quot;try ubuntu without install&quot;,查看ubuntu是否可以安装在电脑上。（5）然后会进入Ubuntu桌面，如果觉得正常，可以安装，就点击左上角的&quot;install ubuntu 18.04LTS&quot;（版本选择最新的稳定版本）安装Ubuntu预配置12345678910111213141516171819202122（1）选择语言（建议中文或者英文，进入系统后可以切换语言）（2）键盘布局（建议选择汉语）（3）无线选项，暂时不连接wifi（4）更新和其他软件选项，选择“最小安装”（避免系统自动安装多余软件，加快速度）（5）安装类型选项，此处会选择是否删除之前的系统和硬盘所有的文件！ --- 如果避免出现问题，可以选择“其他选项”； --- 如果需要全新的安装，就选择删除之前的系统的选项；（我选择的这一项，然后系统会默认分区，就不需要之后两步）（6）开始分区，重新分区或者分一块空闲盘的内存（建议不少于20G） --- EFI分区，存放系统引导文件的引导分区（可以默认选择，或者512MB） --- 交换分区swap，逻辑分区，建议和电脑内存大小相同（例如我的是8G） --- 根分区“&#x2F;”，存放apt-get安装的软件，这个大小自己分配（建议内存大一点，以便安装软件有足够的空间） --- &quot;&#x2F;home&quot;分区，存放个人文件，剩余的磁盘空间可以都给它 （这样分区的话，如果重装Linux系统只需要格式化根分区，而保留“&#x2F;home”分区）（7）接着在安装类型选项界面下侧，有一个“安装启动引导器的设备”，选择刚刚分配好的EFI分区（8）选择“安装”安装进行时12（1）选择时区（2）设置用户名、密码安装后善后12345678910111213（1）如果安装后无法关机，直接长按电源键强制关机，然后再次重启，查看是否正常；（2）开机一直按F12进入开机选择界面选择Ubuntu&#x2F;或者一直按F2进入启动项修改第一启动项为Ubuntu（3）如果内存大于等于8G，交换分区swap分不分配也没有问题（4）显卡驱动不生效：开机按F2进入启动项，进入BIOS中关闭，再重启，显卡驱动就会生效了（这个应该是内核或者驱动和电脑的安全模式启动冲突了）（5）如果安装的时候一直卡在语言包下载，则点击右侧的skip跳过（6）如果vi编辑器输入错乱，编辑&#x2F;etc&#x2F;vim&#x2F;vimrc.tiny,将&#39;compatiable&#39;修改成&#39;nocompatiable&#39;,然后加入一行&#39;set backspace&#x3D;2&#39;,保存退出（可以sudo使用vim编辑，或者root权限使用gedit编辑）Ubuntu桌面主题修改Gnome桌面环境查看12345在登录界面的右上角查看小图标，选择GNOME图标或者安装：** sudo apt-get install gnome-shell （窗口管理程序）** sudo apt-get install gnome-tweak-tool修改主题(只在当前的登录用户)123456789（1）打开文件目录tweek tool，查看到Extensions（2）查看插件选项是否有User themes插件 --- 如果没有tweek tool, 执行sudo apt-get install gnome-tweek-tool --- 如果没有use themes, 执行sudo apt-get gnome-shell-extensions（3）登录GNOME主题官网(https:&#x2F;&#x2F;www.gnome-look.org)，选择主题下载（4）下载后解压放到“~&#x2F;.themes”目录，如果没有，自己创建（5）重新启动tweak tool（可能是重启窗口），然后在Appearance中选择“Shell theme”，修改即可（6）按”alt+F12“弹出命令窗口，输入“r”，重启Gnome桌面环境，查看修改后的主题图标和指针的主题123修改方式和上面一样，但是下载解压后的文件夹放置位置不同。图标： &#x2F;usr&#x2F;share&#x2F;icons&#x2F; （全局修改）指针： ~&#x2F;.icons&#x2F; （只限当前用户，即&#x2F;home&#x2F;account&#x2F;）ibus输入法有些软件不能输入中文12345ibus-daemon -drx此时终端不能编辑，重启终端之后就可以输入中文。终端主题zsh修改12345678910111213141. 查看当前shell主题echo $SHELL2. 查看shell列表cat &#x2F;etc&#x2F;shell3. 安装zsh再次查看列表会有zsh的存在4. 切换shellchsh -s &#x2F;bin&#x2F;shells5. 重启服务器添加开机启动程序的自定义命令12345vi /etc/rc.local例如ibus输入中文： ibus-daemonibus-daemon -dxr 重启ibus查看CPU使用情况cat /proc/cpuinfo查看磁盘内存使用情况12345df -hdf -i 检查inode使用情况sudo du / -h --max-depth=1","tags":[{"name":"linux","slug":"linux","permalink":"http://wizzie.top/tags/linux/"}]},{"title":"C++多字节char、bool、字符常量、浮点数","date":"2019-07-23T14:01:37.000Z","path":"2019/07/23/2019/190723_cpp_float/","text":"wchar_t程序需要处理的字符集可能无法用一个8位的字节表示，比如日文、汉字等此时有两种处理方法：编译器厂商将char定义16位的字节或者更长char表示8位的字节，另一种wchar_t表示宽字符类型，可以扩展字符集wchar_t类型是一种整数类型，因此可以有足够的空间表示系统使用的最大扩展字符集。iostream使用wcin和wcout表示宽字符的输入输出。C++11新增的char16_t和char32_tUnicode提供了一种表示各种字符集的解决方案。ASCII码是Unicode的子集。Unicode给每个字符指定一个编号 – 码点码点通常类似: U-222B (其中U表示这是一个Unicode字符，222B表示该字符的16进制编号)另一种针对多语言文本的编码标准是ISO 10646char16_t使用前缀u表示字符常量或者字符串常量；char32_t使用前缀U表示字符常量或者字符串常量；例如：12char16_t = u'q';char32_t = U'\\U0000222B';bool布尔类型C++将非零值解释为true，0是false此处bool表示真和假如果需要打印这个类型的值，可以直接使用%d打印判断是否为01234bool is_ready = false;bool start = -100; //truebool stop = 0; //false常量的符号名称 – const限定符符号名称指出了常量表示的内容（即使用符号来表示一个常量）符号常量的两种定义方式：#define A 10 (预处理处理)const int B = 10; (C++编译器处理，提供类型检查和作用域检查)例如：const int Months = 12; //首字母大写或者全部大写，表示常量（非通用约定）常量Months被初始化后，其值就被固定了，编译器不允许修改这个常量的值。如果强制修改，g++将指出程序试图给一个只读变量赋值。关键词const叫做限定符，因为它限定了声明的含义。创建常量如果在声明中没有提供具体值，则常量的值是不确定的，且无法修改。const_test.cpp12345const int pink = 10; //建议在声明中对常量初始化//TODO 不建议- const int toes;- toes = 10;const和define比较const相比#define定义常量来说， 优势：能够明确指定类型可以使用C++的作用域规则将其定义限制在特定的函数或者类文件中可以用于复杂的类型，例如数组、结构浮点数书写方式常用的小数点表示法12312.340.23192.023E表示法例如23.3E3表示23.3的三次方。 E可以形容很大或者很小的数。E后面是负数，表示除以N*10d.ddE+n表示小数点向右移动n位d.ddE-n表示小数点向左移动n位之所以称为浮点数，就是因为小数点的移动12344E334E-1031.23e1212.5e-5浮点类型float,double,long double这三个类型是按他们可以表示的有效数位和允许的指数最小范围来描述的。有效位表示数字当中有效的位数。比如14000的有效位数是2，因为可以精确到千位，其余三位只不过是占位符。有效位数不依赖小数点的位置。比如12.23的有效位数是4。C++和C对float的有效位数至少32位。double至少48位，且不少于float。long double至少和double一样多。可以从头文件cfloat和float.h找到系统的限制！floatnum.cpp12345678910111213141516#include&lt;iostream&gt;int main() &#123; using namespace std; cout.setf(ios_base::fixed, ios_base::floatfield); //fixed-point,将E转换成小数点显示 float tub = 10.0/3.0; double mint = 10.0/3.0; const float million = 1.0E6; cout &lt;&lt; \"float tub = \" &lt;&lt; tub &lt;&lt;endl; cout &lt;&lt; \"double mint = \" &lt;&lt; mint &lt;&lt;\"\\n\"; cout &lt;&lt; \"const float million = \" &lt;&lt; million &lt;&lt;endl; cout &lt;&lt; \"tub * million = \" &lt;&lt; tub*million &lt;&lt;endl; cout &lt;&lt; \"mint * million = \" &lt;&lt; mint*million&lt;&lt;endl; return 0;&#125;g++ floatnum.cpp编译生成a.out执行./a.out运行结果：12345float tub = 3.333333double mint = 3.333333const float million = 1000000.000000tub * million = 3333333.250000mint * million = 3333333.333333说明:cout会将3333333.250000直接打印成3333333.25 ，而cout.setf将覆盖这种行为；cout打印6位小数，他是iostream的一个类成员函数，能够精确的控制输出格式、字段宽度、小数位数、采用小数格式还是E格式显示；","tags":[{"name":"cpp","slug":"cpp","permalink":"http://wizzie.top/tags/cpp/"}]},{"title":"hexo文章加密方法","date":"2019-07-22T14:31:16.000Z","path":"2019/07/22/2019/190722-hexo-article-pass/","text":"直接修改JS存在问题：可能被破解。如果你的博客源码是存放在GitHub这样的开源库的话，那么恭喜你。别有用心之人可以通过查看你的GitHub仓库对应文章的md文件找到这个密码。themes/next/layout/custom/head.swig1234567891011#JavaScript&lt;script&gt; (function()&#123; if('&#123;&#123; page.password &#125;&#125;')&#123; if (prompt('请输入密码') !== '&#123;&#123; page.password &#125;&#125;')&#123; alert('密码错误'); history.back(); &#125; &#125; &#125;)();&lt;/script&gt;Hexo插件安装npm install --save hexo-blog-encrypt站点配置文件启用该插件_config.yml12encrypt: enable: true文章的头部添加上对应的字段，如 password, abstract, message123password: 是该博客加密使用的密码abstract: 是该博客的摘要，会显示在博客的列表页message: 这个是博客查看时，密码输入框上面的描述性文字123456789101112---title: 文章加密date: 2019-01-04T22:20:13.000Zcategory: 教程tags: - 博客 - Hexokeywords: 博客文章密码password: passabstract: 密码：passmessage: 输入密码，查看文章---","tags":[{"name":"hexo","slug":"hexo","permalink":"http://wizzie.top/tags/hexo/"}]},{"title":"git stash储藏命令","date":"2019-07-22T03:12:33.000Z","path":"2019/07/22/2019/190722-git-stashing/","text":"储藏（stashing）可以获取工作目录的中间状态，即被修改过的被追踪的文件和暂存的变更。 并将它保存在一个未完结变更的堆栈中，随时可以重新应用。储藏暂时未完成的工作如果你想在当前目录切换分支或者暂停正在进行的工作，而去先做另一件事。你就需要先储藏这些变更。为了向堆栈推送一个新的储藏，只需要执行：git stashgit status 可以查看到干净的工作目录；git stash list 可以查看储藏的列表;git stash show stash@{0} 可以查看某个储藏的修改信息如果工作目录不干净，包含已修改、未提交的文件，此时进行apply会给出归并冲突。git stash apply stash@{0} 可以请求某个储藏（如果不指定某个，会默认最近的储藏）对文件的变更被重新应用，但是被暂存的文件没有重新被暂存。需要告诉命令重新应用被暂存（commit）的变更。git stash apply --index 告诉命令重新应用被暂存的变更git stash drop stash@{0} 移除某个储藏取消储藏如果已经apply某个储藏，但是在修改一些代码后需要取消这个储藏，此时使用:git stash show -p stash@{0} | git apply -R可以达到取消该储藏的补丁效果。git stash branch &lt;name&gt;这条命令会根据最近的stash创建一个新的分支，然后删除最近的stash可以指定某个stash， 在后面加上 stash@{0}","tags":[{"name":"git","slug":"git","permalink":"http://wizzie.top/tags/git/"}]},{"title":"C++变量","date":"2019-07-21T13:11:47.000Z","path":"2019/07/21/2019/190721-cpp-variable/","text":"C++变量命名规则只能使用字母、数字、下划线第一个字符不能是数字区分大小写不能使用关键字以两个下划线或下划线和大写字母打头的名称保留给实现（编译器及其使用的资源）使用，以一个下划线开头的名称被保留给实现，用作全局标识符C++对命名的长度没有限制，但是有些平台会限制长度常用描述类型或者变量的命名方式，比如： str或者sz（表示以空字符结束的字符串）、b（表示布尔值）、p（表示指针）、c（表示单个字符）整型1C++的基本整型按照宽度递增（width,用于描述存储整型时候使用的内存量。内存越多，则越宽）的排序顺序分别是：char、short、int、long和C++11新增的long long。short、int、long、long long123456789101112计算机内存的基本单元是bit位。关表示0，开表示1.8位的内存内存块可以设置256种不同的组合（2的八次方）。因此，8位单元可以表示0-255或者-128到127。字节byte通常表示8位的内存单元。从这个意义来说，字节指的是描述计算机内存量的度量单位。1KB&#x3D;1024byte1MB&#x3D;1024KB在美国，基本字符集通常是ASCII和EBCDIC字符集，他们可以用8位表示一个字节。但是在国际编程中可能需要使用更大的字符集，如Unicode，因此有些实现可能使用16位甚至32位的字节。当前很多系统都使用最小长度，即short是16位。这为int提供了多种选择，可以是16位、24位、32位。甚至64位。因为long和long long至少长64位。short是short int的简称。long是long int的简称。short、int、long、long long都是符号类型。这意味着每种类型的取值范围，负值和正值几乎相同。示例代码：limits.cpp1234567891011121314151617181920212223242526#include&lt;iostream&gt;#include&lt;climits&gt; //use limits.h for older systemint main() &#123; using namespace std; int n_int = INT_MAX; short n_short = SHRT_MAX; //symbols defined in climts file long n_long = LONG_MAX; long long n_llong = LLONG_MAX; cout &lt;&lt; \"int is\"&lt;&lt; sizeof(n_int) &lt;&lt; \" bytes\" &lt;&lt; endl; cout &lt;&lt; \"short is\"&lt;&lt; sizeof(n_short) &lt;&lt; \" bytes\" &lt;&lt; endl; cout &lt;&lt; \"long is\"&lt;&lt; sizeof(n_long) &lt;&lt; \" bytes\" &lt;&lt; endl; cout &lt;&lt; \"long long is\"&lt;&lt; sizeof(n_llong) &lt;&lt; \" bytes\" &lt;&lt; endl; cout &lt;&lt; endl; cout &lt;&lt; \"Maximum value:\"&lt;&lt; endl; cout &lt;&lt; \"int : \" &lt;&lt; n_int &lt;&lt; endl; cout &lt;&lt; \"short : \" &lt;&lt; n_short &lt;&lt; endl; cout &lt;&lt; \"long : \" &lt;&lt; n_long &lt;&lt; endl; cout &lt;&lt; \"long long : \" &lt;&lt; n_llong &lt;&lt; endl; cout &lt;&lt; \"Minimum int value = \"&lt;&lt;INT_MIN&lt;&lt;endl; cout &lt;&lt; \"BNits per bytr = \"&lt;&lt; CHAR_BIT &lt;&lt;endl; return 0;&#125;执行结果：Results123456789101112int is 4 bytesshort is 2 byteslong is 8 byteslong long is 8 bytesMaximum value:int : 2147483647short : 32767long : 9223372036854775807long long : 9223372036854775807Minimum int value = -2147483648BNits per bytr = 8climits文件的符号常量符号常量极值意义CHAR_INTchar的位数CHAR_MAXchar的最大值CHAR_INTchar的最小值SCHAR_MAXsigned char的最大值UCHAR_MAXunsigned char的最大值SHRT_MAXshort的最大值USHRT_MAXunsigned short的最大值INT_MAXint的最大值LONG_MAXlong的最大值LLONG_MAXlong long的最大值初始化12345678910111213int n_int = INT_MAX; short year; year = 1492; //C++11的初始化方式int hamburgers = &#123;24&#125;; //set hanmburgers to 24int emus&#123;7&#125;; //设置emus为7int rheas = &#123;12&#125;; //设置rheas为12int rocs = &#123;&#125;; //设置为0int rocs&#123;&#125;;无符号类型123例如：short的unsigned无符号的表示范围是0-65535short的表示范围是-32768到+32767C++如何确定常量的类型12345678910111213例如：&#96;cout &lt;&lt; &quot;year&quot; &lt;&lt; 2019 &lt;&lt; endl;&#96;程序会把2019存储为int类型。整型后面的l或者L后缀表示为long；u或者U表示unsigned int常量；ul或者UL表示unsigned long；C++11还提供了ull, ULL, uLL和Ull。char字符型char是专门存储字符（字母或者数字）的类型。testChar123char ch = 'M';cout.put(ch);char的字面值123456ASCII系统中对应的数值编码：&#39;A&#39; &#x3D; 65&#39;a&#39; &#x3D; 97&#39;5&#39; &#x3D; 53&#39;&#39; &#x3D; 32 &#x2F;&#x2F;空格字&#39;!&#39; &#x3D; 33","tags":[{"name":"cpp","slug":"cpp","permalink":"http://wizzie.top/tags/cpp/"}]},{"title":"Hexo Next主题优化（二）","date":"2019-07-18T14:41:47.000Z","path":"2019/07/18/2019/190718-nextdebug-md/","text":"样式页脚foot优化爱心跳动在Next主题根目录的配置文件修改12345678910111213footer: # Specify the date when the site was setup. If not defined, current year will be used. since: 2019 # Icon between year and copyright info. icon: # Icon name in fontawesome, see: https://fontawesome.com/v4.7.0/icons/ # `heart` is recommended with animation in red (#ff0000). name: heartbeat # If you want to animate the icon, set it to true. animated: true # Change the color of icon, using Hex Code. color: \"#ff0000\"代码框样式代码框样式（复制按钮）在Next主题根目录的配置文件修改主题根目录_config.yml12345678910codeblock: # Manual define the border radius in codeblock, leave it blank for the default value: 1 border_radius: 10 //代码框边缘圆角 # Add copy button on codeblock copy_button: enable: true # Show text copy result show_result: true # Style: only 'flat' is currently available, leave it blank if you prefer default theme style: flat //复制按钮代码高亮主题主题根目录_config.yml1234# Code Highlight theme# Available values: normal | night | night eighties | night blue | night bright# https://github.com/chriskempson/tomorrow-themehighlight_theme: normaldiff样式12- printf(\"Hello World!\");+ printf(\"Hello_World!\");改变显示字体的颜色主要是侧边栏和文章主题内容（不包含标题）source/custom/custom.styl123456789101112131415161718//主页的阅读全文、主内容字体，不包含标题.main-inner &#123; p,span,a &#123;color: #ffb6c1;&#125; background-color: rgba(255,255,255,0.5);&#125;//上侧边栏.header-inner &#123; p,span,a &#123;color: #ffb6c1;&#125; background-color: rgba(255,255,255,0.5);&#125;// 下侧边栏字体颜色#sidebar &#123; p,span,a &#123;color: #ffb6c1;&#125; //改变颜色&#125;*/自动更换背景图片source/custom/custom.styl123456789101112131415161718body &#123; //以下是自动更换背景图片 background:url(https://source.unsplash.com/random/1600x900); background-repeat: no-repeat; background-attachment:fixed; background-position:50% 50%; background-size: 100% 100%;&#125;//更换侧边标题栏图片.site-meta &#123; //background: #BABABA //#5CADAD; //颜色 background-image:url(/images/subtitle1.jpg); //背景图片 background-position:50% 50%; background-size: 100% 100%; opacity: 0.9; //虚化 //p,span,a &#123;color: #3D3D3D;&#125; //字体颜色&#125;背景虚化（解决搜索框被虚化的问题）修改左侧栏菜单带搜索框的UI的背景颜色RGB值其余的使用透明度如此搜索框的就不会被虚化source/custom/custom.styl12345678910111213141516171819202122//主页的阅读全文、主内容字体，不包含标题.main-inner &#123; //background-color: rgba(255,255,255.0.8); opacity: 0.8;&#125;//上侧边栏.header-inner &#123; background-color: rgba(255,255,255,0.8); //只修改此处的背景颜色，以便搜索框不会被覆盖 //opacity: 0.75; //透明度，会覆盖到搜索框&#125;//上侧边栏的标题栏.site-meta &#123; background: #5CADAD; //颜色 //background-image:url(/images/huojinsi.jpg); //背景图片&#125;// 下侧边栏#sidebar &#123; //opacity: 0.8; //透明度&#125;note 便签主题配置文件搜索 note, 可设置风格和图标是否显示。存在部分样式无效的问题。主题根目录_config.yml123456789101112note: # Note tag style values: # - simple bs-callout old alert style. Default. # - modern bs-callout new (v2-v3) alert style. # - flat flat callout style with background, like on Mozilla or StackOverflow. # - disabled disable all CSS styles import of note tag. style: simple //默认样式 icons: true //图标 border_radius: 10 //圆角 # Offset lighter of background in % for modern and flat styles (modern: -12 | 12; flat: -18 | 6). # Offset also applied to label tag variables. This option can work with disabled note tag. light_bg_offset: 0示例：1&#123;% note default %&#125;default是类型还有以下几种&#123;% endnote %&#125;123456789101112131415&#123;% note default %&#125;default&#123;% endnote %&#125;&#123;% note primary %&#125;primary&#123;% endnote %&#125;&#123;% note success %&#125;success&#123;% endnote %&#125;&#123;% note info %&#125;info&#123;% endnote %&#125;&#123;% note warning %&#125;warning&#123;% endnote %&#125;&#123;% note danger %&#125;danger&#123;% endnote %&#125;&#123;% note %&#125;空样式&#123;% endnote %&#125;&#123;% note danger no-icon %&#125;danger no-icon&#123;% endnote %&#125;另一种写法：1&lt;div class=\"note danger\"&gt;&lt;p&gt;danger&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;note danger&quot;&gt;&lt;p&gt;danger&lt;/p&gt;&lt;/div&gt;文章编辑选项卡“tab” 为选项卡的名称，可以自定义，数字是几表示从第几个选项卡开始。非必须，若数值为 - 1 则隐藏选项卡内容。下载插件： npm i hexo-ruby-marks1234567891011&#123;% tabs tab,2 %&#125;&lt;!-- tab --&gt;this is tab1&lt;!-- endtab --&gt;&lt;!-- tab --&gt;this is tab2&lt;!-- endtab --&gt;&lt;!-- tab --&gt;this is tab3&lt;!-- endtab --&gt;&#123;% endtabs %&#125;结果：1234567891011&#123;% tabs tab,2 %&#125;&lt;!-- tab --&gt;this is tab1&lt;!-- endtab --&gt;&lt;!-- tab --&gt;this is tab2&lt;!-- endtab --&gt;&lt;!-- tab --&gt;this is tab3&lt;!-- endtab --&gt;&#123;% endtabs %&#125;引用（文章居中）123&#123;% cq %&#125;**there are test words**&#123;% endcq %&#125;123&#123;% cq %&#125;**there are test words in center**&#123;% endcq %&#125;在文章中插入 iframe1&#123;% iframe url [width] [height] %&#125;","tags":[{"name":"hexo","slug":"hexo","permalink":"http://wizzie.top/tags/hexo/"}]},{"title":"Use ADB","date":"2019-07-17T14:04:14.000Z","path":"2019/07/17/2019/190717_debug_adb_commonds/","text":"ADB是连接手机设备和电脑设备的调试桥。这种工具命令用于Android调试是基础而且重要的。OverviewInstall: sudo apt-get install adbFunction:123456通过adb可以管理、操作模拟器和设备，如安装软件、查看设备软硬件参数、系统升级、运行shell命令等。手机启动USB调试模式，设备连接电脑。注：我的手机一加6的USB调试模式打开方式如下： （1）在手机设置的关于手机找到版本号，双击七次打开开发者模式; （2）在开发者选项中打开USB调试选项; （3）设备连接Commonds基础命令如果设备连接&gt;1，可使用adb -s DevicesID + 其余部分命令CommondExplainadb devices查看设备连接情况adb version查看版本adb help查看帮助adb shell进入adb sehll命令adb shell top查看手机当前进程占用手机内存情况adb shell kill -3 pid杀掉进程adb logcat -v process &#124; grep 86078607是进程 PIDadb shell reboot -p关机adb reboot重启adb shutdown关机adb rootrootadb remount获取读写权限adb kill-server关闭adb服务adb start-server启动adb服务adb shell stop关闭设备请求adb shell start启动设备请求adb shell su root setenforce 0关闭seLinux模式网络相关设置CommondExplainadb shell ifconfig查看手机IPadb tcpip 5555设置手机tcpipadb connect IP连接IP屏幕display信息CommondExplainadb shell wm size查看分辨率adb shell set wm size设置分辨率软件操作命令安装软件:123adb install adb install &lt;apk文件路径&gt; :这个命令将指定的apk文件安装到设备上adb install -r -d APK卸载软件12adb uninstall &lt;软件名&gt;adb uninstall -k &lt;软件名&gt; 如果加 -k 参数,为卸载软件但是保留配置和缓存文件文件操作命令：从电脑上发送文件到设备,用push命令可以把本机电脑上的文件或者文件夹复制到设备(手机)1adb push &lt;本地路径&gt; &lt;远程路径&gt;从设备上下载文件到电脑,用pull命令可以把设备(手机)上的文件或者文件夹复制到本机电脑1adb pull &lt;远程路径&gt; &lt;本地路径&gt;录制视频12adb shell screenrecord sdcard&#x2F;test.mp4adb pull sdcard&#x2F;test.mp4 .日志操作命令常用日志命令CommondExplainadb logcat &#124; tee log1保存日志到本地并且打印到控制台adb logcat -v threadtime按照线程时间打印日志adb logcat -s System.out设置标签（某个字符串），过滤显示日志adb logcat -c清理已存在的日志adb logcat -g打印日志缓冲区的大小adb logcat &gt; home/mylog.txt日志保存到电脑某路径adb logcat -d -f /sdcard/mylog.txt保存到手机上指定位置（-d 日志显示在控制台）adb logcat -f /scard/log.txt输出到手机指定位置查看日志12345678910adb logcat日志等级（由上往下级别递增）：V verbase，级别最低，琐碎、不重要的日志信息D debug，调试信息I info，重要信息W warning，警告信息E error，错误信息F fatal，严重错误信息S slient，无记载查看帮助信息，获取该命令可配置的参数选项1adb logcat --help加载一个可使用的日志缓冲区供查看123456789adb logcat -b &lt;buffer&gt; buffer选项可以填为：radio 通信系统system 系统组件event event事件模块main java层kernel linux内核all 所有指定标签，指定级别过滤显示日志12adb logcat [tag:level]例如：adb logcat Test:I设置日志输入格式控制输出字段123456789101112adb logcat -v &lt;format&gt;format选项可以填为：brief 显示优先级&#x2F;标记和原始进程的PID（默认） process 只显示进程PIDtag 只显示优先级&#x2F;标记thread 只显示进程、线程、优先级&#x2F;标记rawtimelong例如：adb logcat -v processAPK包相关命令adb shell pm命令123456adb shell pm -l 列出包列表adb shell pm list packages 查看包名(同上)adb shell pm path &quot;PackageName&quot; 获取包的路径(可以通过dump SF获取当前的活动包名)adb shell pm list packages -f 查看包名对应的apk路径及名称adb shell dumpsys 列出手机所有apk的详细信息按名称检查正在运行的进程12adb shell pidof ”mediaserver“ &#x2F;&#x2F;查找正在运行的服务名的pidadb shell pidof com.android.phone &#x2F;&#x2F;获取进程号(如果找到此类进程，则返回PID，否则返回空字符串)获取当前ACTIVITY1adb shell dumpsys activity top|grep ACTIVITY命令启动指定Activity1adb shell am start -n com.android.systemui&#x2F;com.android.systemui.recents.RecentActivity模拟点击事件（点击屏幕）打开开发者选项的指针位置选项，点击屏幕即可获得XY坐标。1adb shell input tap x y获取设备信息参数12345678910adb shell getprop &quot;name&quot;例如：adb shellgetprop 查看机器的全部信息参数getprop ro.serialno 查看机器的序列号getprop ro.carrier 查看机器的CID号getprop ro.hardware 查看机器板子代号getprop ro.bootloader 查看SPL(Hboot)版本号setprop &lt;参数名&gt; &lt;参数值&gt; 设置某个参数输入命令inputinput后可以跟很多参数， text相当于输入内容，keyevent相当于手机物理或是屏幕按键，tap相当于touch事件，swipe相当于滑动。模拟的是滑动事件12345678910111213141516input swipe模拟的是滑动事件，需要将起始的坐标传进去,可以传入滑动时长adb shell input swipe &lt;x1&gt; &lt;y1&gt; &lt;x2&gt; &lt;y2&gt; [duration(ms)] (Default: touchscreen)例如：向左滑动：input swipe 600 800 300 800向右滑动：input swipe 300 800 600 800滑动：adb shell input swipe 100 100 200 200 300 &#x2F;&#x2F;从 100 100 经历300毫秒滑动到 200 200 长按：adb shell input swipe 100 100 100 100 1000 &#x2F;&#x2F;在 100 100 位置长按 1000毫秒输入文本内容1adb shell input &quot;text&quot; 输入文本内容adb shell am instrument …instrument为am命令的一个子命令。用于启动一个Instrumentation测试。各项参数：12345678910111213-r: 以原始形式输出测试结果；该选项通常是在性能测试时与[-e perf true]一起使用。-e name value: 提供了以键值对形式存在的过滤器和参数。例如：-e testFile &lt;filePath&gt;（运行文件中指定的用例）；-e package &lt;packageName&gt;（运行这个包中的所有用例）…… 有十几种。 -p file: 将分析数据写入 file。-w: 测试运行器需要使用此选项。例如:-w &lt;test_package_name&gt;&#x2F;&lt;runner_class&gt; ：&lt;test_package_name&gt;和&lt;runner_class&gt;在测试工程的AndroidManifest.xml中查找，作用是保持adb shell打开直至测试完成。--no-window-animation: 运行时关闭窗口动画。--user user_id | current: 指定仪器在哪个用户中运行；如果未指定，则在当前用户中运行。例如运行一个类中的所有用例：1adb shell am instrument -w -r -e class com.letv.leview.setproxy com.le.tcauto.uitest.test&#x2F;android.support.test.runner.AndroidJUnitRunnerDumpsys信息服务列表信息adb shell 进入shelldumpsys -l 查看所有正在运行的服务名service list 查看这些服务名称调用了哪个服务常见服务信息列表服务名类名功能gfxinfoGraphicsBinder图像SurfaceFlinger图像相关activityActivityManagerServiceAMS相关信息packagePackageManagerServicePMS相关信息windowWindowManagerServiceWMS相关信息inputInputManagerServiceIMS相关信息powerPowerManagerServicePMS相关信息batterystatsBatterystatsService电池统计信息batteryBatteryService电池信息alarmAlarmManagerService闹钟信息dropboxDropboxManagerService调试相关procstatsProcessStatsService进程统计cpuinfoCpuBinderCPUmeminfoMemBinder内存dbinfoDbBinder数据库appopsapp使用情况permission权限processinfo进程服务batteryproperties电池相关audio查看声音信息netstats查看网络统计信息diskstats查看空间free状态jobscheduler查看任务计划wifiwifi信息diskstats磁盘情况usagestats用户使用情况devicestoragemonitor设备信息dump方法1234567dumpsys &lt;service&gt; 打印具体某一项服务（service就是前面表格中的服务名）例如： （adb shell）dumpsys cpuinfo &#x2F;&#x2F;打印一段时间进程的CPU使用百分比排行榜dumpsys meminfo -h &#x2F;&#x2F;查看dump内存的帮助信息dumpsys package &lt;packagename&gt; &#x2F;&#x2F;查看指定包的信息dumpsys SurfaceFLinger &#x2F;&#x2F;查看SF服务dump窗口信息12adb shell dumpsys window windowsadb shell dumpsys window windows |grep Current &#x2F;&#x2F;当前窗口信息dump SurfaceFlinger信息方式：12345678910adb shell dumpsys SurfaceFlinger一般包含：1、layer的信息，layer一般对应于一个surface;2、opengl的信息。一般是跟gpu比较相关的参数，opengl是标准的接口;3、display。安卓支持三种类型的display，可以导出display当前的显示状态，也就是各个surface(layer)在各个display的显示属性;4、surfaceflinger管理graphis buffer的信息。主要是layer申请的帧数据内存;5、hwcomopser的如果实现dump接口也能知道hwcomposer的一些参数;6、gralloc的内存分配信息。如果gralloc有实现dump接口的话;7、合成方式、BufferLayer的树形结构信息连接DP 然后继续dump SurfaceFlinger信息123连接之前启动: adb shell dumpsys SurfaceFlinger --file --no-limit 断开后再次执行 adb shell dumpsys SurfaceFlinger --file --no-limit 并pull出来 adb pull &#x2F;data&#x2F;misc&#x2F;wmtrace&#x2F;dumpsys.txtGPU帧渲染数据1234567adb shell dumpsys gfxinfo 例如查看camera功能的渲染一帧所经过的各个阶段的耗时情况（单位毫秒）dumpsys gfxinfo **.camera 带上 framestats 参数可以获取最近的 120 帧数据：adb shell dumpsys gfxinfo **.camera framestatsfastboot模式进入fastboot（设备需要解锁）adb reboot bootloaderfastboot devices 检查设备刷机fastboot erase boot/system 清除区fastboot -wfastboot boot/system NewImg 烧录fastboot reboot","tags":[{"name":"ADB","slug":"ADB","permalink":"http://wizzie.top/tags/ADB/"}]},{"title":"在Android源码调试函数的堆栈","date":"2019-07-16T12:04:14.000Z","path":"2019/07/16/2019/190716_debug_ancdoid_callstack/","text":"在Android代码中可以通过了解函数的CallStack加速调试和分析过程，本文说明如何在Android运行时加入CallStack及Android P上的注意点。Java12import android.util.Log; Log.d(\"yourTag\", Log.getStackTraceString(new Exception()));C++Android 9以前CallStack call是被build进libutils, framework大部分service都是link了该lib，因此可以直接使用Callstack。Android 9开始后CallStack被build进libutilscallstack，因此直接使用Callstack会报undefined reference to ‘android::CallStack::CallStack 在Android.bp或Android.mk中加入”libutilscallstack” 即可.12345678910#include &lt;utils/CallStack.h&gt;ALOGD(\"dump callstack\");android::CallStack stack; stack.update(); stack.dump(\"yourTag\");// stack.log(\"yourTag\"); //callstack LOG_TAGMethods:adb logcat | grep yourTag","tags":[{"name":"android debug","slug":"android-debug","permalink":"http://wizzie.top/tags/android-debug/"}]},{"title":"Next Gemini主题优化","date":"2019-07-15T14:16:31.000Z","path":"2019/07/15/2019/190715_genminiChange-md/","text":"圆角设计主题修改成Gemini不同于Pisces, Gemini主题是卡片式布局_config.xml12345# Schemes#scheme: Muse#scheme: Mist#scheme: Piscesscheme: Gemini修改UIthemes/hexo-theme-next/source/css/_variables/Gemini.styl123// 修改主题页面布局为圆角$border-radius-inner = 15px 15px 15px 15px;$border-radius = 15px;背景动态效果下载依赖库12cd themes&#x2F;next git clone https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;theme-next-canvas-nest source&#x2F;lib&#x2F;canvas-nest修改配置文件_config.xml123456789# Canvas-nest# Dependencies: https://github.com/theme-next/theme-next-canvas-nestcanvas_nest: enable: true onmobile: true # display on mobile or not color: \"0,0,255\" # RGB values, use ',' to separate opacity: 0.5 # the opacity of line: 0~1 zIndex: -1 # z-index property of the background count: 99 # the number of lines","tags":[{"name":"hexo","slug":"hexo","permalink":"http://wizzie.top/tags/hexo/"}]},{"title":"Use VTS","date":"2019-07-15T14:04:14.000Z","path":"2019/07/15/2019/190715_debug_VTS/","text":"Overview来源为了能更快的将设备升级到新的Android版本，Android O 开始新引入了 Project Treble，Project Treble 适用于搭载 Android O 及后续版本的所有新设备。(1) Android 7.x 及更早版本中没有正式的Vendor层接口，因此每次更新系统都相对耗时和困难：(2) Android O 之后，Treble 提供了稳定的Vendor层接口，供设备制造商访问 Android 代码中特定于硬件的部分，这样就可以只更新框架层，减少升级系统带来的成本和困难：作用为了确保Vendor层实现的前向兼容性，新的Vendor层接口会由供应商测试套件 (VTS) 进行验证，该套件类似于兼容性测试套件 (CTS)。通过 CTS 测试，确保了 APP 与 Android Framework 之间有一致的调用接口（API），这使得 APP 开发者编写的同一款程序可以运行在不同系统版本（向前兼容）、不同硬件平台、不同厂商制造的不同设备上。VTS 类似 CTS，通过对 Vendor Interface 进行测试，确保同一个版本的 Android Framework 可以运行在不同 HAL 上，或不同 Android Framework 可以运行在 同一个 HAL 上。通过这样的 Framework / HAL 分离设计和接口一致性保证，也使得 8.0 版本之后的 Android 系统在进行升级时，可以直接对 Framework 进行升级而不用考虑 HAL 层的改动，从而缩短了用户手上设备得到系统升级 OTA 推送的时间。环境搭建12345678910111213141） 安装 Python 开发包$ sudo apt-get install python-dev2） 安装 Protocol Buffer 工具（协议缓冲区工具）$ sudo apt-get install python-protobuf$ sudo apt-get install protobuf-compiler3） 安装 Python 虚拟环境相关工具$ sudo apt-get install python-virtualenv$ sudo apt-get install python-pip4） 在设备上启用开发者模式并打开 USB 调试功能 5） 测试的时候需要网络测试前提GSIGSI介绍GSI是Google AOSP System Image的简称，在进行VTS测试之前，要使用user版本关闭verified boot后刷入GSI，VTS测试用的GSI由谷歌释放。如VTS r6版本的GSI镜像：GSI方法1234567GSI方法（先adb remount）：1）adb reboot bootloader 进入fastboot（或者音量键+电源键）2）fastboot devices 查看识别设备 3）fastboot erase system_a 擦除分区（需要userDebug版本）4）fastboot -w 擦除用户数据分区和缓存分区5）fastboot flash system_a xxx.img 刷入img6）fastboot reboot 重启123PS：在开发者选项查看oem unlocking选项是否已经解锁，如果未解锁可能是因为：（1）不是userDebugg版本； （2）可以通过执行fastboot flashing unlock和fastboot oem unlock，执行命令后需要选择音量 + 来确认unlock；测试命令（同CTS相似）启动vts(测试包从源码编译或者Google Android Developer官网查找)./vts-tradefed测试（跑测需要网络稳定）1234567891011全局测： run vts模块测试： run vts -m 模块名某个测试项： run vts -m &lt;模块名&gt; -t &lt;测试项名&gt;可用选项:run vts -s &lt;device_id&gt; --logcat-on-failure --screenshot-on-failure --shard-count &lt;shards&gt;&#39;-s &lt;device_id&gt;&#39;：可指定运行测试的设备&#39;--logcat-on-failure&#39;：当测试失败时捕获logcat&#39;--screenshot-on-failure&#39;：当测试失败时截取屏幕截图&#39;--shard-count &lt;shards&gt;&#39;：用多个设备上同时跑测，可节省时间查看list命令123查看设备信息： l d查看命令信息： l c查看跑测结果： l r","tags":[{"name":"VTS","slug":"VTS","permalink":"http://wizzie.top/tags/VTS/"}]},{"title":"Use CTS","date":"2019-07-15T14:04:14.000Z","path":"2019/07/15/2019/190715_debug_CTS/","text":"OverviewCTS就是兼容性测试为了确保Android应用能够在所有兼容Android的设备上正确运行，并且保持相似的用户体验，在每个版本发布之时，Android提供了一套兼容性测试用例集合（Compatibility Test Suite, CTS）来认证运行Android系统的设备是否完全兼容Android规范，并附带有相关的兼容性标准文档（Compatibility Definition Document, CDD）。从 http://source.android.com/compatibility/downloads.html（ 网络需要能进google）处下载最新的兼容性测试用例集合，并解压。大部分是基于Junit和仪表盘技术编写的。还扩展了自动化测试过程，可以自动执行用例，自动收集和汇总测试结果。CTS采用XML配置文件的方式将这些测试用例分组成多个测试计划（plan）,第三方也可以创建自己的plan。Achieve CTS Packagegoogle官方下载Link: http://source.android.com/compatibility/downloads.html编译源码1234CTS的代码在Android源码CTS目录下。 make cts -j4 编译好cts后生成的文件位置： &#x2F;out&#x2F;host&#x2F;linux-x86&#x2F; 在该目录下包含tools和rtestcases两个目录。环境配置Android 调试桥 (adb)手机不能休眠123设置-&gt;开发人员选项：打开Settings-&gt;Accessibility-&gt;Developer options-&gt;USB debugging(USB 调试)打开Settings-&gt;Accessibility-&gt;Developer options-&gt;Stay Awake（保持唤醒）系统语言最好保证英语1设置手机语言为英语：Setting-&gt;Language&amp;input-&gt;language-&gt;English(United States)。测试命令在CTS/tools目录下执行./cts-tradefed 进入cts-tf,进入的打印信息会提示连接到手机设备！123run cts --help 查看帮助help listhelp run测试模块run cts -s DeviceID -m CtsMediaTestCases （在testcases目录下找apk）测试模块下的一小模块： cts-tf &gt; run cts -m CtsMediaTestCases -a armeabi-v7a测试模块某个testcaserun cts -s DeviceID -m &lt;模块名&gt; -t &lt;具体fail项&gt;123456789101112131415161718192021run cts -兼容性（compatibility）选项：--include-filter 请求包含的模块过滤器--exclude-filter 请求排出的模块过滤器（默认一大堆）--subplan 运行子计划--serial&#x2F;-s &lt;deviceID&gt; 在特定设备上运行 CTS-d&#x2F;--device &lt;devicedID&gt; 设备-r &#x2F;--retry 重新尝试当前的session--skip-system-status-check + ...Check 跳过系统状态检查-–skip-preconditions&#x2F;-o 跳过一些预置条件的检查，可以减少测试的时间–-skip-device-info 跳过手机信息的收集，可以减少测试的时间--continue-session &lt;sessionId&gt; 继续被中断的任务查看测试结果l r查看等待执行的任务l c查看所有执行的任务l i12345678l -d 设备r 结果c 当前被等待执行的命令p 所有可获得的planm 所有可获得的modulei 所有调用的线程（查看任务是否结束）config 所有可知的配置全局测试run cts –plan CTS继续被中断的测试l rrun cts –continue-session sessionID重新跑测某个任务的失败项（节约时间）l rrun cts retry -s DeviceID –retry sessionID测试结果测试结束后在/results文件夹中，会看到以日期和时间命名的文件夹用于保存执行过的测试结果。还有一个同名的zip文件保存同样的内容。测试过程中的自动录log，测试结束后log自动保存在/logs里边以日期和时间命名的文件夹中。在测试结果文件夹中，所有的测试结果是以XML的形式保存的。通常测试结果网页分成“Device Information”、“Test Summary”、“Test Summary by Package”、“Test Failures(xx)”和“Detailed Test Report”等四个区域。","tags":[{"name":"CTS","slug":"CTS","permalink":"http://wizzie.top/tags/CTS/"}]},{"title":"VS code常用插件","date":"2019-07-15T14:04:14.000Z","path":"2019/07/15/2019/190715_vscode_plugins/","text":"markdown相关插件markdown PDF可以转换md文件成pdf, html, png, jpg文件markdownlint可以提示markdown语法规范markdown toc可以生成md文件的目录markdown preview enhanced实时预览，但是在vscode自带预览markdown文件效果，必要性不大。UML建模插件plantUML使用一种便捷的设计语言plantUML， 参考http://plantuml.com/基本使用方法参考：https://www.jianshu.com/p/30f6a9c06083","tags":[{"name":"vs code","slug":"vs-code","permalink":"http://wizzie.top/tags/vs-code/"}]},{"title":"Hexo Next主题优化","date":"2019-07-13T14:04:14.000Z","path":"2019/07/13/2019/190713_hexo-improve/","text":"首页预览加入图片在根目录下的images文件夹加入图片12345678---title: Hexo Next主题优化categories: Webtags: - Hexophotos: - /images/background.jpg---Hexo-lazyload-image图片懒加载下载插件npm install hexo-lazyload-image –save修改_config.xml_config.xml1234lazyload: enable: true onlypost: false loadingImg: # eg. ./images/loading.png文章插入图片1. 把主页配置文件_config.yml 里的post_asset_folder:这个选项设置为true在你的hexo目录下执行这样一句话npm install hexo-asset-image –save，这是下载安装一个可以上传本地图片的插件等待一小段时间后，再运行hexo n “xxxx”来生成md博文时，/source/_posts文件夹内除了xxxx.md文件还有一个同名的文件夹;最后在xxxx.md中想引入图片时，先把图片复制到xxxx这个文件夹中，然后只需要在xxxx.md中按照markdown的格式引入图片：![你想输入的替代文字](图片名.jpg)例如![loading](background.jpg)result：loadingNext主题图片浏览放大功能fancybox1234567891011Step1:cd next&#x2F;source&#x2F;libgit clone https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;theme-next-fancybox3 fancyboxps:注意fancybox和next&#x2F;_config.uml里面的名字保持一致step2：更改next&#x2F;_config.uml文件fancybox： trueHexo NexT主题添加点击爱心效果创建js文件在/themes/next/source/js/src下新建文件 clicklove.js ，接着把该链接下的代码拷贝粘贴到 clicklove.js 文件中。代码如下：1!function(e,t,a)&#123;function n()&#123;c(\".heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;\"),o(),r()&#125;function r()&#123;for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText=\"left:\"+d[e].x+\"px;top:\"+d[e].y+\"px;opacity:\"+d[e].alpha+\";transform:scale(\"+d[e].scale+\",\"+d[e].scale+\") rotate(45deg);background:\"+d[e].color+\";z-index:99999\");requestAnimationFrame(r)&#125;function o()&#123;var t=\"function\"==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e)&#123;t&amp;&amp;t(),i(e)&#125;&#125;function i(e)&#123;var a=t.createElement(\"div\");a.className=\"heart\",d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()&#125;),t.body.appendChild(a)&#125;function c(e)&#123;var a=t.createElement(\"style\");a.type=\"text/css\";try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName(\"head\")[0].appendChild(a)&#125;function s()&#123;return\"rgb(\"+~~(255*Math.random())+\",\"+~~(255*Math.random())+\",\"+~~(255*Math.random())+\")\"&#125;var d=[];e.requestAnimationFrame=function()&#123;return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e)&#123;setTimeout(e,1e3/60)&#125;&#125;(),n()&#125;(window,document);修改_layout.swig在\\themes\\next\\layout_layout.swig文件末尾添加：12&lt;!-- 页面点击小红心 --&gt;&lt;script type=\"text/javascript\" src=\"/js/src/clicklove.js\"&gt;&lt;/script&gt;Next网站标题栏颜色打开themes/next/source/css/_custom/custom.styl，在里面新增如下代码：123.site-meta &#123; background: $blue; //天空的颜色，和我的眼镜是绝配&#125;博客背景图片打开上述相同文件1234567body &#123; background-image:url(/images/background.jpg); background-repeat: no-repeat; background-attachment:fixed; background-position:50% 50%; background-size: 100% 100%;&#125;背景虚化12345678910&#x2F;&#x2F; 修改主体透明度.main-inner &#123; background: #fff; opacity: 0.85;&#125;&#x2F;&#x2F; 修改菜单栏透明度.header-inner &#123; opacity: 0.85;&#125;添加资源链接菜单(1) hexo new page &quot;resources&quot;(2) 编辑resources文件夹下的md页面,将类型设置为resources，主题将自动为这个页面显示所有分类。1234567title: resourcesdate: 2019-07-14 13:05:38type: &quot;resources&quot;comments: false---(3) 在菜单中添加链接,编辑主题的_config.yml，在menu中的添加如下:menu:resources: /resources || download123456789101112131415(4) 新添加的菜单需要翻译对应的中文,打开hexo&gt;theme&gt;next&gt;languages&gt;zh-Hans.yml，在menu下添加：&#96;&#96;&#96;cssmenu: home: 首页 archives: 归档 categories: 分类 tags: 标签 about: 关于 search: 搜索 schedule: 日程表 sitemap: 站点地图 commonweal: 公益404 resources: 资源阅读全文设置在网站首页只显示每篇文章的部分内容，不要全部内容都展示出来。解决要解决这个问题有两个方法：一是修改 _config.yml 文件设置，而是直接在你的 md 中加一句代码即可。第一种方法用文本编辑器打开 themes/next 目录下的 _config.yml 文件，找到这段代码：Automatically Excerpt. Not recommend.Please use in the post to control excerpt accurately.123456auto_excerpt: enable: false length: 150把 enable 的 false 改成 true 就行了，然后 length 是设定文章预览的文本长度。修改后重启 hexo 就ok了。第二种方法在你写 md 文章的时候，可以在内容中加上 ，这样首页和列表页展示的文章内容就是 之前的文字，而之后的就不会显示了。效果上面两种方式展示出来的效果是不一样的。第一种修改 _config.yml 文件的效果是会格式化你文章的样式，直接把文字挤在一起显示，最后会有 …标签云位置：\\blog\\themes\\next\\layout\\page.swig原来：1&#123;&#123; tagcloud(&#123;min_font: theme.tagcloud.min, max_font: theme.tagcloud.max, amount: theme.tagcloud.amount, color: true, start_color: theme.tagcloud.start, end_color: theme.tagcloud.end&#125;) &#125;&#125;修改成:(else)12345&#123;% if not theme.tagcloud %&#125; &#123;&#123; tagcloud(&#123;min_font: 12, max_font: 30, amount: 200, color: true, start_color: '#ccc', end_color: '#111'&#125;) &#125;&#125;&#123;% else %&#125; &#123;&#123; tagcloud(&#123;min_font: 13, max_font: 31, amount: 1000, color: true, start_color: '#9733EE', end_color: '#FF512F'&#125;) &#125;&#125;&#123;% endif %&#125;与主题样式一致的 404 页面new page12cd &lt;blog-path&gt; #定位到 Hexo 博客目录hexo new page &quot;404&quot;index.md12345---title: 404 Not Foundcomments: falsepermalink: &#x2F;404---使用hexo-neat插件压缩页面以提高响应速度安装hexo-neat插件npm install hexo-neat --save在站点配置文件中添加配置下边是我自己站点的相关配置，直接添加到站点配置文件_config.yml的末尾就可以。可以安装自己的需求去自定义那些文件需要压缩,主要是有些js可能压缩后会失效。123456789101112131415161718192021222324# 博文压缩neat_enable: true# 压缩htmlneat_html: enable: true exclude:# 压缩css neat_css: enable: true exclude: - '**/*.min.css'# 压缩jsneat_js: enable: true mangle: true output: compress: exclude: - '**/*.min.js' - '**/jquery.fancybox.pack.js' - '**/index.js' - '**/love.js' //此处忽略压缩点击桃心的特效# 压缩博文配置结束菜单上显示数目在next的主题配置文件中找到下面内容，设置为true即可123menu_settings: icons: true badges: true # 显示文章数开关Next主题代码块加入复制功能在Next主题的配置文件，将copy_button打开_congig.xml12345678910codeblock: # Manual define the border radius in codeblock, leave it blank for the default value: 1 border_radius: # Add copy button on codeblock copy_button: enable: true # Show text copy result show_result: true # Style: only 'flat' is currently available, leave it blank if you prefer default theme style:修改侧边栏宽度1234# Manual define the sidebar width. If commented, will be default for: # Muse | Mist: 320 # Pisces | Gemini: 240 #width: 300Hexo博客NexT主题下添加文章边框阴影效果themes/next/source/css/_custom/custom.styl123456789101112.post &#123; margin-top: 60px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5);&#125;.main-inner &#123; background: #fff; opacity: 0.85;&#125;保留上次阅读时候的位置_config.xml12# Automatically saving scroll position on each post / page in cookies.save_scroll: true界面对齐方式_confi.xml12345# Set the text alignment in the posts.text_align: # Available values: start | end | left | right | center | justify | justify-all | match-parent desktop: justify mobile: justify","tags":[{"name":"hexo","slug":"hexo","permalink":"http://wizzie.top/tags/hexo/"}]},{"title":"Hexo Next主题集成gitalk评论系统","date":"2019-07-13T14:04:14.000Z","path":"2019/07/13/2019/190713_use_gitalk/","text":"在我的Github+hexo搭建的网站中，使用github的gitalk评论系统。gitalk官方示例、官方文档register app in github在Github注册一个application，点击创建参数说明：Application name： # 应用名称，随意Homepage URL： # 网站URL，如https://wizzie.top/Application description # 描述，随意Authorization callback URL：# 网站URL，https://wizzie.top/创建完成后记录好Clien信息Client ID、Client Secret配置_config.yml在主题配置文件next/_config.yml中添加如下内容：12345678gitalk: enable: true githubID: github帐号 # 例：asdfv1929 repo: 仓库名称 # 例：asdfv1929.github.io ClientID: Client ID ClientSecret: Client Secret adminUser: github帐号 #指定可初始化评论账户 distractionFreeMode: true提交hexo cleanhexo ghexo deploy以下在最新的Next代码库都已经添加，无需修改。修改gitalk.swig文件（最新的Next版本已有）修改/layout/_third-party/comments/gitalk.swig文件，添加（最新的Next版本已有，无需修改）：12345678910111213141516&#123;% if page.comments &amp;&amp; theme.gitalk.enable %&#125; &lt;link rel=\"stylesheet\" href=\"https://unpkg.com/gitalk/dist/gitalk.css\"&gt; &lt;script src=\"https://unpkg.com/gitalk/dist/gitalk.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; var gitalk = new Gitalk(&#123; clientID: '&#123;&#123; theme.gitalk.ClientID &#125;&#125;', clientSecret: '&#123;&#123; theme.gitalk.ClientSecret &#125;&#125;', repo: '&#123;&#123; theme.gitalk.repo &#125;&#125;', owner: '&#123;&#123; theme.gitalk.githubID &#125;&#125;', admin: ['&#123;&#123; theme.gitalk.adminUser &#125;&#125;'], id: location.pathname, distractionFreeMode: '&#123;&#123; theme.gitalk.distractionFreeMode &#125;&#125;' &#125;) gitalk.render('gitalk-container') &lt;/script&gt;&#123;% endif %&#125;comments.swig（最新的Next版本已有）修改/layout/_partials/comments.swig，添加内容如下，与前面的elseif同一级别上：12&#123;% elseif theme.gitalk.enable %&#125; &lt;div id=\"gitalk-container\"&gt;&lt;/div&gt;修改index.swig（最新的Next版本已有）修改layout/_third-party/comments/index.swig，在最后一行添加内容：1&#123;% include 'gitalk.swig' %&#125;修改gitalk.styl（最新的Next版本已有）新建/source/css/_common/components/third-party/gitalk.styl文件，添加内容：1234.gt-header a, .gt-comments a, .gt-popup a border-bottom: none;.gt-container .gt-popup .gt-action.is--active:before top: 0.7em;third-party.styl（最新的Next版本已有）修改/source/css/_common/components/third-party/third-party.styl，在最后一行上添加内容，引入样式：1@import \"gitalk\";常见问题GET https://api.github.com/user 401 (Unauthorized)未找到相关的 Issues 进行评论未找到解决办法https://github.com/gitalk/gitalk/issues/183","tags":[{"name":"hexo","slug":"hexo","permalink":"http://wizzie.top/tags/hexo/"}]},{"title":"C++ 编译和概述","date":"2019-07-11T13:01:33.000Z","path":"2019/07/11/2019/190711_cpp-basic/","text":"g++编译工具linux编译的四个阶段在Linux下编译程序分为以下4个阶段：预处理：编译处理宏定义等宏命令（eg:#define）——生成后缀为“.i”的文件编译：将预处理后的文件转换成汇编语言——生成后缀为“.s”的文件汇编：由汇编生成的文件翻译为二进制目标文件——生成后缀为“.o”的文件连接：多个目标文件（二进制）结合库函数等综合成的能直接独立执行的执行文件——生成后缀为“.out”的文件Linux下执行gcc与g++编译C++文件的差别后缀为.c的，gcc把它当作是C程序（cc/cpp才判定为C++源程序），而g++当作是c++程序gcc无法进行库文件的连接，即无法编译完成步骤4；而g++则能完整编译出可执行文件。（实质上，g++从步骤1-步骤3均是调用gcc完成，步骤4连接则由自己完成），如以下：1234567 gcc -E 执行到步骤1，只处理宏命令，需要用重定向生成文件 gcc -S 执行到步骤2，生成文件.s gcc -c 执行到步骤3，生成文件.o g++ 分别编译于连接 .cc文件与.o文件Tips后缀为.c的，gcc把它当作是C程序，而g++当作是c++程序；后缀为.cpp的，两者都会认为是c++程序，注意，虽然c++是c的超集，但是两者对语法的要求是有区别的。编译阶段，g++会调用gcc，对于c++代码，两者是等价的，但是因为gcc命令不能自动和C＋＋程序使用的库联接，所以通常用g++来完成链接，为了统一起见，干脆编译/链接统统用g++了，这就给人一种错觉，好像cpp程序只能用g++似的。安装使用g++除了code blocks, Vs code，可以更简单的使用gcc g++编译c和c++语言。安装：sudo apt-get install g++编译：g++ getinfo.cpp 生成a.out,使用./a.out执行或者g++ getinfo.cpp -o getinfo 生成getinfo，使用./getinfo执行input and output12345678910111213141516171819//getinfo .cpp -- input and output#include&lt;iostream&gt;int main() &#123; using namespace std; int carrots; cout &lt;&lt; \"How many carrots do you have?\" &lt;&lt; endl; cin &gt;&gt; carrots; cout &lt;&lt; \"Here are two more.\"; carrots = carrots + 2; cin.get(); cin.get(); //添加两句，第一句按enter键位输入数字，第二条让程序暂停 //FIXME the next line concatenates output cout &lt;&lt; \"Now you have\" &lt;&lt; carrots &lt;&lt; \" carrots.\" &lt;&lt; endl; return 0;&#125;cin &gt;&gt; carrots;从键盘输入数值赋给变量carrotscout &lt;&lt; &quot;Now you have&quot; &lt;&lt; carrots &lt;&lt; &quot; carrots.&quot; &lt;&lt; endl;使用cout拼接，endl换行。类class类是c++种面向对象编程OOP的核心概念之一类是用户定义的一种数据类型定义类，需要描述它能够表达什么信息和可对数据执行那哪些操作类定义描述的是数据格式及其用法，而杜希昂是根据数据格式规范创建的实体例如cout是一个ostream类对象，cin是一个istream类对象，都是在iostream中定义的。函数函数创建C++程序的模块，分为两种：有返回值的和无返回值的。例如：1234#include&lt;cmath&gt;double x;x = sqrt(6.25);","tags":[{"name":"cpp","slug":"cpp","permalink":"http://wizzie.top/tags/cpp/"}]},{"title":"Hexo Next主题集成Valine评论系统","date":"2019-07-09T14:04:14.000Z","path":"2019/07/09/2019/190709_use_valine/","text":"注册leanCloud官网账号为了避免混乱，可以和github使用同样的账号信息。注册app邮箱验证后，注册一个APP应用：alonealive.github.com_appAPP设置的安全中心选上数据存储，以及添加绑定的web域名。配置_config.yml12345678910111213valine: enable: true # When enable is set to be true, leancloud_visitors is recommended to be closed for the re-initialization problem within different leancloud adk version. appid: vh******sz # your leancloud application appid appkey: Cf***2xz # your leancloud application appkey notify: true # mail notifier, See: https://github.com/xCss/Valine/wiki verify: false # Verification code placeholder: Just go go # comment box placeholder avatar: wavatar # gravatar style 评论头像 guest_info: nick,mail,link # custom comment header pageSize: 10 # pagination size language: zh-cn # language, available values: en, zh-cn visitor: false # leancloud-counter-security is not supported for now. When visitor is set to be true, appid and appkey are recommended to be the same as leancloud_visitors' for counter compatibility. Article reading statistic https://valine.js.org/visitor.html comment_count: true # if false, comment count will only be displayed in post page, not in home page评论头像，点解链接查看添加邮件提醒参考：Valine评论系统中的邮件提醒设置在邮件模板中，将重置密码的模板修改一下，邮件内容修改成：12345&lt;p&gt;Hi, &#123;&#123;username&#125;&#125;&lt;/p&gt;&lt;p&gt;你在 &#123;&#123;appname&#125;&#125; 的评论收到了新的回复，请点击查看：&lt;/p&gt;&lt;p&gt;&lt;a href=\"你的网址首页链接\" style=\"display: inline-block; padding: 10px 20px; border-radius: 4px; background-color: #3090e4; color: #fff; text-decoration: none;\"&gt;马上查看&lt;/a&gt;&lt;/p&gt;保存后，提交代码发布网站测试。去除标签页和类别页的分类在他们的suource目录下的md文件添加：comments: false例如分类页面：123456---title: categoriesdate: 2019-05-08 22:40:04type: \"categories\"comments: false---","tags":[{"name":"hexo","slug":"hexo","permalink":"http://wizzie.top/tags/hexo/"}]},{"title":"hexo的admin后台搭建","date":"2019-07-08T14:04:14.000Z","path":"2019/07/08/2019/190708_hexo的admin后台搭建/","text":"hexo-admin配置后台查看github源项目： https://github.com/jaredly/hexo-admin部署步骤123npm install --save hexo-adminhexo server -dopen http://localhost:4000/admin/hexo的_config.xml配置123456admin: username: zoro password_hash:be121740bf988b2225a313fa1f107ca1 secret: hey hexo deployCommand: './admin_script/hexo-generate.sh' # expire: 60*1hexo-myadmin查看文档： https://www.npmjs.com/package/hexo-myadmin使用方法12345678910# install hexo-myadmin npm i hexo-myadmin --save # start server with global hexo-cli hexo server # or with pm2 as deamon pm2 start node_modules&#x2F;.bin&#x2F;hexo -- server # visit localhost:4000&#x2F;admin优点使用轻量级的插件，而且简化了界面，编辑书写方便，功能便捷待完善关于图片的功能不够完善，需要输入地址，这对于同一个内网不通的机器不方便。hexo-local-admin文档： https://www.npmjs.com/package/hexo-local-admin使用方法：123451. installnpm install -g hexo-local-admin2. use commandhexo-admin -hhexo-heyhttps://github.com/nihgwu/hexo-hey使用方法npm install hexo-hey –save优点可以粘贴图片缺点部分文章没有编辑的UI，原因待查","tags":[{"name":"hexo","slug":"hexo","permalink":"http://wizzie.top/tags/hexo/"}]},{"title":"Use hexo and github to build website","date":"2019-07-05T14:04:14.000Z","path":"2019/07/05/2019/190705_use_hexo/","text":"这篇文章主要是讲述如何结合hexo和github建站。使用hexo+github建站，相对减少开发时间和成本。相关Link： hexo官方文档、github建站Issue、我的网站1. 安装node.js2. 配置hexonpm install -g hexo-cli3. 初始化hexo工作目录1. mkdir hexo //新建文件夹2. hexo init hexo //初始化hexo工作目录note: 可能需要安装一些依赖，按照log的指示配置。12生成目录文件夹：TODO4. 编译运行登录1. hexo g //build2. hexo s //生成服务端使用http://localhost:4000/ 即可查看结果。本地测试也可以使用127.0.0.1:4000访问，或者内网IP:4000 方式访问（ipconfig查看）note: 如果有修改，可以使用hexo clean清除public等文件，再重新编译运行。结果文件是public文件夹。5. 发布到github1. 在根目录的_config.yml（非theme主题文件下的配置文件）修改1234deploy: type: git repository: git@github.com:***&#x2F;***.github.com.git branch: master2. 安装插件npm install hexo-deployer-git –save3. 发布到githubhexo deploy4. 查看结果，例如我的网站wizzie.topnote: 需要在你购买域名的万网进行域名绑定解析到github，please google by yourseflf。6. 修改配置_config.yml1. 修改主题推荐主题： 官方主题、Next套装主题（不需要安装基础依赖插件，简单配置使用）例如下载Next主题仓库，然后在_config.yml中修改，编译后查看结果即可：12345# Extensions## Plugins: https:&#x2F;&#x2F;hexo.io&#x2F;plugins&#x2F;## Themes: https:&#x2F;&#x2F;hexo.io&#x2F;themes&#x2F;## theme: landscapetheme: next2. 修改博主信息12345678# Sitetitle: 博客 &#x2F;&#x2F;标题subtitle: &#x2F;&#x2F;子标题description:keywords:author: wizzie &#x2F;&#x2F;作者language: zh-CN &#x2F;&#x2F;网站语言，可在theme目录的language查看timezone:3. hexo文件夹结构123456789# Directorysource_dir: source &#x2F;&#x2F;资源文件夹public_dir: public &#x2F;&#x2F;网站构建生成tag_dir: tags &#x2F;&#x2F;标签archive_dir: archives &#x2F;&#x2F;日期归档category_dir: categories &#x2F;&#x2F;分类（使用hexo page &quot;categories&quot;生成）code_dir: downloads&#x2F;code &#x2F;&#x2F;下载i18n_dir: :lang &#x2F;&#x2F;语言skip_render: README.md &#x2F;&#x2F;可以避免该文件构造成html4. 主页配置（分页大小、排序规则）12345678# Home page setting# path: Root path for your blogs index page. (default &#x3D; &#39;&#39;)# per_page: Posts displayed per page. (0 &#x3D; disable pagination)# order_by: Posts order. (Order by date descending by default)index_generator: path: &#39;&#39; per_page: 10 order_by: -date5. 网站日期格式123456# Date &#x2F; Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http:&#x2F;&#x2F;momentjs.com&#x2F;docs&#x2F;#&#x2F;displaying&#x2F;format&#x2F;date_format: YYYY-MM-DDtime_format: HH:mm:ss7. 修改theme的_config.yml(Next主题)1. 主题选择12345# Schemes#scheme: Muse#scheme: Mistscheme: Pisces#scheme: Gemini2. 菜单配置1234567891011121314menu: home: &#x2F; || home archives: &#x2F;archives&#x2F; || archive categories: &#x2F;categories&#x2F; || th tags: &#x2F;tags&#x2F; || tags about: &#x2F;about&#x2F; || user #schedule: &#x2F;schedule&#x2F; || calendar #sitemap: &#x2F;sitemap.xml || sitemap #commonweal: &#x2F;404&#x2F; || heartbeat# Enable &#x2F; Disable menu icons &#x2F; item badges.menu_settings: icons: true badges: false3. LOGO修改1234567favicon: small: &#x2F;images&#x2F;favicon-16x16-next.png medium: &#x2F;images&#x2F;favicon-32x32-next.png apple_touch_icon: &#x2F;images&#x2F;apple-touch-icon-next.png safari_pinned_tab: &#x2F;images&#x2F;logo.svg #android_manifest: &#x2F;images&#x2F;manifest.json #ms_browserconfig: &#x2F;images&#x2F;browserconfig.xml4. 页脚配置12345678910111213141516171819202122232425262728293031323334footer: # Specify the date when the site was setup. If not defined, current year will be used. since: 2019 # Icon between year and copyright info. icon: # Icon name in fontawesome, see: https:&#x2F;&#x2F;fontawesome.com&#x2F;v4.7.0&#x2F;icons&#x2F; # &#96;heart&#96; is recommended with animation in red (#ff0000). name: user &#x2F;&#x2F;图标可以到提供的网站修改 # If you want to animate the icon, set it to true. animated: false &#x2F;&#x2F;动画效果 # Change the color of icon, using Hex Code. color: &quot;#808080&quot; &#x2F;&#x2F;图标颜色 # If not defined, &#96;author&#96; from Hexo main config will be used. copyright: powered: # Hexo link (Powered by Hexo). &#x2F;&#x2F;关闭hexo强力驱动显示 enable: false # Version info of Hexo after Hexo link (vX.X.X). version: false theme: # Theme &amp; scheme info link (Theme - NexT.scheme). &#x2F;&#x2F;关闭next主题显示 enable: false # Version info of NexT after scheme info (vX.X.X). version: false # Beian icp information for Chinese users. In China, every legal website should have a beian icp in website footer. # http:&#x2F;&#x2F;www.beian.miit.gov.cn beian: enable: false icp:5. 主页阅读全文设置12345# Automatically Excerpt (Not recommend).# Use &lt;!-- more --&gt; in the post to control excerpt accurately.auto_excerpt: enable: true &#x2F;&#x2F;修改成true length: 150 &#x2F;&#x2F;显示字数6. 评论系统配置文件提供了一些畅言、Valine(要指定next版本)、gitment、gitalk等，选择其中一个进行配置，配置方法见另一篇文章。12345678910111213141516171819# ---------------------------------------------------------------# Comments and Widgets# See: https:&#x2F;&#x2F;theme-next.org&#x2F;docs&#x2F;third-party-services&#x2F;comments-and-widgets# ---------------------------------------------------------------.......# Gitalk# Demo: https:&#x2F;&#x2F;gitalk.github.iogitalk: enable: true github_id: # Github repo owner repo: # Repository name to store issues client_id: # Github Application Client ID client_secret: # Github Application Client Secret admin_user: # GitHub repo owner and collaborators, only these guys can initialize github issues distraction_free_mode: true # Facebook-like distraction free mode # Gitalk&#39;s display language depends on user&#39;s browser or system environment # If you want everyone visiting your site to see a uniform language, you can set a force language value # Available values: en, es-ES, fr, ru, zh-CN, zh-TW language:7. 右上角github12345# &#96;Follow me on GitHub&#96; banner in the top-right corner.github_banner: enable: false &#x2F;&#x2F;修改成true permalink: https:&#x2F;&#x2F;github.com&#x2F;yourname title: Follow me on GitHub8. 创建page(menu标签)在终端窗口下，定位到 Hexo 站点目录下。使用 hexo new page 新建一个页面，命名为 categories ：12$ cd your-hexo-site$ hexo new page categoriescategories目录index.md修改date: 2019-05-08 22:40:04type: “categories”编辑刚新建的页面,设置分类title: 分类date: 2019-06-01 12:39:04categories: Testing #分类名type: “categories”9. 创建文章和草稿12$ cd you-site$ hexo new post(或者draft) &quot;you title&quot;10. 头像显示123456789101112# Sidebar Avataravatar: # In theme directory (source/images): /images/avatar.gif # In site directory (source/uploads): /uploads/avatar.gif # You can also use other linking images. url: /images/user.jpg //使用本地图片 # If true, the avatar would be dispalyed in circle. rounded: true //是否圆形显示 # The value of opacity should be choose from 0 to 1 to set the opacity of the avatar. opacity: 1 //透明度 # If true, the avatar would be rotated with the cursor. rotated: true //是否旋转11. 浏览进度按钮123456back2top: enable: true //是否启用 # Back to top in sidebar. sidebar: false //是否显示在左侧栏下方 # Scroll percent label in b2t button. scrollpercent: true //是否显示阅读进度12. 侧边栏社交图标12345678910# Social Links# Usage: `Key: permalink || icon`social: #E-Mail: mailto:yourname@gmail.com || envelope #Weibo: https://weibo.com/yourname || weibosocial_icons: enable: true icons_only: false //是否只显示图标 transition: true13. 侧边栏其余外部链接12345678# Blog rollslinks_icon: linklinks_title: Links#links_layout: blocklinks_layout: inlinelinks: 移动平台资源整理: https://mobdevgroup.com/ Android Developer: https://developer.android.com/docs14. 修改底部user文字12# If not defined, `author` from Hexo main config will be used. copyright: 'wizzie.top'15. 修改加载进度条12345pace: true# Themes list:# pace-theme-big-counter | pace-theme-bounce | pace-theme-barber-shop | pace-theme-center-atom......pace_theme: pace-theme-barber-shop16. 打开本地搜索123456789local_search: enable: true # If auto, trigger search by changing input. # If manual, trigger search by pressing enter key or search button. trigger: auto # Show top n results per article, show all results by setting to -1 top_n_per_article: -1 # Unescape html strings to the readable one. unescape: false17. 文章顶部显示时间信息12345678# Post meta display settingspost_meta: item_text: true // created_at: true //创建文章时间 updated_at: enable: true //显示更新时间 another_day: true //其他天显示 categories: true //分类显示18. 文章阅读量统计12345678910# Show Views / Visitors of the website / page with busuanzi.# Get more information on http://ibruce.info/2015/04/04/busuanzibusuanzi_count: enable: true total_visitors: true total_visitors_icon: user total_views: true total_views_icon: eye post_views: true post_views_icon: eye8. 修改主题背景custom.styl修改source/_custom/custon.styl文件，详情可以查询其他博客案例。9. 修改文章底部标签#在theme/layout/_macro/post.swig修改标签：12//将原有的#替换成&lt;i class=\"fa fa-tag\"&gt;&lt;/i&gt;&lt;a href=\"&#123;&#123; url_for(tag.path) &#125;&#125;\" rel=\"tag\"&gt;&lt;i class=\"fa fa-tag\"&gt;&lt;/i&gt;&#123;&#123; tag.name &#125;&#125;&lt;/a&gt;10. 修改文章链接样式在theme/next/source/css/custom/custom.styl添加以下内容：1234567891011// 文章内链接文本样式.post-body p a&#123; color: #0593d3; border-bottom: none; border-bottom: 1px solid #0593d3; &amp;:hover &#123; color: #fc6423; border-bottom: none; border-bottom: 1px solid #fc6423; &#125;&#125;效果图：changenote：注意此处的image是放在hexo/source/img/目录下，但是构建之后在public目录下img是一级目录。所以引用的时候不用加上souce/hexo-admin配置后台查看github源项目： https://github.com/jaredly/hexo-admin部署步骤123npm install --save hexo-adminhexo server -dopen http://localhost:4000/admin/hexo的_config.xml配置123456admin: username: zoro password_hash:be121740bf988b2225a313fa1f107ca1 secret: hey hexo deployCommand: './admin_script/hexo-generate.sh' # expire: 60*1","tags":[{"name":"hexo","slug":"hexo","permalink":"http://wizzie.top/tags/hexo/"}]}]